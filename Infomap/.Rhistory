source("functions/calcGraph_binary.R")
source("functions/import_adj_mats.R")
source("functions/setup_graphs.R")
source("functions/setup_community.R")
source("functions/graph_util_redux.R")
source("functions/run_parse_deltacon.R")
source("functions/wibw_module_degree.R")
#get_subj info here, includes motion exclusion procedure
subj_info <- get_subj_info(adjmats_base, parcellation, conn_method, preproc_pipeline, file_extension=".txt.gz")
#import raw adjacency matrices here (subj_info already contains the identified raw files)
allmats <- import_adj_mats(subj_info, rmShort = rmShort, allowCache=FALSE)
#obtain weighted, non-negative weighted, and density-thresholded binary graphs
gobjs <- setup_graphs(allmats, allowCache=FALSE)
#gobjs contains a list of weighted, non-negative weighted, and binary matrices
#pull these out into single variables for simplicity
allg <- gobjs$allg; allg_noneg <- gobjs$allg_noneg; allg_density <- gobjs$allg_density
rm(gobjs) #remove from environment to save memory
########## RS_BPD_pipeline
####read in package dependencies and custom functions
setwd("~/Box Sync/DEPENd/Projects/bpd_rest/")
#setwd("/Users/mnh5174/Data_Analysis/bpd_rest")
basedir <- getwd()
source("functions/setup_globals.R") #this will setup details of the parcellation, conn_method, preproc_pipeline, and connection distance
source("functions/get_subj_info.R")
source("functions/calcGraph_binary.R")
source("functions/import_adj_mats.R")
source("functions/setup_graphs.R")
source("functions/setup_community.R")
source("functions/graph_util_redux.R")
source("functions/run_parse_deltacon.R")
source("functions/wibw_module_degree.R")
#get_subj info here, includes motion exclusion procedure
subj_info <- get_subj_info(adjmats_base, parcellation, conn_method, preproc_pipeline, file_extension=".txt.gz")
#import raw adjacency matrices here (subj_info already contains the identified raw files)
allmats <- import_adj_mats(subj_info, rmShort = rmShort, allowCache=TRUE)
#obtain weighted, non-negative weighted, and density-thresholded binary graphs
gobjs <- setup_graphs(allmats, allowCache=TRUE)
#gobjs contains a list of weighted, non-negative weighted, and binary matrices
#pull these out into single variables for simplicity
allg <- gobjs$allg; allg_noneg <- gobjs$allg_noneg; allg_density <- gobjs$allg_density
rm(gobjs) #remove from environment to save memory
#estimate and setup community structure
comm_weighted_louvain <- run_community_detection_on_agg(allmats, "louvain")
comm_weighted_greedy <- run_community_detection_on_agg(allmats, "fast_greedy")
# comm_weighted_infomap <- run_community_detection_on_agg(allmats, "infomap")
allg_noneg_comm1 <- get.vertex.attribute(allg_noneg$`001RA`)$name
allg_noneg_comm1
allg_noneg_comm1 <- as.numeric(get.vertex.attribute(allg_noneg$`001RA`)$name)
allg_noneg_comm1
allg_noneg_comm1 <- gsub("V", "", get.vertex.attribute(allg_noneg$`001RA`)$name)
allg_noneg_comm1
allg_noneg_comm1 <- as.numeric(gsub("V", "", get.vertex.attribute(allg_noneg$`001RA`)$name))
allg_noneg_comm1
get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain
allg_noneg <- assign_communities(allg_noneg, comm_weighted_louvain, "comm_weighted_louvain")
get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain
length(get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain)
which(get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1)
as.numeric(gsub("V", "", get.vertex.attribute(allg_noneg$`001RA`)$name))
as.numeric(gsub("V", "", get.vertex.attribute(allg_noneg$`001RA`)$name))[1:10]
which(get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1)
get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain
as.numeric(gsub("V", "", get.vertex.attribute(allg_noneg$`001RA`)$name))[which(get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1)]
conn_method
allg_noneg_comm1 <- as.numeric(gsub("V", "", get.vertex.attribute(allg_noneg$`001RA`)$name))[which(get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1)]
allg_noneg_comm1
class(allg_noneg_comm1)
node.file <- NodeFile(atlas = atlas,
community = get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1,
nnodes = nnodes,
nodestp = allg_noneg_comm1,
labels = 0,
filename = paste0(parcellation, "_", preproc_pipeline, "_", conn_method, "_comm_weighted_louvain_1"),
outputdir = paste0(getwd(), "/BNV_nodefiles/weighted_ridge_comms")
)
NodeFile <- function(atlas, community = NULL, nodestp = NULL, nodevals = NULL, nnodes, labels, filename,outputdir){
#nodestp provides vector of node numbers that need to be plotted
#community can be set to community membership, whether higher in BPD/ controls, or anything else
#labels set equal to either 1 (full anatomical label) or 2 (node number [i.e. V_1...])
nf <- atlas
#if want to read in a csv rather than a predfined atlas in R
#nf <- read.csv(atlas, header = TRUE)        #####csv file should have at least mni attributes and anatomical labels
vnames <- data.frame(atlas[,"name"])
names(vnames) = "vname"
stopifnot(all(c("x.mni", "y.mni", "z.mni", "anat_label") %in% names(nf)))
row.names(nf) <- c(seq(1, 248, 1), seq(251, 271, 1))
if(!is.null(community)){
commvals <- community
names(commvals) <- vnames$vname
} else {
commvals = rep(1,length(vnames[,1]))
names(commvals) <- vnames$vname
}
browser()
if(!is.null(nodestp)) {
nf <- nf[which(nf$vname %in% nodestp),]
commvals <- commvals[which(as.numeric(names(commvals)) %in% nodestp)]
# nf$anat_label <- paste0("V_", nf$vname)
# nf <- nf %>% select(-vname)
names(nodevals) <- vnames$vname
if(is.null(nodevals)){
nodevals <- rep(1, length(nodestp))
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
} else {
if(is.null(nodevals)){
nodevals <- rep(1, nnodes)
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
}
mni <- subset(nf, select = c(x.mni, y.mni, z.mni))
if(labels == 1){
node_label <- subset(nf, select = anat_label)
} else if(labels == 0) {node_label <- paste0("V", row.names(nf))}
# browser()
nf.exp <- cbind(mni, commvals, nodevals, node_label)
write.table(nf.exp, file = file.path(outputdir, paste0(filename, ".node.txt")), row.names = FALSE, col.names = FALSE)
return(nf.exp)
}
node.file <- NodeFile(atlas = atlas,
community = get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1,
nnodes = nnodes,
nodestp = allg_noneg_comm1,
labels = 0,
filename = paste0(parcellation, "_", preproc_pipeline, "_", conn_method, "_comm_weighted_louvain_1"),
outputdir = paste0(getwd(), "/BNV_nodefiles/weighted_ridge_comms")
)
!is.null(nodestp)
nf <- nf[which(nf$vname %in% nodestp),]
nf
nf <- atlas
#if want to read in a csv rather than a predfined atlas in R
#nf <- read.csv(atlas, header = TRUE)        #####csv file should have at least mni attributes and anatomical labels
vnames <- data.frame(atlas[,"name"])
names(vnames) = "vname"
stopifnot(all(c("x.mni", "y.mni", "z.mni", "anat_label") %in% names(nf)))
row.names(nf) <- c(seq(1, 248, 1), seq(251, 271, 1))
if(!is.null(community)){
commvals <- community
names(commvals) <- vnames$vname
} else {
commvals = rep(1,length(vnames[,1]))
names(commvals) <- vnames$vname
}
nf
nf$vname
vnames
NodeFile <- function(atlas, community = NULL, nodestp = NULL, nodevals = NULL, nnodes, labels, filename,outputdir){
#nodestp provides vector of node numbers that need to be plotted
#community can be set to community membership, whether higher in BPD/ controls, or anything else
#labels set equal to either 1 (full anatomical label) or 2 (node number [i.e. V_1...])
nf <- atlas
#if want to read in a csv rather than a predfined atlas in R
#nf <- read.csv(atlas, header = TRUE)        #####csv file should have at least mni attributes and anatomical labels
vnames <- data.frame(atlas[,"name"])
names(vnames) = "vname"
stopifnot(all(c("x.mni", "y.mni", "z.mni", "anat_label") %in% names(nf)))
row.names(nf) <- c(seq(1, 248, 1), seq(251, 271, 1))
if(!is.null(community)){
commvals <- community
names(commvals) <- vnames$vname
} else {
commvals = rep(1,length(vnames[,1]))
names(commvals) <- vnames$vname
}
# browser()
if(!is.null(nodestp)) {
nf <- nf[which(nf$name %in% nodestp),]
commvals <- commvals[which(as.numeric(names(commvals)) %in% nodestp)]
# nf$anat_label <- paste0("V_", nf$vname)
# nf <- nf %>% select(-vname)
names(nodevals) <- vnames$vname
if(is.null(nodevals)){
nodevals <- rep(1, length(nodestp))
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
} else {
if(is.null(nodevals)){
nodevals <- rep(1, nnodes)
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
}
mni <- subset(nf, select = c(x.mni, y.mni, z.mni))
if(labels == 1){
node_label <- subset(nf, select = anat_label)
} else if(labels == 0) {node_label <- paste0("V", row.names(nf))}
# browser()
nf.exp <- cbind(mni, commvals, nodevals, node_label)
write.table(nf.exp, file = file.path(outputdir, paste0(filename, ".node.txt")), row.names = FALSE, col.names = FALSE)
return(nf.exp)
}
node.file <- NodeFile(atlas = atlas,
community = get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1,
nnodes = nnodes,
nodestp = allg_noneg_comm1,
labels = 0,
filename = paste0(parcellation, "_", preproc_pipeline, "_", conn_method, "_comm_weighted_louvain_1"),
outputdir = paste0(getwd(), "/BNV_nodefiles/weighted_ridge_comms")
)
NodeFile <- function(atlas, community = NULL, nodestp = NULL, nodevals = NULL, nnodes, labels, filename,outputdir){
#nodestp provides vector of node numbers that need to be plotted
#community can be set to community membership, whether higher in BPD/ controls, or anything else
#labels set equal to either 1 (full anatomical label) or 2 (node number [i.e. V_1...])
nf <- atlas
#if want to read in a csv rather than a predfined atlas in R
#nf <- read.csv(atlas, header = TRUE)        #####csv file should have at least mni attributes and anatomical labels
vnames <- data.frame(atlas[,"name"])
names(vnames) = "vname"
stopifnot(all(c("x.mni", "y.mni", "z.mni", "anat_label") %in% names(nf)))
row.names(nf) <- c(seq(1, 248, 1), seq(251, 271, 1))
if(!is.null(community)){
commvals <- community
names(commvals) <- vnames$vname
} else {
commvals = rep(1,length(vnames[,1]))
names(commvals) <- vnames$vname
}
browser()
if(!is.null(nodestp)) {
nf <- nf[which(nf$name %in% nodestp),]
commvals <- commvals[which(as.numeric(names(commvals)) %in% nodestp)]
# nf$anat_label <- paste0("V_", nf$vname)
# nf <- nf %>% select(-vname)
names(nodevals) <- vnames$vname
if(is.null(nodevals)){
nodevals <- rep(1, length(nodestp))
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
} else {
if(is.null(nodevals)){
nodevals <- rep(1, nnodes)
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
}
mni <- subset(nf, select = c(x.mni, y.mni, z.mni))
if(labels == 1){
node_label <- subset(nf, select = anat_label)
} else if(labels == 0) {node_label <- paste0("V", row.names(nf))}
# browser()
nf.exp <- cbind(mni, commvals, nodevals, node_label)
write.table(nf.exp, file = file.path(outputdir, paste0(filename, ".node.txt")), row.names = FALSE, col.names = FALSE)
return(nf.exp)
}
node.file <- NodeFile(atlas = atlas,
community = get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1,
nnodes = nnodes,
nodestp = allg_noneg_comm1,
labels = 0,
filename = paste0(parcellation, "_", preproc_pipeline, "_", conn_method, "_comm_weighted_louvain_1"),
outputdir = paste0(getwd(), "/BNV_nodefiles/weighted_ridge_comms")
)
node.file <- NodeFile(atlas = atlas,
community = get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1,
nnodes = nnodes,
nodestp = allg_noneg_comm1,
labels = 0,
filename = paste0(parcellation, "_", preproc_pipeline, "_", conn_method, "_comm_weighted_louvain_1"),
outputdir = paste0(getwd(), "/BNV_nodefiles/weighted_ridge_comms")
)
nodestp
nf <- nf[which(nf$name %in% nodestp),]
nf
nf$name
nf <- atlas
vnames <- data.frame(atlas[,"name"])
names(vnames) = "vname"
stopifnot(all(c("x.mni", "y.mni", "z.mni", "anat_label") %in% names(nf)))
row.names(nf) <- c(seq(1, 248, 1), seq(251, 271, 1))
nf
nf$name
allg_noneg_comm1 <- get.vertex.attribute(allg_noneg$`001RA`)$name)[which(get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1)]
allg_noneg_comm1 <- get.vertex.attribute(allg_noneg$`001RA`)$name[which(get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1)]
allg_noneg_comm1
node.file <- NodeFile(atlas = atlas,
community = get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1,
nnodes = nnodes,
nodestp = allg_noneg_comm1,
labels = 0,
filename = paste0(parcellation, "_", preproc_pipeline, "_", conn_method, "_comm_weighted_louvain_1"),
outputdir = paste0(getwd(), "/BNV_nodefiles/weighted_ridge_comms")
)
nodestp
nf$name
nf <- nf[which(nf$name %in% nodestp),]
nf
commvals <- commvals[which(as.numeric(names(commvals)) %in% nodestp)]
names(nodevals) <- vnames$vname
vnames$vname
nodevals
names(nodevals) <- vnames$vname
is.null(nodevals)
nodevals <- rep(1, length(nodestp))
nodevals
mni <- subset(nf, select = c(x.mni, y.mni, z.mni))
if(labels == 1){
node_label <- subset(nf, select = anat_label)
} else if(labels == 0) {node_label <- paste0("V", row.names(nf))}
nf.exp <- cbind(mni, commvals, nodevals, node_label)
nf.exp
nf.exp
node_label
mni
nodevals
node_label
nf.exp <- cbind(mni, commvals, nodevals, node_label)
mni
length(mni[,1])
length(commvals)
commvals
!is.null(community)
commvals <- community
commvals
names(commvals) <- vnames$vname
commvals
community
get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1
NodeFile <- function(atlas, community = NULL, nodestp = NULL, nodevals = NULL, nnodes, labels, filename,outputdir){
#nodestp provides vector of node numbers that need to be plotted
#community can be set to community membership, whether higher in BPD/ controls, or anything else
#labels set equal to either 1 (full anatomical label) or 2 (node number [i.e. V_1...])
nf <- atlas
#if want to read in a csv rather than a predfined atlas in R
#nf <- read.csv(atlas, header = TRUE)        #####csv file should have at least mni attributes and anatomical labels
vnames <- data.frame(atlas[,"name"])
names(vnames) = "vname"
stopifnot(all(c("x.mni", "y.mni", "z.mni", "anat_label") %in% names(nf)))
row.names(nf) <- c(seq(1, 248, 1), seq(251, 271, 1))
if(!is.null(community)){
commvals <- community
names(commvals) <- vnames$vname
} else {
commvals = rep(1,length(vnames[,1]))
names(commvals) <- vnames$vname
}
browser()
if(!is.null(nodestp)) {
nf <- nf[which(nf$name %in% nodestp),]
commvals <- commvals[which(as.numeric(names(commvals)) %in% nodestp)]
# nf$anat_label <- paste0("V_", nf$vname)
# nf <- nf %>% select(-vname)
#names(nodevals) <- vnames$vname
if(is.null(nodevals)){
nodevals <- rep(1, length(nodestp))
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
} else {
if(is.null(nodevals)){
nodevals <- rep(1, nnodes)
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
}
mni <- subset(nf, select = c(x.mni, y.mni, z.mni))
if(labels == 1){
node_label <- subset(nf, select = anat_label)
} else if(labels == 0) {node_label <- paste0("V", row.names(nf))}
# browser()
nf.exp <- cbind(mni, commvals, nodevals, node_label)
write.table(nf.exp, file = file.path(outputdir, paste0(filename, ".node.txt")), row.names = FALSE, col.names = FALSE)
return(nf.exp)
}
NodeFile <- function(atlas, community = NULL, nodestp = NULL, nodevals = NULL, nnodes, labels, filename,outputdir){
#nodestp provides vector of node numbers that need to be plotted
#community can be set to community membership, whether higher in BPD/ controls, or anything else
#labels set equal to either 1 (full anatomical label) or 2 (node number [i.e. V_1...])
nf <- atlas
#if want to read in a csv rather than a predfined atlas in R
#nf <- read.csv(atlas, header = TRUE)        #####csv file should have at least mni attributes and anatomical labels
vnames <- data.frame(atlas[,"name"])
names(vnames) = "vname"
stopifnot(all(c("x.mni", "y.mni", "z.mni", "anat_label") %in% names(nf)))
row.names(nf) <- c(seq(1, 248, 1), seq(251, 271, 1))
if(!is.null(community)){
commvals <- community
names(commvals) <- vnames$vname
} else {
commvals = rep(1,length(vnames[,1]))
names(commvals) <- vnames$vname
}
# browser()
if(!is.null(nodestp)) {
nf <- nf[which(nf$name %in% nodestp),]
commvals <- commvals[which(as.numeric(names(commvals)) %in% nodestp)]
# nf$anat_label <- paste0("V_", nf$vname)
# nf <- nf %>% select(-vname)
#names(nodevals) <- vnames$vname
if(is.null(nodevals)){
nodevals <- rep(1, length(nodestp))
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
} else {
if(is.null(nodevals)){
nodevals <- rep(1, nnodes)
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
}
mni <- subset(nf, select = c(x.mni, y.mni, z.mni))
if(labels == 1){
node_label <- subset(nf, select = anat_label)
} else if(labels == 0) {node_label <- paste0("V", row.names(nf))}
# browser()
nf.exp <- cbind(mni, commvals, nodevals, node_label)
write.table(nf.exp, file = file.path(outputdir, paste0(filename, ".node.txt")), row.names = FALSE, col.names = FALSE)
return(nf.exp)
}
NodeFile <- function(atlas, community = NULL, nodestp = NULL, nodevals = NULL, nnodes, labels, filename,outputdir){
#nodestp provides vector of node numbers that need to be plotted
#community can be set to community membership, whether higher in BPD/ controls, or anything else
#labels set equal to either 1 (full anatomical label) or 2 (node number [i.e. V_1...])
nf <- atlas
#if want to read in a csv rather than a predfined atlas in R
#nf <- read.csv(atlas, header = TRUE)        #####csv file should have at least mni attributes and anatomical labels
vnames <- data.frame(atlas[,"name"])
names(vnames) = "vname"
stopifnot(all(c("x.mni", "y.mni", "z.mni", "anat_label") %in% names(nf)))
row.names(nf) <- c(seq(1, 248, 1), seq(251, 271, 1))
if(!is.null(community)){
commvals <- community
names(commvals) <- vnames$vname
} else {
commvals = rep(1,length(vnames[,1]))
names(commvals) <- vnames$vname
}
# browser()
if(!is.null(nodestp)) {
nf <- nf[which(nf$name %in% nodestp),]
commvals <- commvals[which(as.numeric(names(commvals)) %in% nodestp)]
# nf$anat_label <- paste0("V_", nf$vname)
# nf <- nf %>% select(-vname)
#names(nodevals) <- vnames$vname
if(is.null(nodevals)){
nodevals <- rep(1, length(nodestp))
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
} else {
if(is.null(nodevals)){
nodevals <- rep(1, nnodes)
} else {
nodevals <- nodevals[which(as.numeric(names(nodevals)) %in% nodestp)]
}
}
mni <- subset(nf, select = c(x.mni, y.mni, z.mni))
if(labels == 1){
node_label <- subset(nf, select = anat_label)
} else if(labels == 0) {node_label <- paste0("V", row.names(nf))}
# browser()
nf.exp <- cbind(mni, commvals, nodevals, node_label)
write.table(nf.exp, file = file.path(outputdir, paste0(filename, ".node.txt")), row.names = FALSE, col.names = FALSE)
return(nf.exp)
}
node.file <- NodeFile(atlas = atlas,
# community = get.vertex.attribute(allg_noneg$`001RA`)$comm_weighted_louvain == 1,
nnodes = nnodes,
nodestp = allg_noneg_comm1,
labels = 0,
filename = paste0(parcellation, "_", preproc_pipeline, "_", conn_method, "_comm_weighted_louvain_1"),
outputdir = paste0(getwd(), "/BNV_nodefiles/weighted_ridge_comms")
)
########## RS_BPD_pipeline
####read in package dependencies and custom functions
setwd("~/Box Sync/DEPENd/Projects/RS_BPD_graph/bpd_rest/")
#setwd("/Users/mnh5174/Data_Analysis/bpd_rest")
basedir <- getwd()
source("functions/setup_globals.R") #this will setup details of the parcellation, conn_method, preproc_pipeline, and connection distance
source("functions/get_subj_info.R")
source("functions/calcGraph_binary.R")
source("functions/import_adj_mats.R")
source("functions/setup_graphs.R")
source("functions/setup_community.R")
source("functions/graph_util_redux.R")
source("functions/run_parse_deltacon.R")
source("functions/wibw_module_degree.R")
source("Infomap/infomap_communities.R")
#get_subj info here, includes motion exclusion procedure
subj_info <- get_subj_info(adjmats_base, parcellation, conn_method, preproc_pipeline, file_extension=".txt.gz")
#import raw adjacency matrices here (subj_info already contains the identified raw files)
allmats <- import_adj_mats(subj_info, rmShort = rmShort, allowCache=TRUE)
#obtain weighted, non-negative weighted, and density-thresholded binary graphs
gobjs <- setup_graphs(allmats, allowCache=TRUE)
#gobjs contains a list of weighted, non-negative weighted, and binary matrices
#pull these out into single variables for simplicity
allg <- gobjs$allg; allg_noneg <- gobjs$allg_noneg; allg_density <- gobjs$allg_density
rm(gobjs) #remove from environment to save memory
#estimate and setup community structure
comm_weighted_louvain <- run_community_detection_on_agg(allmats, "louvain")
comm_weighted_greedy <- run_community_detection_on_agg(allmats, "fast_greedy")
# comm_weighted_infomap <- run_community_detection_on_agg(allmats, "infomap")
comm_d05 <- run_community_detection_on_agg(allmats, "louvain", density=0.05)
comm_d10 <- run_community_detection_on_agg(allmats, "louvain", density=0.10)
comm_d15 <- run_community_detection_on_agg(allmats, "louvain", density = 0.15)
comm_d20 <- run_community_detection_on_agg(allmats, "louvain", density=0.20)
# compare(comm_weighted_louvain, comm_d05, method="nmi")
# compare(comm_weighted_louvain, comm_d10, method="nmi")
# compare(comm_weighted_louvain, comm_d15, method = "nmi")
# compare(comm_weighted_louvain, comm_d20, method = "nmi")
# compare(comm_weighted_louvain, comm_weighted_greedy)
# compare(comm_d20, comm_d10, method = "nmi")
# compare(comm_d05, comm_weighted_greedy, method="nmi")
# compare(comm_weighted_louvain, comm_d15, method="nmi")
# compare(comm_weighted_louvain, comm_d20, method="nmi")
# compare(comm_weighted_louvain, comm_weighted_greedy, method="nmi")
comm_infomap_d10 <- run_community_detection_on_agg(allmats, "infomap", density=0.10)
