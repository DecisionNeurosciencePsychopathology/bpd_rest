# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -outdir build/R -o build/R/infomap_wrap.cpp build/R/Infomap.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t', contains = 'C++Reference')
setClass('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', contains = 'C++Reference')
setClass('_p_Infomap', contains = 'C++Reference')
setClass('_p_MemInfomap', contains = 'C++Reference')
setClass('_p_ElapsedTime', contains = 'C++Reference')
setClass('_p_Date', contains = 'C++Reference')
setClass('_p_Config', contains = 'ExternalReference')
setClass("Config",
    representation(
        parsedArgs = "character",
        networkFile = "character",
        additionalInput = "character",
        inputFormat = "character",
        withMemory = "logical",
        bipartite = "logical",
        skipAdjustBipartiteFlow = "logical",
        multiplexAddMissingNodes = "logical",
        hardPartitions = "logical",
        nonBacktracking = "logical",
        parseWithoutIOStreams = "logical",
        zeroBasedNodeNumbers = "logical",
        includeSelfLinks = "logical",
        ignoreEdgeWeights = "logical",
        completeDanglingMemoryNodes = "logical",
        nodeLimit = "integer",
        preClusterMultiplex = "logical",
        clusterDataFile = "character",
        noInfomap = "logical",
        twoLevel = "logical",
        directed = "logical",
        undirdir = "logical",
        outdirdir = "logical",
        rawdir = "logical",
        recordedTeleportation = "logical",
        teleportToNodes = "logical",
        teleportationProbability = "numeric",
        selfTeleportationProbability = "numeric",
        markovTime = "numeric",
        variableMarkovTime = "logical",
        preferredNumberOfModules = "integer",
        multiplexRelaxRate = "numeric",
        multiplexJSRelaxRate = "numeric",
        multiplexJSRelaxLimit = "numeric",
        multiplexRelaxLimit = "integer",
        seedToRandomNumberGenerator = "integer",
        numTrials = "integer",
        minimumCodelengthImprovement = "numeric",
        minimumSingleNodeCodelengthImprovement = "numeric",
        randomizeCoreLoopLimit = "logical",
        coreLoopLimit = "integer",
        levelAggregationLimit = "integer",
        tuneIterationLimit = "integer",
        minimumRelativeTuneIterationImprovement = "numeric",
        fastCoarseTunePartition = "logical",
        alternateCoarseTuneLevel = "logical",
        coarseTuneLevel = "integer",
        fastHierarchicalSolution = "integer",
        fastFirstIteration = "logical",
        lowMemoryPriority = "integer",
        innerParallelization = "logical",
        resetConfigBeforeRecursion = "logical",
        outDirectory = "character",
        outName = "character",
        originallyUndirected = "logical",
        printTree = "logical",
        printFlowTree = "logical",
        printMap = "logical",
        printClu = "logical",
        printNodeRanks = "logical",
        printFlowNetwork = "logical",
        printPajekNetwork = "logical",
        printStateNetwork = "logical",
        printBinaryTree = "logical",
        printBinaryFlowTree = "logical",
        printExpanded = "logical",
        noFileOutput = "logical",
        verbosity = "integer",
        verboseNumberPrecision = "integer",
        silent = "logical",
        benchmark = "logical",
        maxNodeIndexVisible = "integer",
        showBiNodes = "logical",
        minBipartiteNodeIndex = "integer",
        version = "character"),
        contains = "RSWIGStruct")


# End class Config

setClass('_p_Network', contains = 'C++Reference')
setClass('_p_Bigram', contains = 'ExternalReference')
setClass("Bigram",
    representation(
        first = "integer",
        second = "integer"),
        contains = "RSWIGStruct")


# End class Bigram

setClass('_p_BipartiteLink', contains = 'ExternalReference')
setClass("BipartiteLink",
    representation(
        featureNode = "integer",
        node = "integer",
        swapOrder = "logical"),
        contains = "RSWIGStruct")


# End class BipartiteLink

setClass('_p_Weight', contains = 'ExternalReference')
setClass("Weight",
    representation(
        weight = "numeric"),
        contains = "RSWIGStruct")


# End class Weight

setClass('_p_Triple', contains = 'ExternalReference')
setClass("Triple",
    representation(
        n1 = "integer",
        n2 = "integer",
        n3 = "integer"),
        contains = "RSWIGStruct")


# End class Triple

setClass('_p_Link', contains = 'ExternalReference')
setClass("Link",
    representation(
        n1 = "integer",
        n2 = "integer",
        weight = "numeric"),
        contains = "RSWIGStruct")


# End class Link

setClass('_p_ComplementaryData', contains = 'ExternalReference')
setClass("ComplementaryData",
    representation(
        sumWeightExactMatch = "numeric",
        sumWeightPartialMatch = "numeric",
        sumWeightShiftedMatch = "numeric"),
        contains = "RSWIGStruct")


# End class ComplementaryData

setClass('_p_MemNetwork', contains = c('_p_Network'))
setClass('_p_MultiplexNetwork', contains = c('_p_MemNetwork'))
setClass('_p_NodeData', contains = 'ExternalReference')
setClass("NodeData",
    representation(
        flow = "numeric",
        enterFlow = "numeric",
        exitFlow = "numeric",
        teleportRate = "numeric",
        danglingFlow = "numeric",
        indexCodelength = "numeric",
        moduleCodelength = "numeric",
        name = "character"),
        contains = "RSWIGStruct")


# End class NodeData

setClass('_p_ChildEdge', contains = 'ExternalReference')
setClass("ChildEdge",
    representation(
        source = "integer",
        target = "integer",
        flow = "numeric"),
        contains = "RSWIGStruct")


# End class ChildEdge

setClass('_p_EdgeComp', contains = 'ExternalReference')
setClass("EdgeComp",
    representation(
),
        contains = "RSWIGStruct")


# End class EdgeComp

setClass('_p_SNode', contains = 'C++Reference')
setClass('_p_LeafIterator', contains = 'C++Reference')
setClass('_p_TreeIterator', contains = 'C++Reference')
setClass('_p_ChildIterator', contains = 'C++Reference')
setClass('_p_HierarchicalNetwork', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of StringVector___nonzero__

`StringVector___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector___nonzero__', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector___nonzero__`, 'returnType') = 'logical'
attr(`StringVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___nonzero__`) = c("SWIGFunction", class('StringVector___nonzero__'))

# Start of StringVector___len__

`StringVector___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector___len__', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector___len__`, 'returnType') = 'integer'
attr(`StringVector___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___len__`) = c("SWIGFunction", class('StringVector___len__'))

# Start of StringVector_pop

`StringVector_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_pop', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector_pop`, 'returnType') = 'character'
attr(`StringVector_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_pop`) = c("SWIGFunction", class('StringVector_pop'))

# Start of StringVector___getslice__

`StringVector___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_StringVector___getslice__', self, i, j, PACKAGE='infomap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`StringVector___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StringVector___getslice__`) = c("SWIGFunction", class('StringVector___getslice__'))

# Start of StringVector___setslice__

`StringVector___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_StringVector___setslice__', self, i, j, v, PACKAGE='infomap');
  
}

attr(`StringVector___setslice__`, 'returnType') = 'void'
attr(`StringVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___setslice__`) = c("SWIGFunction", class('StringVector___setslice__'))

# Start of StringVector___delslice__

`StringVector___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_StringVector___delslice__', self, i, j, PACKAGE='infomap');
  
}

attr(`StringVector___delslice__`, 'returnType') = 'void'
attr(`StringVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StringVector___delslice__`) = c("SWIGFunction", class('StringVector___delslice__'))

# Start of StringVector___delitem__

`StringVector___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StringVector___delitem__', self, i, PACKAGE='infomap');
  
}

attr(`StringVector___delitem__`, 'returnType') = 'void'
attr(`StringVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector___delitem__`) = c("SWIGFunction", class('StringVector___delitem__'))

# Start of StringVector___getitem__

`StringVector___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StringVector___getitem__', self, i, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector___getitem__`, 'returnType') = 'character'
attr(`StringVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector___getitem__`) = c("SWIGFunction", class('StringVector___getitem__'))

# Start of StringVector___setitem__

`StringVector___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector___setitem__', self, i, x, PACKAGE='infomap');
  
}

attr(`StringVector___setitem__`, 'returnType') = 'void'
attr(`StringVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector___setitem__`) = c("SWIGFunction", class('StringVector___setitem__'))

# Start of StringVector_append

`StringVector_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_append', self, x, PACKAGE='infomap');
  
}

attr(`StringVector_append`, 'returnType') = 'void'
attr(`StringVector_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StringVector_append`) = c("SWIGFunction", class('StringVector_append'))

# Start of new_StringVector

`StringVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_StringVector__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`StringVector__SWIG_0`) = c("SWIGFunction", class('StringVector__SWIG_0'))

# Start of new_StringVector

`StringVector__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_StringVector__SWIG_1', s_arg1, PACKAGE='infomap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector__SWIG_1`) = c("SWIGFunction", class('StringVector__SWIG_1'))

# Start of StringVector_empty

`StringVector_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector_empty`, 'returnType') = 'logical'
attr(`StringVector_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_empty`) = c("SWIGFunction", class('StringVector_empty'))

# Start of StringVector_size

`StringVector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector_size`, 'returnType') = 'integer'
attr(`StringVector_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_size`) = c("SWIGFunction", class('StringVector_size'))

# Start of StringVector_swap

`StringVector_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_StringVector_swap', self, v, PACKAGE='infomap');
  
}

attr(`StringVector_swap`, 'returnType') = 'void'
attr(`StringVector_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_swap`) = c("SWIGFunction", class('StringVector_swap'))

# Start of StringVector_clear

`StringVector_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_clear', self, PACKAGE='infomap');
  
}

attr(`StringVector_clear`, 'returnType') = 'void'
attr(`StringVector_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_clear`) = c("SWIGFunction", class('StringVector_clear'))

# Start of StringVector_get_allocator

`StringVector_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_StringVector_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_std__allocatorT_std__string_t", ref=ans);
  
  ans
  
}

attr(`StringVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`StringVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_get_allocator`) = c("SWIGFunction", class('StringVector_get_allocator'))

# Start of new_StringVector

`StringVector__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_StringVector__SWIG_2', size, PACKAGE='infomap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_2`, "inputTypes") = c('integer')
class(`StringVector__SWIG_2`) = c("SWIGFunction", class('StringVector__SWIG_2'))

# Start of StringVector_pop_back

`StringVector_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_pop_back', self, PACKAGE='infomap');
  
}

attr(`StringVector_pop_back`, 'returnType') = 'void'
attr(`StringVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_pop_back`) = c("SWIGFunction", class('StringVector_pop_back'))

# Start of StringVector_resize

`StringVector_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_StringVector_resize__SWIG_0', self, new_size, PACKAGE='infomap');
  
}

attr(`StringVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`StringVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector_resize__SWIG_0`) = c("SWIGFunction", class('StringVector_resize__SWIG_0'))

# Start of new_StringVector

`StringVector__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_StringVector__SWIG_3', size, value, PACKAGE='infomap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`StringVector__SWIG_3`) = c("SWIGFunction", class('StringVector__SWIG_3'))

`StringVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- StringVector__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- StringVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1) {
      f <- StringVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- StringVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for StringVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StringVector_push_back

`StringVector_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_push_back', self, x, PACKAGE='infomap');
  
}

attr(`StringVector_push_back`, 'returnType') = 'void'
attr(`StringVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StringVector_push_back`) = c("SWIGFunction", class('StringVector_push_back'))

# Start of StringVector_front

`StringVector_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_front', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector_front`, 'returnType') = 'character'
attr(`StringVector_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_front`) = c("SWIGFunction", class('StringVector_front'))

# Start of StringVector_back

`StringVector_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_back', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector_back`, 'returnType') = 'character'
attr(`StringVector_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_back`) = c("SWIGFunction", class('StringVector_back'))

# Start of StringVector_assign

`StringVector_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_assign', self, n, x, PACKAGE='infomap');
  
}

attr(`StringVector_assign`, 'returnType') = 'void'
attr(`StringVector_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector_assign`) = c("SWIGFunction", class('StringVector_assign'))

# Start of StringVector_resize

`StringVector_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_resize__SWIG_1', self, new_size, x, PACKAGE='infomap');
  
}

attr(`StringVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`StringVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector_resize__SWIG_1`) = c("SWIGFunction", class('StringVector_resize__SWIG_1'))

`StringVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- StringVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- StringVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StringVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StringVector_reserve

`StringVector_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_StringVector_reserve', self, n, PACKAGE='infomap');
  
}

attr(`StringVector_reserve`, 'returnType') = 'void'
attr(`StringVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector_reserve`) = c("SWIGFunction", class('StringVector_reserve'))

# Start of StringVector_capacity

`StringVector_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_capacity', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StringVector_capacity`, 'returnType') = 'integer'
attr(`StringVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_capacity`) = c("SWIGFunction", class('StringVector_capacity'))

# Start of delete_StringVector

`delete_StringVector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_StringVector', self, PACKAGE='infomap');
  
}

attr(`delete_StringVector`, 'returnType') = 'void'
attr(`delete_StringVector`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_StringVector`) = c("SWIGFunction", class('delete_StringVector'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = StringVector___nonzero__, '__len__' = StringVector___len__, 'pop' = StringVector_pop, '__getslice__' = StringVector___getslice__, '__setslice__' = StringVector___setslice__, '__delslice__' = StringVector___delslice__, '__delitem__' = StringVector___delitem__, '__getitem__' = StringVector___getitem__, '__setitem__' = StringVector___setitem__, 'append' = StringVector_append, 'empty' = StringVector_empty, 'size' = StringVector_size, 'swap' = StringVector_swap, 'clear' = StringVector_clear, 'get_allocator' = StringVector_get_allocator, 'pop_back' = StringVector_pop_back, 'resize' = StringVector_resize, 'push_back' = StringVector_push_back, 'front' = StringVector_front, 'back' = StringVector_back, 'assign' = StringVector_assign, 'reserve' = StringVector_reserve, 'capacity' = StringVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of new_StateNodeMap

`StateNodeMap__SWIG_0` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_StateNodeMap__SWIG_0', s_arg1, PACKAGE='infomap');
  ans <- new("_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StateNodeMap)
  ans
  
}

attr(`StateNodeMap__SWIG_0`, 'returnType') = '_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t'
attr(`StateNodeMap__SWIG_0`, "inputTypes") = c('_p_std__lessT_StateNode_t')
class(`StateNodeMap__SWIG_0`) = c("SWIGFunction", class('StateNodeMap__SWIG_0'))

# Start of new_StateNodeMap

`StateNodeMap__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_StateNodeMap__SWIG_1', PACKAGE='infomap');
  ans <- new("_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StateNodeMap)
  ans
  
}

attr(`StateNodeMap__SWIG_1`, 'returnType') = '_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t'
class(`StateNodeMap__SWIG_1`) = c("SWIGFunction", class('StateNodeMap__SWIG_1'))

# Start of new_StateNodeMap

`StateNodeMap__SWIG_2` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_StateNodeMap__SWIG_2', s_arg1, PACKAGE='infomap');
  ans <- new("_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StateNodeMap)
  ans
  
}

attr(`StateNodeMap__SWIG_2`, 'returnType') = '_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t'
attr(`StateNodeMap__SWIG_2`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t')
class(`StateNodeMap__SWIG_2`) = c("SWIGFunction", class('StateNodeMap__SWIG_2'))

`StateNodeMap` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- StateNodeMap__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_std__lessT_StateNode_t') && length(argv[[1]]) == 1) {
      f <- StateNodeMap__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t') && length(argv[[1]]) == 1) {
      f <- StateNodeMap__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for StateNodeMap with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StateNodeMap_empty

`StateNodeMap_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StateNodeMap_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNodeMap_empty`, 'returnType') = 'logical'
attr(`StateNodeMap_empty`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t')
class(`StateNodeMap_empty`) = c("SWIGFunction", class('StateNodeMap_empty'))

# Start of StateNodeMap_size

`StateNodeMap_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StateNodeMap_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNodeMap_size`, 'returnType') = 'integer'
attr(`StateNodeMap_size`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t')
class(`StateNodeMap_size`) = c("SWIGFunction", class('StateNodeMap_size'))

# Start of StateNodeMap_swap

`StateNodeMap_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_StateNodeMap_swap', self, v, PACKAGE='infomap');
  
}

attr(`StateNodeMap_swap`, 'returnType') = 'void'
attr(`StateNodeMap_swap`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t', '_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t')
class(`StateNodeMap_swap`) = c("SWIGFunction", class('StateNodeMap_swap'))

# Start of StateNodeMap_clear

`StateNodeMap_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StateNodeMap_clear', self, PACKAGE='infomap');
  
}

attr(`StateNodeMap_clear`, 'returnType') = 'void'
attr(`StateNodeMap_clear`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t')
class(`StateNodeMap_clear`) = c("SWIGFunction", class('StateNodeMap_clear'))

# Start of StateNodeMap_get_allocator

`StateNodeMap_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_StateNodeMap_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_std__allocatorT_std__pairT_StateNode_const_double_t_t", ref=ans);
  
  ans
  
}

attr(`StateNodeMap_get_allocator`, 'returnType') = '_p_std__allocatorT_std__pairT_StateNode_const_double_t_t'
attr(`StateNodeMap_get_allocator`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t')
class(`StateNodeMap_get_allocator`) = c("SWIGFunction", class('StateNodeMap_get_allocator'))

# Start of StateNodeMap_erase

`StateNodeMap_erase` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_StateNodeMap_erase', self, x, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNodeMap_erase`, 'returnType') = 'integer'
attr(`StateNodeMap_erase`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t', '_p_StateNode')
class(`StateNodeMap_erase`) = c("SWIGFunction", class('StateNodeMap_erase'))

# Start of StateNodeMap_count

`StateNodeMap_count` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_StateNodeMap_count', self, x, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNodeMap_count`, 'returnType') = 'integer'
attr(`StateNodeMap_count`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t', '_p_StateNode')
class(`StateNodeMap_count`) = c("SWIGFunction", class('StateNodeMap_count'))

# Start of delete_StateNodeMap

`delete_StateNodeMap` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_StateNodeMap', self, PACKAGE='infomap');
  
}

attr(`delete_StateNodeMap`, 'returnType') = 'void'
attr(`delete_StateNodeMap`, "inputTypes") = c('_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t')
class(`delete_StateNodeMap`) = c("SWIGFunction", class('delete_StateNodeMap'))

# Start of accessor method for std::map<(StateNode,double)>
setMethod('$', '_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t', function(x, name)

{
  accessorFuns = list('empty' = StateNodeMap_empty, 'size' = StateNodeMap_size, 'swap' = StateNodeMap_swap, 'clear' = StateNodeMap_clear, 'get_allocator' = StateNodeMap_get_allocator, 'erase' = StateNodeMap_erase, 'count' = StateNodeMap_count);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::map<(StateNode,double)>
setMethod('delete', '_p_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t', function(obj) {delete_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t(obj)})
# Start of new_UIntDeque

`UIntDeque__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_UIntDeque__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_UIntDeque)
  ans
  
}

attr(`UIntDeque__SWIG_0`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
class(`UIntDeque__SWIG_0`) = c("SWIGFunction", class('UIntDeque__SWIG_0'))

# Start of new_UIntDeque

`UIntDeque__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_UIntDeque__SWIG_1', s_arg1, PACKAGE='infomap');
  ans <- new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_UIntDeque)
  ans
  
}

attr(`UIntDeque__SWIG_1`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`UIntDeque__SWIG_1`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque__SWIG_1`) = c("SWIGFunction", class('UIntDeque__SWIG_1'))

# Start of UIntDeque_empty

`UIntDeque_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UIntDeque_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`UIntDeque_empty`, 'returnType') = 'logical'
attr(`UIntDeque_empty`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_empty`) = c("SWIGFunction", class('UIntDeque_empty'))

# Start of UIntDeque_size

`UIntDeque_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UIntDeque_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`UIntDeque_size`, 'returnType') = 'integer'
attr(`UIntDeque_size`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_size`) = c("SWIGFunction", class('UIntDeque_size'))

# Start of UIntDeque_swap

`UIntDeque_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_UIntDeque_swap', self, v, PACKAGE='infomap');
  
}

attr(`UIntDeque_swap`, 'returnType') = 'void'
attr(`UIntDeque_swap`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_swap`) = c("SWIGFunction", class('UIntDeque_swap'))

# Start of UIntDeque_clear

`UIntDeque_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UIntDeque_clear', self, PACKAGE='infomap');
  
}

attr(`UIntDeque_clear`, 'returnType') = 'void'
attr(`UIntDeque_clear`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_clear`) = c("SWIGFunction", class('UIntDeque_clear'))

# Start of UIntDeque_get_allocator

`UIntDeque_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_UIntDeque_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_std__allocatorT_unsigned_int_t", ref=ans);
  
  ans
  
}

attr(`UIntDeque_get_allocator`, 'returnType') = '_p_std__allocatorT_unsigned_int_t'
attr(`UIntDeque_get_allocator`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_get_allocator`) = c("SWIGFunction", class('UIntDeque_get_allocator'))

# Start of new_UIntDeque

`UIntDeque__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_UIntDeque__SWIG_2', size, PACKAGE='infomap');
  ans <- new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_UIntDeque)
  ans
  
}

attr(`UIntDeque__SWIG_2`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`UIntDeque__SWIG_2`, "inputTypes") = c('integer')
class(`UIntDeque__SWIG_2`) = c("SWIGFunction", class('UIntDeque__SWIG_2'))

# Start of UIntDeque_pop_back

`UIntDeque_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UIntDeque_pop_back', self, PACKAGE='infomap');
  
}

attr(`UIntDeque_pop_back`, 'returnType') = 'void'
attr(`UIntDeque_pop_back`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_pop_back`) = c("SWIGFunction", class('UIntDeque_pop_back'))

# Start of UIntDeque_resize

`UIntDeque_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_UIntDeque_resize__SWIG_0', self, new_size, PACKAGE='infomap');
  
}

attr(`UIntDeque_resize__SWIG_0`, 'returnType') = 'void'
attr(`UIntDeque_resize__SWIG_0`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer')
class(`UIntDeque_resize__SWIG_0`) = c("SWIGFunction", class('UIntDeque_resize__SWIG_0'))

# Start of new_UIntDeque

`UIntDeque__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;ans = .Call('R_swig_new_UIntDeque__SWIG_3', size, value, PACKAGE='infomap');
  ans <- new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_UIntDeque)
  ans
  
}

attr(`UIntDeque__SWIG_3`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`UIntDeque__SWIG_3`, "inputTypes") = c('integer', '_p_unsigned_int')
class(`UIntDeque__SWIG_3`) = c("SWIGFunction", class('UIntDeque__SWIG_3'))

`UIntDeque` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- UIntDeque__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- UIntDeque__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t') && length(argv[[1]]) == 1) {
      f <- UIntDeque__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_unsigned_int') && length(argv[[2]]) == 1) {
      f <- UIntDeque__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for UIntDeque with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of UIntDeque_push_back

`UIntDeque_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_UIntDeque_push_back', self, x, PACKAGE='infomap');
  
}

attr(`UIntDeque_push_back`, 'returnType') = 'void'
attr(`UIntDeque_push_back`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_unsigned_int')
class(`UIntDeque_push_back`) = c("SWIGFunction", class('UIntDeque_push_back'))

# Start of UIntDeque_front

`UIntDeque_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UIntDeque_front', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`UIntDeque_front`, 'returnType') = '_p_unsigned_int'
attr(`UIntDeque_front`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_front`) = c("SWIGFunction", class('UIntDeque_front'))

# Start of UIntDeque_back

`UIntDeque_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UIntDeque_back', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`UIntDeque_back`, 'returnType') = '_p_unsigned_int'
attr(`UIntDeque_back`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_back`) = c("SWIGFunction", class('UIntDeque_back'))

# Start of UIntDeque_assign

`UIntDeque_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_UIntDeque_assign', self, n, x, PACKAGE='infomap');
  
}

attr(`UIntDeque_assign`, 'returnType') = 'void'
attr(`UIntDeque_assign`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', '_p_unsigned_int')
class(`UIntDeque_assign`) = c("SWIGFunction", class('UIntDeque_assign'))

# Start of UIntDeque_resize

`UIntDeque_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_UIntDeque_resize__SWIG_1', self, new_size, x, PACKAGE='infomap');
  
}

attr(`UIntDeque_resize__SWIG_1`, 'returnType') = 'void'
attr(`UIntDeque_resize__SWIG_1`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', '_p_unsigned_int')
class(`UIntDeque_resize__SWIG_1`) = c("SWIGFunction", class('UIntDeque_resize__SWIG_1'))

`UIntDeque_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- UIntDeque_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_unsigned_int') && length(argv[[3]]) == 1) {
      f <- UIntDeque_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for UIntDeque_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of UIntDeque_pop_front

`UIntDeque_pop_front` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UIntDeque_pop_front', self, PACKAGE='infomap');
  
}

attr(`UIntDeque_pop_front`, 'returnType') = 'void'
attr(`UIntDeque_pop_front`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`UIntDeque_pop_front`) = c("SWIGFunction", class('UIntDeque_pop_front'))

# Start of UIntDeque_push_front

`UIntDeque_push_front` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_UIntDeque_push_front', self, x, PACKAGE='infomap');
  
}

attr(`UIntDeque_push_front`, 'returnType') = 'void'
attr(`UIntDeque_push_front`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_unsigned_int')
class(`UIntDeque_push_front`) = c("SWIGFunction", class('UIntDeque_push_front'))

# Start of delete_UIntDeque

`delete_UIntDeque` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_UIntDeque', self, PACKAGE='infomap');
  
}

attr(`delete_UIntDeque`, 'returnType') = 'void'
attr(`delete_UIntDeque`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`delete_UIntDeque`) = c("SWIGFunction", class('delete_UIntDeque'))

# Start of accessor method for std::deque<(unsigned int)>
setMethod('$', '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', function(x, name)

{
  accessorFuns = list('empty' = UIntDeque_empty, 'size' = UIntDeque_size, 'swap' = UIntDeque_swap, 'clear' = UIntDeque_clear, 'get_allocator' = UIntDeque_get_allocator, 'pop_back' = UIntDeque_pop_back, 'resize' = UIntDeque_resize, 'push_back' = UIntDeque_push_back, 'front' = UIntDeque_front, 'back' = UIntDeque_back, 'assign' = UIntDeque_assign, 'pop_front' = UIntDeque_pop_front, 'push_front' = UIntDeque_push_front);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::deque<(unsigned int)>
setMethod('delete', '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', function(obj) {delete_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t(obj)})
# Start of run

`run__SWIG_0` = function(flags, .copy = FALSE)
{
  flags = as(flags, "character"); 
  ;.Call('R_swig_run__SWIG_0', flags, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`run__SWIG_0`, 'returnType') = 'integer'
attr(`run__SWIG_0`, "inputTypes") = c('character')
class(`run__SWIG_0`) = c("SWIGFunction", class('run__SWIG_0'))

# Start of init

`init` = function(flags, .copy = FALSE)
{
  flags = as(flags, "character"); 
  ;ans = .Call('R_swig_init', flags, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_Config", ref=ans);
  
  ans
  
}

attr(`init`, 'returnType') = '_p_Config'
attr(`init`, "inputTypes") = c('character')
class(`init`) = c("SWIGFunction", class('init'))

# Start of run

`run__SWIG_1` = function(input, output, .copy = FALSE)
{
  if (inherits(input, "ExternalReference")) input = slot(input,"ref") 
  if (inherits(output, "ExternalReference")) output = slot(output,"ref") 
  ;.Call('R_swig_run__SWIG_1', input, output, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`run__SWIG_1`, 'returnType') = 'integer'
attr(`run__SWIG_1`, "inputTypes") = c('_p_Network', '_p_HierarchicalNetwork')
class(`run__SWIG_1`) = c("SWIGFunction", class('run__SWIG_1'))

`run` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- run__SWIG_0; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Network') && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_HierarchicalNetwork') && length(argv[[2]]) == 1) {
      f <- run__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for run with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of new_Infomap

`Infomap` = function(flags)
{
  flags = as(flags, "character"); 
  ;ans = .Call('R_swig_new_Infomap', flags, PACKAGE='infomap');
  ans <- new("_p_Infomap", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Infomap)
  ans
  
}

attr(`Infomap`, 'returnType') = '_p_Infomap'
attr(`Infomap`, "inputTypes") = c('character')
class(`Infomap`) = c("SWIGFunction", class('Infomap'))

# Start of Infomap_readInputData

`Infomap_readInputData` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_Infomap_readInputData', self, filename, PACKAGE='infomap');
  
}

attr(`Infomap_readInputData`, 'returnType') = 'void'
attr(`Infomap_readInputData`, "inputTypes") = c('_p_Infomap', 'character')
class(`Infomap_readInputData`) = c("SWIGFunction", class('Infomap_readInputData'))

# Start of Infomap_addLink

`Infomap_addLink__SWIG_0` = function(self, n1, n2, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;.Call('R_swig_Infomap_addLink__SWIG_0', self, n1, n2, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Infomap_addLink__SWIG_0`, 'returnType') = 'logical'
attr(`Infomap_addLink__SWIG_0`, "inputTypes") = c('_p_Infomap', 'integer', 'integer', 'numeric')
class(`Infomap_addLink__SWIG_0`) = c("SWIGFunction", class('Infomap_addLink__SWIG_0'))

# Start of Infomap_addLink

`Infomap_addLink__SWIG_1` = function(self, n1, n2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  ;.Call('R_swig_Infomap_addLink__SWIG_1', self, n1, n2, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Infomap_addLink__SWIG_1`, 'returnType') = 'logical'
attr(`Infomap_addLink__SWIG_1`, "inputTypes") = c('_p_Infomap', 'integer', 'integer')
class(`Infomap_addLink__SWIG_1`) = c("SWIGFunction", class('Infomap_addLink__SWIG_1'))

`Infomap_addLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Infomap') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- Infomap_addLink__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_Infomap') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- Infomap_addLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Infomap_addLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Infomap_run

`Infomap_run` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Infomap_run', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Infomap_run`, 'returnType') = 'integer'
attr(`Infomap_run`, "inputTypes") = c('_p_Infomap')
class(`Infomap_run`) = c("SWIGFunction", class('Infomap_run'))

# Start of Infomap_config_set

`Infomap_config_set` = function(self, s_config)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_config, "ExternalReference")) s_config = slot(s_config,"ref") 
  ;.Call('R_swig_Infomap_config_set', self, s_config, PACKAGE='infomap');
  
}

attr(`Infomap_config_set`, 'returnType') = 'void'
attr(`Infomap_config_set`, "inputTypes") = c('_p_Infomap', '_p_Config')
class(`Infomap_config_set`) = c("SWIGFunction", class('Infomap_config_set'))

# Start of Infomap_config_get

`Infomap_config_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Infomap_config_get', self, PACKAGE='infomap');
  ans <- new("_p_Config", ref=ans) ;
  
  ans
  
}

attr(`Infomap_config_get`, 'returnType') = '_p_Config'
attr(`Infomap_config_get`, "inputTypes") = c('_p_Infomap')
class(`Infomap_config_get`) = c("SWIGFunction", class('Infomap_config_get'))

# Start of Infomap_network_set

`Infomap_network_set` = function(self, s_network)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_network, "ExternalReference")) s_network = slot(s_network,"ref") 
  ;.Call('R_swig_Infomap_network_set', self, s_network, PACKAGE='infomap');
  
}

attr(`Infomap_network_set`, 'returnType') = 'void'
attr(`Infomap_network_set`, "inputTypes") = c('_p_Infomap', '_p_Network')
class(`Infomap_network_set`) = c("SWIGFunction", class('Infomap_network_set'))

# Start of Infomap_network_get

`Infomap_network_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Infomap_network_get', self, PACKAGE='infomap');
  ans <- new("_p_Network", ref=ans) ;
  
  ans
  
}

attr(`Infomap_network_get`, 'returnType') = '_p_Network'
attr(`Infomap_network_get`, "inputTypes") = c('_p_Infomap')
class(`Infomap_network_get`) = c("SWIGFunction", class('Infomap_network_get'))

# Start of Infomap_tree_set

`Infomap_tree_set` = function(self, s_tree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_tree, "ExternalReference")) s_tree = slot(s_tree,"ref") 
  ;.Call('R_swig_Infomap_tree_set', self, s_tree, PACKAGE='infomap');
  
}

attr(`Infomap_tree_set`, 'returnType') = 'void'
attr(`Infomap_tree_set`, "inputTypes") = c('_p_Infomap', '_p_HierarchicalNetwork')
class(`Infomap_tree_set`) = c("SWIGFunction", class('Infomap_tree_set'))

# Start of Infomap_tree_get

`Infomap_tree_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Infomap_tree_get', self, PACKAGE='infomap');
  ans <- new("_p_HierarchicalNetwork", ref=ans) ;
  
  ans
  
}

attr(`Infomap_tree_get`, 'returnType') = '_p_HierarchicalNetwork'
attr(`Infomap_tree_get`, "inputTypes") = c('_p_Infomap')
class(`Infomap_tree_get`) = c("SWIGFunction", class('Infomap_tree_get'))

# Start of delete_Infomap

`delete_Infomap` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Infomap', self, PACKAGE='infomap');
  
}

attr(`delete_Infomap`, 'returnType') = 'void'
attr(`delete_Infomap`, "inputTypes") = c('_p_Infomap')
class(`delete_Infomap`) = c("SWIGFunction", class('delete_Infomap'))

# Start of accessor method for Infomap
setMethod('$', '_p_Infomap', function(x, name)

{
  accessorFuns = list('readInputData' = Infomap_readInputData, 'addLink' = Infomap_addLink, 'run' = Infomap_run, 'config' = Infomap_config_get, 'network' = Infomap_network_get, 'tree' = Infomap_tree_get);
  vaccessors = c('config', 'network', 'tree');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Infomap
# Start of accessor method for Infomap
setMethod('$<-', '_p_Infomap', function(x, name, value)

{
  accessorFuns = list('config' = Infomap_config_set, 'network' = Infomap_network_set, 'tree' = Infomap_tree_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Infomap', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('config' = Infomap_config_set, 'network' = Infomap_network_set, 'tree' = Infomap_tree_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Infomap
setMethod('delete', '_p_Infomap', function(obj) {delete_Infomap(obj)})
# Start of new_MemInfomap

`MemInfomap` = function(flags)
{
  flags = as(flags, "character"); 
  ;ans = .Call('R_swig_new_MemInfomap', flags, PACKAGE='infomap');
  ans <- new("_p_MemInfomap", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_MemInfomap)
  ans
  
}

attr(`MemInfomap`, 'returnType') = '_p_MemInfomap'
attr(`MemInfomap`, "inputTypes") = c('character')
class(`MemInfomap`) = c("SWIGFunction", class('MemInfomap'))

# Start of MemInfomap_readInputData

`MemInfomap_readInputData` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_MemInfomap_readInputData', self, filename, PACKAGE='infomap');
  
}

attr(`MemInfomap_readInputData`, 'returnType') = 'void'
attr(`MemInfomap_readInputData`, "inputTypes") = c('_p_MemInfomap', 'character')
class(`MemInfomap_readInputData`) = c("SWIGFunction", class('MemInfomap_readInputData'))

# Start of MemInfomap_addTrigram

`MemInfomap_addTrigram__SWIG_0` = function(self, n1, n2, n3, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  n3 = as.integer(n3);
  
  if(length(n3) > 1) {
    warning("using only the first element of n3");
  };
  
  
  ;.Call('R_swig_MemInfomap_addTrigram__SWIG_0', self, n1, n2, n3, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemInfomap_addTrigram__SWIG_0`, 'returnType') = 'logical'
attr(`MemInfomap_addTrigram__SWIG_0`, "inputTypes") = c('_p_MemInfomap', 'integer', 'integer', 'integer', 'numeric')
class(`MemInfomap_addTrigram__SWIG_0`) = c("SWIGFunction", class('MemInfomap_addTrigram__SWIG_0'))

# Start of MemInfomap_addTrigram

`MemInfomap_addTrigram__SWIG_1` = function(self, n1, n2, n3, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  n3 = as.integer(n3);
  
  if(length(n3) > 1) {
    warning("using only the first element of n3");
  };
  
  ;.Call('R_swig_MemInfomap_addTrigram__SWIG_1', self, n1, n2, n3, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemInfomap_addTrigram__SWIG_1`, 'returnType') = 'logical'
attr(`MemInfomap_addTrigram__SWIG_1`, "inputTypes") = c('_p_MemInfomap', 'integer', 'integer', 'integer')
class(`MemInfomap_addTrigram__SWIG_1`) = c("SWIGFunction", class('MemInfomap_addTrigram__SWIG_1'))

`MemInfomap_addTrigram` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 4) {
    if (extends(argtypes[1], '_p_MemInfomap') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- MemInfomap_addTrigram__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_MemInfomap') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- MemInfomap_addTrigram__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MemInfomap_addTrigram with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemInfomap_addStateLink

`MemInfomap_addStateLink__SWIG_0` = function(self, n1PriorState, n1, n2PriorState, n2, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1PriorState = as.integer(n1PriorState);
  
  if(length(n1PriorState) > 1) {
    warning("using only the first element of n1PriorState");
  };
  
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2PriorState = as.integer(n2PriorState);
  
  if(length(n2PriorState) > 1) {
    warning("using only the first element of n2PriorState");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;.Call('R_swig_MemInfomap_addStateLink__SWIG_0', self, n1PriorState, n1, n2PriorState, n2, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemInfomap_addStateLink__SWIG_0`, 'returnType') = 'logical'
attr(`MemInfomap_addStateLink__SWIG_0`, "inputTypes") = c('_p_MemInfomap', 'integer', 'integer', 'integer', 'integer', 'numeric')
class(`MemInfomap_addStateLink__SWIG_0`) = c("SWIGFunction", class('MemInfomap_addStateLink__SWIG_0'))

# Start of MemInfomap_addStateLink

`MemInfomap_addStateLink__SWIG_1` = function(self, n1PriorState, n1, n2PriorState, n2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1PriorState = as.integer(n1PriorState);
  
  if(length(n1PriorState) > 1) {
    warning("using only the first element of n1PriorState");
  };
  
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2PriorState = as.integer(n2PriorState);
  
  if(length(n2PriorState) > 1) {
    warning("using only the first element of n2PriorState");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  ;.Call('R_swig_MemInfomap_addStateLink__SWIG_1', self, n1PriorState, n1, n2PriorState, n2, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemInfomap_addStateLink__SWIG_1`, 'returnType') = 'logical'
attr(`MemInfomap_addStateLink__SWIG_1`, "inputTypes") = c('_p_MemInfomap', 'integer', 'integer', 'integer', 'integer')
class(`MemInfomap_addStateLink__SWIG_1`) = c("SWIGFunction", class('MemInfomap_addStateLink__SWIG_1'))

`MemInfomap_addStateLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 5) {
    if (extends(argtypes[1], '_p_MemInfomap') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- MemInfomap_addStateLink__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_MemInfomap') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 )) {
      f <- MemInfomap_addStateLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MemInfomap_addStateLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemInfomap_addMultiplexLink

`MemInfomap_addMultiplexLink__SWIG_0` = function(self, layer1, node1, layer2, node2, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  layer1 = as.integer(layer1);
  
  if(length(layer1) > 1) {
    warning("using only the first element of layer1");
  };
  
  node1 = as.integer(node1);
  
  if(length(node1) > 1) {
    warning("using only the first element of node1");
  };
  
  layer2 = as.integer(layer2);
  
  if(length(layer2) > 1) {
    warning("using only the first element of layer2");
  };
  
  node2 = as.integer(node2);
  
  if(length(node2) > 1) {
    warning("using only the first element of node2");
  };
  
  
  ;.Call('R_swig_MemInfomap_addMultiplexLink__SWIG_0', self, layer1, node1, layer2, node2, weight, PACKAGE='infomap');
  
}

attr(`MemInfomap_addMultiplexLink__SWIG_0`, 'returnType') = 'void'
attr(`MemInfomap_addMultiplexLink__SWIG_0`, "inputTypes") = c('_p_MemInfomap', 'integer', 'integer', 'integer', 'integer', 'numeric')
class(`MemInfomap_addMultiplexLink__SWIG_0`) = c("SWIGFunction", class('MemInfomap_addMultiplexLink__SWIG_0'))

# Start of MemInfomap_addMultiplexLink

`MemInfomap_addMultiplexLink__SWIG_1` = function(self, layer1, node1, layer2, node2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  layer1 = as.integer(layer1);
  
  if(length(layer1) > 1) {
    warning("using only the first element of layer1");
  };
  
  node1 = as.integer(node1);
  
  if(length(node1) > 1) {
    warning("using only the first element of node1");
  };
  
  layer2 = as.integer(layer2);
  
  if(length(layer2) > 1) {
    warning("using only the first element of layer2");
  };
  
  node2 = as.integer(node2);
  
  if(length(node2) > 1) {
    warning("using only the first element of node2");
  };
  
  ;.Call('R_swig_MemInfomap_addMultiplexLink__SWIG_1', self, layer1, node1, layer2, node2, PACKAGE='infomap');
  
}

attr(`MemInfomap_addMultiplexLink__SWIG_1`, 'returnType') = 'void'
attr(`MemInfomap_addMultiplexLink__SWIG_1`, "inputTypes") = c('_p_MemInfomap', 'integer', 'integer', 'integer', 'integer')
class(`MemInfomap_addMultiplexLink__SWIG_1`) = c("SWIGFunction", class('MemInfomap_addMultiplexLink__SWIG_1'))

`MemInfomap_addMultiplexLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 5) {
    if (extends(argtypes[1], '_p_MemInfomap') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- MemInfomap_addMultiplexLink__SWIG_1; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_MemInfomap') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 )) {
      f <- MemInfomap_addMultiplexLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MemInfomap_addMultiplexLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemInfomap_run

`MemInfomap_run` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemInfomap_run', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemInfomap_run`, 'returnType') = 'integer'
attr(`MemInfomap_run`, "inputTypes") = c('_p_MemInfomap')
class(`MemInfomap_run`) = c("SWIGFunction", class('MemInfomap_run'))

# Start of MemInfomap_config_set

`MemInfomap_config_set` = function(self, s_config)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_config, "ExternalReference")) s_config = slot(s_config,"ref") 
  ;.Call('R_swig_MemInfomap_config_set', self, s_config, PACKAGE='infomap');
  
}

attr(`MemInfomap_config_set`, 'returnType') = 'void'
attr(`MemInfomap_config_set`, "inputTypes") = c('_p_MemInfomap', '_p_Config')
class(`MemInfomap_config_set`) = c("SWIGFunction", class('MemInfomap_config_set'))

# Start of MemInfomap_config_get

`MemInfomap_config_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_MemInfomap_config_get', self, PACKAGE='infomap');
  ans <- new("_p_Config", ref=ans) ;
  
  ans
  
}

attr(`MemInfomap_config_get`, 'returnType') = '_p_Config'
attr(`MemInfomap_config_get`, "inputTypes") = c('_p_MemInfomap')
class(`MemInfomap_config_get`) = c("SWIGFunction", class('MemInfomap_config_get'))

# Start of MemInfomap_network_set

`MemInfomap_network_set` = function(self, s_network)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_network, "ExternalReference")) s_network = slot(s_network,"ref") 
  ;.Call('R_swig_MemInfomap_network_set', self, s_network, PACKAGE='infomap');
  
}

attr(`MemInfomap_network_set`, 'returnType') = 'void'
attr(`MemInfomap_network_set`, "inputTypes") = c('_p_MemInfomap', '_p_MultiplexNetwork')
class(`MemInfomap_network_set`) = c("SWIGFunction", class('MemInfomap_network_set'))

# Start of MemInfomap_network_get

`MemInfomap_network_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_MemInfomap_network_get', self, PACKAGE='infomap');
  ans <- new("_p_MultiplexNetwork", ref=ans) ;
  
  ans
  
}

attr(`MemInfomap_network_get`, 'returnType') = '_p_MultiplexNetwork'
attr(`MemInfomap_network_get`, "inputTypes") = c('_p_MemInfomap')
class(`MemInfomap_network_get`) = c("SWIGFunction", class('MemInfomap_network_get'))

# Start of MemInfomap_tree_set

`MemInfomap_tree_set` = function(self, s_tree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_tree, "ExternalReference")) s_tree = slot(s_tree,"ref") 
  ;.Call('R_swig_MemInfomap_tree_set', self, s_tree, PACKAGE='infomap');
  
}

attr(`MemInfomap_tree_set`, 'returnType') = 'void'
attr(`MemInfomap_tree_set`, "inputTypes") = c('_p_MemInfomap', '_p_HierarchicalNetwork')
class(`MemInfomap_tree_set`) = c("SWIGFunction", class('MemInfomap_tree_set'))

# Start of MemInfomap_tree_get

`MemInfomap_tree_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_MemInfomap_tree_get', self, PACKAGE='infomap');
  ans <- new("_p_HierarchicalNetwork", ref=ans) ;
  
  ans
  
}

attr(`MemInfomap_tree_get`, 'returnType') = '_p_HierarchicalNetwork'
attr(`MemInfomap_tree_get`, "inputTypes") = c('_p_MemInfomap')
class(`MemInfomap_tree_get`) = c("SWIGFunction", class('MemInfomap_tree_get'))

# Start of delete_MemInfomap

`delete_MemInfomap` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_MemInfomap', self, PACKAGE='infomap');
  
}

attr(`delete_MemInfomap`, 'returnType') = 'void'
attr(`delete_MemInfomap`, "inputTypes") = c('_p_MemInfomap')
class(`delete_MemInfomap`) = c("SWIGFunction", class('delete_MemInfomap'))

# Start of accessor method for MemInfomap
setMethod('$', '_p_MemInfomap', function(x, name)

{
  accessorFuns = list('readInputData' = MemInfomap_readInputData, 'addTrigram' = MemInfomap_addTrigram, 'addStateLink' = MemInfomap_addStateLink, 'addMultiplexLink' = MemInfomap_addMultiplexLink, 'run' = MemInfomap_run, 'config' = MemInfomap_config_get, 'network' = MemInfomap_network_get, 'tree' = MemInfomap_tree_get);
  vaccessors = c('config', 'network', 'tree');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for MemInfomap
# Start of accessor method for MemInfomap
setMethod('$<-', '_p_MemInfomap', function(x, name, value)

{
  accessorFuns = list('config' = MemInfomap_config_set, 'network' = MemInfomap_network_set, 'tree' = MemInfomap_tree_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_MemInfomap', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('config' = MemInfomap_config_set, 'network' = MemInfomap_network_set, 'tree' = MemInfomap_tree_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for MemInfomap
setMethod('delete', '_p_MemInfomap', function(obj) {delete_MemInfomap(obj)})
defineEnumeration('_ElapsedTime__InSeconds',
                    .values = c(
                        'SECONDS_IN_A_MINUTE' = 60, 
                        'SECONDS_IN_AN_HOUR' = 3600, 
                        'SECONDS_IN_A_DAY' = 86400
))
# Start of new_ElapsedTime

`ElapsedTime` = function(elapsedTime)
{
  ;ans = .Call('R_swig_new_ElapsedTime', elapsedTime, PACKAGE='infomap');
  ans <- new("_p_ElapsedTime", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ElapsedTime)
  ans
  
}

attr(`ElapsedTime`, 'returnType') = '_p_ElapsedTime'
attr(`ElapsedTime`, "inputTypes") = c('numeric')
class(`ElapsedTime`) = c("SWIGFunction", class('ElapsedTime'))

# Start of delete_ElapsedTime

`delete_ElapsedTime` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_ElapsedTime', self, PACKAGE='infomap');
  
}

attr(`delete_ElapsedTime`, 'returnType') = 'void'
attr(`delete_ElapsedTime`, "inputTypes") = c('_p_ElapsedTime')
class(`delete_ElapsedTime`) = c("SWIGFunction", class('delete_ElapsedTime'))

# Start of ElapsedTime_getSeconds

`ElapsedTime_getSeconds` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ElapsedTime_getSeconds', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ElapsedTime_getSeconds`, 'returnType') = 'numeric'
attr(`ElapsedTime_getSeconds`, "inputTypes") = c('_p_ElapsedTime')
class(`ElapsedTime_getSeconds`) = c("SWIGFunction", class('ElapsedTime_getSeconds'))

# Start of ElapsedTime_getMinutes

`ElapsedTime_getMinutes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ElapsedTime_getMinutes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ElapsedTime_getMinutes`, 'returnType') = 'numeric'
attr(`ElapsedTime_getMinutes`, "inputTypes") = c('_p_ElapsedTime')
class(`ElapsedTime_getMinutes`) = c("SWIGFunction", class('ElapsedTime_getMinutes'))

# Start of ElapsedTime_getHours

`ElapsedTime_getHours` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ElapsedTime_getHours', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ElapsedTime_getHours`, 'returnType') = 'numeric'
attr(`ElapsedTime_getHours`, "inputTypes") = c('_p_ElapsedTime')
class(`ElapsedTime_getHours`) = c("SWIGFunction", class('ElapsedTime_getHours'))

# Start of ElapsedTime_getDays

`ElapsedTime_getDays` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ElapsedTime_getDays', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ElapsedTime_getDays`, 'returnType') = 'numeric'
attr(`ElapsedTime_getDays`, "inputTypes") = c('_p_ElapsedTime')
class(`ElapsedTime_getDays`) = c("SWIGFunction", class('ElapsedTime_getDays'))

# Start of accessor method for ElapsedTime
setMethod('$', '_p_ElapsedTime', function(x, name)

{
  accessorFuns = list('getSeconds' = ElapsedTime_getSeconds, 'getMinutes' = ElapsedTime_getMinutes, 'getHours' = ElapsedTime_getHours, 'getDays' = ElapsedTime_getDays);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for ElapsedTime
setMethod('delete', '_p_ElapsedTime', function(obj) {delete_ElapsedTime(obj)})
# Start of new_Date

`Date__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Date__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_Date", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Date)
  ans
  
}

attr(`Date__SWIG_0`, 'returnType') = '_p_Date'
class(`Date__SWIG_0`) = c("SWIGFunction", class('Date__SWIG_0'))

# Start of new_Date

`Date__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_Date__SWIG_1', other, PACKAGE='infomap');
  ans <- new("_p_Date", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Date)
  ans
  
}

attr(`Date__SWIG_1`, 'returnType') = '_p_Date'
attr(`Date__SWIG_1`, "inputTypes") = c('_p_Date')
class(`Date__SWIG_1`) = c("SWIGFunction", class('Date__SWIG_1'))

`Date` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Date__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Date') && length(argv[[1]]) == 1) {
      f <- Date__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Date with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Date_Equal

`Date_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_Date_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_Date", ref=ans) ;
  
  ans
  
}

attr(`Date_Equal`, 'returnType') = '_p_Date'
attr(`Date_Equal`, "inputTypes") = c('_p_Date', '_p_Date')
class(`Date_Equal`) = c("SWIGFunction", class('Date_Equal'))

# Start of delete_Date

`delete_Date` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Date', self, PACKAGE='infomap');
  
}

attr(`delete_Date`, 'returnType') = 'void'
attr(`delete_Date`, "inputTypes") = c('_p_Date')
class(`delete_Date`) = c("SWIGFunction", class('delete_Date'))

# Start of Date_Minus

`Date_Minus` = function(self, date, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(date, "ExternalReference")) date = slot(date,"ref") 
  ;ans = .Call('R_swig_Date_Minus', self, date, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_ElapsedTime", ref=ans);
  
  ans
  
}

attr(`Date_Minus`, 'returnType') = '_p_ElapsedTime'
attr(`Date_Minus`, "inputTypes") = c('_p_Date', '_p_Date')
class(`Date_Minus`) = c("SWIGFunction", class('Date_Minus'))

# Start of accessor method for Date
setMethod('$', '_p_Date', function(x, name)

{
  accessorFuns = list('Equal' = Date_Equal, 'Minus' = Date_Minus);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for Date
setMethod('delete', '_p_Date', function(obj) {delete_Date(obj)})
# Start of new_Config

`Config__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Config__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_Config", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Config)
  ans
  
}

attr(`Config__SWIG_0`, 'returnType') = '_p_Config'
class(`Config__SWIG_0`) = c("SWIGFunction", class('Config__SWIG_0'))

# Start of new_Config

`Config__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_Config__SWIG_1', other, PACKAGE='infomap');
  ans <- new("_p_Config", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Config)
  ans
  
}

attr(`Config__SWIG_1`, 'returnType') = '_p_Config'
attr(`Config__SWIG_1`, "inputTypes") = c('_p_Config')
class(`Config__SWIG_1`) = c("SWIGFunction", class('Config__SWIG_1'))

`Config` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Config__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Config') && length(argv[[1]]) == 1) {
      f <- Config__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Config with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Config_Equal

`Config_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_Config_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_Config", ref=ans) ;
  
  ans
  
}

attr(`Config_Equal`, 'returnType') = '_p_Config'
attr(`Config_Equal`, "inputTypes") = c('_p_Config', '_p_Config')
class(`Config_Equal`) = c("SWIGFunction", class('Config_Equal'))

# Start of Config_setOptimizationLevel

`Config_setOptimizationLevel` = function(self, level)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  ;.Call('R_swig_Config_setOptimizationLevel', self, level, PACKAGE='infomap');
  
}

attr(`Config_setOptimizationLevel`, 'returnType') = 'void'
attr(`Config_setOptimizationLevel`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_setOptimizationLevel`) = c("SWIGFunction", class('Config_setOptimizationLevel'))

# Start of Config_adaptDefaults

`Config_adaptDefaults` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_adaptDefaults', self, PACKAGE='infomap');
  
}

attr(`Config_adaptDefaults`, 'returnType') = 'void'
attr(`Config_adaptDefaults`, "inputTypes") = c('_p_Config')
class(`Config_adaptDefaults`) = c("SWIGFunction", class('Config_adaptDefaults'))

# Start of Config_reset

`Config_reset` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_reset', self, PACKAGE='infomap');
  
}

attr(`Config_reset`, 'returnType') = 'void'
attr(`Config_reset`, "inputTypes") = c('_p_Config')
class(`Config_reset`) = c("SWIGFunction", class('Config_reset'))

# Start of Config_isUndirected

`Config_isUndirected` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_isUndirected', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isUndirected`, 'returnType') = 'logical'
attr(`Config_isUndirected`, "inputTypes") = c('_p_Config')
class(`Config_isUndirected`) = c("SWIGFunction", class('Config_isUndirected'))

# Start of Config_setUndirected

`Config_setUndirected` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_setUndirected', self, PACKAGE='infomap');
  
}

attr(`Config_setUndirected`, 'returnType') = 'void'
attr(`Config_setUndirected`, "inputTypes") = c('_p_Config')
class(`Config_setUndirected`) = c("SWIGFunction", class('Config_setUndirected'))

# Start of Config_isUndirectedFlow

`Config_isUndirectedFlow` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_isUndirectedFlow', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isUndirectedFlow`, 'returnType') = 'logical'
attr(`Config_isUndirectedFlow`, "inputTypes") = c('_p_Config')
class(`Config_isUndirectedFlow`) = c("SWIGFunction", class('Config_isUndirectedFlow'))

# Start of Config_printAsUndirected

`Config_printAsUndirected` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printAsUndirected', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printAsUndirected`, 'returnType') = 'logical'
attr(`Config_printAsUndirected`, "inputTypes") = c('_p_Config')
class(`Config_printAsUndirected`) = c("SWIGFunction", class('Config_printAsUndirected'))

# Start of Config_parseAsUndirected

`Config_parseAsUndirected` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_parseAsUndirected', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_parseAsUndirected`, 'returnType') = 'logical'
attr(`Config_parseAsUndirected`, "inputTypes") = c('_p_Config')
class(`Config_parseAsUndirected`) = c("SWIGFunction", class('Config_parseAsUndirected'))

# Start of Config_useTeleportation

`Config_useTeleportation` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_useTeleportation', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_useTeleportation`, 'returnType') = 'logical'
attr(`Config_useTeleportation`, "inputTypes") = c('_p_Config')
class(`Config_useTeleportation`) = c("SWIGFunction", class('Config_useTeleportation'))

# Start of Config_isMemoryInput

`Config_isMemoryInput` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_isMemoryInput', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isMemoryInput`, 'returnType') = 'logical'
attr(`Config_isMemoryInput`, "inputTypes") = c('_p_Config')
class(`Config_isMemoryInput`) = c("SWIGFunction", class('Config_isMemoryInput'))

# Start of Config_isMemoryNetwork

`Config_isMemoryNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_isMemoryNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isMemoryNetwork`, 'returnType') = 'logical'
attr(`Config_isMemoryNetwork`, "inputTypes") = c('_p_Config')
class(`Config_isMemoryNetwork`) = c("SWIGFunction", class('Config_isMemoryNetwork'))

# Start of Config_isSimulatedMemoryNetwork

`Config_isSimulatedMemoryNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_isSimulatedMemoryNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isSimulatedMemoryNetwork`, 'returnType') = 'logical'
attr(`Config_isSimulatedMemoryNetwork`, "inputTypes") = c('_p_Config')
class(`Config_isSimulatedMemoryNetwork`) = c("SWIGFunction", class('Config_isSimulatedMemoryNetwork'))

# Start of Config_isMultiplexNetwork

`Config_isMultiplexNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_isMultiplexNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isMultiplexNetwork`, 'returnType') = 'logical'
attr(`Config_isMultiplexNetwork`, "inputTypes") = c('_p_Config')
class(`Config_isMultiplexNetwork`) = c("SWIGFunction", class('Config_isMultiplexNetwork'))

# Start of Config_isBipartite

`Config_isBipartite` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_isBipartite', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isBipartite`, 'returnType') = 'logical'
attr(`Config_isBipartite`, "inputTypes") = c('_p_Config')
class(`Config_isBipartite`) = c("SWIGFunction", class('Config_isBipartite'))

# Start of Config_isStateNetwork

`Config_isStateNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_isStateNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isStateNetwork`, 'returnType') = 'logical'
attr(`Config_isStateNetwork`, "inputTypes") = c('_p_Config')
class(`Config_isStateNetwork`) = c("SWIGFunction", class('Config_isStateNetwork'))

# Start of Config_haveOutput

`Config_haveOutput` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_haveOutput', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_haveOutput`, 'returnType') = 'logical'
attr(`Config_haveOutput`, "inputTypes") = c('_p_Config')
class(`Config_haveOutput`) = c("SWIGFunction", class('Config_haveOutput'))

# Start of Config_haveModularResultOutput

`Config_haveModularResultOutput` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_haveModularResultOutput', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_haveModularResultOutput`, 'returnType') = 'logical'
attr(`Config_haveModularResultOutput`, "inputTypes") = c('_p_Config')
class(`Config_haveModularResultOutput`) = c("SWIGFunction", class('Config_haveModularResultOutput'))

# Start of Config_elapsedTime

`Config_elapsedTime` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Config_elapsedTime', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_ElapsedTime", ref=ans);
  
  ans
  
}

attr(`Config_elapsedTime`, 'returnType') = '_p_ElapsedTime'
attr(`Config_elapsedTime`, "inputTypes") = c('_p_Config')
class(`Config_elapsedTime`) = c("SWIGFunction", class('Config_elapsedTime'))

# Start of Config_parsedArgs_set

`Config_parsedArgs_set` = function(self, s_parsedArgs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_parsedArgs = as(s_parsedArgs, "character"); 
  ;.Call('R_swig_Config_parsedArgs_set', self, s_parsedArgs, PACKAGE='infomap');
  
}

attr(`Config_parsedArgs_set`, 'returnType') = 'void'
attr(`Config_parsedArgs_set`, "inputTypes") = c('_p_Config', 'character')
class(`Config_parsedArgs_set`) = c("SWIGFunction", class('Config_parsedArgs_set'))

# Start of Config_parsedArgs_get

`Config_parsedArgs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_parsedArgs_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_parsedArgs_get`, 'returnType') = 'character'
attr(`Config_parsedArgs_get`, "inputTypes") = c('_p_Config')
class(`Config_parsedArgs_get`) = c("SWIGFunction", class('Config_parsedArgs_get'))

# Start of Config_networkFile_set

`Config_networkFile_set` = function(self, s_networkFile)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_networkFile = as(s_networkFile, "character"); 
  ;.Call('R_swig_Config_networkFile_set', self, s_networkFile, PACKAGE='infomap');
  
}

attr(`Config_networkFile_set`, 'returnType') = 'void'
attr(`Config_networkFile_set`, "inputTypes") = c('_p_Config', 'character')
class(`Config_networkFile_set`) = c("SWIGFunction", class('Config_networkFile_set'))

# Start of Config_networkFile_get

`Config_networkFile_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_networkFile_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_networkFile_get`, 'returnType') = 'character'
attr(`Config_networkFile_get`, "inputTypes") = c('_p_Config')
class(`Config_networkFile_get`) = c("SWIGFunction", class('Config_networkFile_get'))

# Start of Config_additionalInput_set

`Config_additionalInput_set` = function(self, s_additionalInput)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_additionalInput, "ExternalReference")) s_additionalInput = slot(s_additionalInput,"ref") 
  ;.Call('R_swig_Config_additionalInput_set', self, s_additionalInput, PACKAGE='infomap');
  
}

attr(`Config_additionalInput_set`, 'returnType') = 'void'
attr(`Config_additionalInput_set`, "inputTypes") = c('_p_Config', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`Config_additionalInput_set`) = c("SWIGFunction", class('Config_additionalInput_set'))

# Start of Config_additionalInput_get

`Config_additionalInput_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Config_additionalInput_get', self, PACKAGE='infomap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`Config_additionalInput_get`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`Config_additionalInput_get`, "inputTypes") = c('_p_Config')
class(`Config_additionalInput_get`) = c("SWIGFunction", class('Config_additionalInput_get'))

# Start of Config_inputFormat_set

`Config_inputFormat_set` = function(self, s_inputFormat)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_inputFormat = as(s_inputFormat, "character"); 
  ;.Call('R_swig_Config_inputFormat_set', self, s_inputFormat, PACKAGE='infomap');
  
}

attr(`Config_inputFormat_set`, 'returnType') = 'void'
attr(`Config_inputFormat_set`, "inputTypes") = c('_p_Config', 'character')
class(`Config_inputFormat_set`) = c("SWIGFunction", class('Config_inputFormat_set'))

# Start of Config_inputFormat_get

`Config_inputFormat_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_inputFormat_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_inputFormat_get`, 'returnType') = 'character'
attr(`Config_inputFormat_get`, "inputTypes") = c('_p_Config')
class(`Config_inputFormat_get`) = c("SWIGFunction", class('Config_inputFormat_get'))

# Start of Config_withMemory_set

`Config_withMemory_set` = function(self, s_withMemory)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_withMemory = as.logical(s_withMemory);
  ;.Call('R_swig_Config_withMemory_set', self, s_withMemory, PACKAGE='infomap');
  
}

attr(`Config_withMemory_set`, 'returnType') = 'void'
attr(`Config_withMemory_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_withMemory_set`) = c("SWIGFunction", class('Config_withMemory_set'))

# Start of Config_withMemory_get

`Config_withMemory_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_withMemory_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_withMemory_get`, 'returnType') = 'logical'
attr(`Config_withMemory_get`, "inputTypes") = c('_p_Config')
class(`Config_withMemory_get`) = c("SWIGFunction", class('Config_withMemory_get'))

# Start of Config_bipartite_set

`Config_bipartite_set` = function(self, s_bipartite)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_bipartite = as.logical(s_bipartite);
  ;.Call('R_swig_Config_bipartite_set', self, s_bipartite, PACKAGE='infomap');
  
}

attr(`Config_bipartite_set`, 'returnType') = 'void'
attr(`Config_bipartite_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_bipartite_set`) = c("SWIGFunction", class('Config_bipartite_set'))

# Start of Config_bipartite_get

`Config_bipartite_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_bipartite_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_bipartite_get`, 'returnType') = 'logical'
attr(`Config_bipartite_get`, "inputTypes") = c('_p_Config')
class(`Config_bipartite_get`) = c("SWIGFunction", class('Config_bipartite_get'))

# Start of Config_skipAdjustBipartiteFlow_set

`Config_skipAdjustBipartiteFlow_set` = function(self, s_skipAdjustBipartiteFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_skipAdjustBipartiteFlow = as.logical(s_skipAdjustBipartiteFlow);
  ;.Call('R_swig_Config_skipAdjustBipartiteFlow_set', self, s_skipAdjustBipartiteFlow, PACKAGE='infomap');
  
}

attr(`Config_skipAdjustBipartiteFlow_set`, 'returnType') = 'void'
attr(`Config_skipAdjustBipartiteFlow_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_skipAdjustBipartiteFlow_set`) = c("SWIGFunction", class('Config_skipAdjustBipartiteFlow_set'))

# Start of Config_skipAdjustBipartiteFlow_get

`Config_skipAdjustBipartiteFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_skipAdjustBipartiteFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_skipAdjustBipartiteFlow_get`, 'returnType') = 'logical'
attr(`Config_skipAdjustBipartiteFlow_get`, "inputTypes") = c('_p_Config')
class(`Config_skipAdjustBipartiteFlow_get`) = c("SWIGFunction", class('Config_skipAdjustBipartiteFlow_get'))

# Start of Config_multiplexAddMissingNodes_set

`Config_multiplexAddMissingNodes_set` = function(self, s_multiplexAddMissingNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_multiplexAddMissingNodes = as.logical(s_multiplexAddMissingNodes);
  ;.Call('R_swig_Config_multiplexAddMissingNodes_set', self, s_multiplexAddMissingNodes, PACKAGE='infomap');
  
}

attr(`Config_multiplexAddMissingNodes_set`, 'returnType') = 'void'
attr(`Config_multiplexAddMissingNodes_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_multiplexAddMissingNodes_set`) = c("SWIGFunction", class('Config_multiplexAddMissingNodes_set'))

# Start of Config_multiplexAddMissingNodes_get

`Config_multiplexAddMissingNodes_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_multiplexAddMissingNodes_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multiplexAddMissingNodes_get`, 'returnType') = 'logical'
attr(`Config_multiplexAddMissingNodes_get`, "inputTypes") = c('_p_Config')
class(`Config_multiplexAddMissingNodes_get`) = c("SWIGFunction", class('Config_multiplexAddMissingNodes_get'))

# Start of Config_hardPartitions_set

`Config_hardPartitions_set` = function(self, s_hardPartitions)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_hardPartitions = as.logical(s_hardPartitions);
  ;.Call('R_swig_Config_hardPartitions_set', self, s_hardPartitions, PACKAGE='infomap');
  
}

attr(`Config_hardPartitions_set`, 'returnType') = 'void'
attr(`Config_hardPartitions_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_hardPartitions_set`) = c("SWIGFunction", class('Config_hardPartitions_set'))

# Start of Config_hardPartitions_get

`Config_hardPartitions_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_hardPartitions_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_hardPartitions_get`, 'returnType') = 'logical'
attr(`Config_hardPartitions_get`, "inputTypes") = c('_p_Config')
class(`Config_hardPartitions_get`) = c("SWIGFunction", class('Config_hardPartitions_get'))

# Start of Config_nonBacktracking_set

`Config_nonBacktracking_set` = function(self, s_nonBacktracking)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_nonBacktracking = as.logical(s_nonBacktracking);
  ;.Call('R_swig_Config_nonBacktracking_set', self, s_nonBacktracking, PACKAGE='infomap');
  
}

attr(`Config_nonBacktracking_set`, 'returnType') = 'void'
attr(`Config_nonBacktracking_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_nonBacktracking_set`) = c("SWIGFunction", class('Config_nonBacktracking_set'))

# Start of Config_nonBacktracking_get

`Config_nonBacktracking_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_nonBacktracking_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_nonBacktracking_get`, 'returnType') = 'logical'
attr(`Config_nonBacktracking_get`, "inputTypes") = c('_p_Config')
class(`Config_nonBacktracking_get`) = c("SWIGFunction", class('Config_nonBacktracking_get'))

# Start of Config_parseWithoutIOStreams_set

`Config_parseWithoutIOStreams_set` = function(self, s_parseWithoutIOStreams)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_parseWithoutIOStreams = as.logical(s_parseWithoutIOStreams);
  ;.Call('R_swig_Config_parseWithoutIOStreams_set', self, s_parseWithoutIOStreams, PACKAGE='infomap');
  
}

attr(`Config_parseWithoutIOStreams_set`, 'returnType') = 'void'
attr(`Config_parseWithoutIOStreams_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_parseWithoutIOStreams_set`) = c("SWIGFunction", class('Config_parseWithoutIOStreams_set'))

# Start of Config_parseWithoutIOStreams_get

`Config_parseWithoutIOStreams_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_parseWithoutIOStreams_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_parseWithoutIOStreams_get`, 'returnType') = 'logical'
attr(`Config_parseWithoutIOStreams_get`, "inputTypes") = c('_p_Config')
class(`Config_parseWithoutIOStreams_get`) = c("SWIGFunction", class('Config_parseWithoutIOStreams_get'))

# Start of Config_zeroBasedNodeNumbers_set

`Config_zeroBasedNodeNumbers_set` = function(self, s_zeroBasedNodeNumbers)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_zeroBasedNodeNumbers = as.logical(s_zeroBasedNodeNumbers);
  ;.Call('R_swig_Config_zeroBasedNodeNumbers_set', self, s_zeroBasedNodeNumbers, PACKAGE='infomap');
  
}

attr(`Config_zeroBasedNodeNumbers_set`, 'returnType') = 'void'
attr(`Config_zeroBasedNodeNumbers_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_zeroBasedNodeNumbers_set`) = c("SWIGFunction", class('Config_zeroBasedNodeNumbers_set'))

# Start of Config_zeroBasedNodeNumbers_get

`Config_zeroBasedNodeNumbers_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_zeroBasedNodeNumbers_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_zeroBasedNodeNumbers_get`, 'returnType') = 'logical'
attr(`Config_zeroBasedNodeNumbers_get`, "inputTypes") = c('_p_Config')
class(`Config_zeroBasedNodeNumbers_get`) = c("SWIGFunction", class('Config_zeroBasedNodeNumbers_get'))

# Start of Config_includeSelfLinks_set

`Config_includeSelfLinks_set` = function(self, s_includeSelfLinks)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_includeSelfLinks = as.logical(s_includeSelfLinks);
  ;.Call('R_swig_Config_includeSelfLinks_set', self, s_includeSelfLinks, PACKAGE='infomap');
  
}

attr(`Config_includeSelfLinks_set`, 'returnType') = 'void'
attr(`Config_includeSelfLinks_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_includeSelfLinks_set`) = c("SWIGFunction", class('Config_includeSelfLinks_set'))

# Start of Config_includeSelfLinks_get

`Config_includeSelfLinks_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_includeSelfLinks_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_includeSelfLinks_get`, 'returnType') = 'logical'
attr(`Config_includeSelfLinks_get`, "inputTypes") = c('_p_Config')
class(`Config_includeSelfLinks_get`) = c("SWIGFunction", class('Config_includeSelfLinks_get'))

# Start of Config_ignoreEdgeWeights_set

`Config_ignoreEdgeWeights_set` = function(self, s_ignoreEdgeWeights)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_ignoreEdgeWeights = as.logical(s_ignoreEdgeWeights);
  ;.Call('R_swig_Config_ignoreEdgeWeights_set', self, s_ignoreEdgeWeights, PACKAGE='infomap');
  
}

attr(`Config_ignoreEdgeWeights_set`, 'returnType') = 'void'
attr(`Config_ignoreEdgeWeights_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_ignoreEdgeWeights_set`) = c("SWIGFunction", class('Config_ignoreEdgeWeights_set'))

# Start of Config_ignoreEdgeWeights_get

`Config_ignoreEdgeWeights_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_ignoreEdgeWeights_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_ignoreEdgeWeights_get`, 'returnType') = 'logical'
attr(`Config_ignoreEdgeWeights_get`, "inputTypes") = c('_p_Config')
class(`Config_ignoreEdgeWeights_get`) = c("SWIGFunction", class('Config_ignoreEdgeWeights_get'))

# Start of Config_completeDanglingMemoryNodes_set

`Config_completeDanglingMemoryNodes_set` = function(self, s_completeDanglingMemoryNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_completeDanglingMemoryNodes = as.logical(s_completeDanglingMemoryNodes);
  ;.Call('R_swig_Config_completeDanglingMemoryNodes_set', self, s_completeDanglingMemoryNodes, PACKAGE='infomap');
  
}

attr(`Config_completeDanglingMemoryNodes_set`, 'returnType') = 'void'
attr(`Config_completeDanglingMemoryNodes_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_completeDanglingMemoryNodes_set`) = c("SWIGFunction", class('Config_completeDanglingMemoryNodes_set'))

# Start of Config_completeDanglingMemoryNodes_get

`Config_completeDanglingMemoryNodes_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_completeDanglingMemoryNodes_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_completeDanglingMemoryNodes_get`, 'returnType') = 'logical'
attr(`Config_completeDanglingMemoryNodes_get`, "inputTypes") = c('_p_Config')
class(`Config_completeDanglingMemoryNodes_get`) = c("SWIGFunction", class('Config_completeDanglingMemoryNodes_get'))

# Start of Config_nodeLimit_set

`Config_nodeLimit_set` = function(self, s_nodeLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_nodeLimit = as.integer(s_nodeLimit);
  
  if(length(s_nodeLimit) > 1) {
    warning("using only the first element of s_nodeLimit");
  };
  
  ;.Call('R_swig_Config_nodeLimit_set', self, s_nodeLimit, PACKAGE='infomap');
  
}

attr(`Config_nodeLimit_set`, 'returnType') = 'void'
attr(`Config_nodeLimit_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_nodeLimit_set`) = c("SWIGFunction", class('Config_nodeLimit_set'))

# Start of Config_nodeLimit_get

`Config_nodeLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_nodeLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_nodeLimit_get`, 'returnType') = 'integer'
attr(`Config_nodeLimit_get`, "inputTypes") = c('_p_Config')
class(`Config_nodeLimit_get`) = c("SWIGFunction", class('Config_nodeLimit_get'))

# Start of Config_preClusterMultiplex_set

`Config_preClusterMultiplex_set` = function(self, s_preClusterMultiplex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_preClusterMultiplex = as.logical(s_preClusterMultiplex);
  ;.Call('R_swig_Config_preClusterMultiplex_set', self, s_preClusterMultiplex, PACKAGE='infomap');
  
}

attr(`Config_preClusterMultiplex_set`, 'returnType') = 'void'
attr(`Config_preClusterMultiplex_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_preClusterMultiplex_set`) = c("SWIGFunction", class('Config_preClusterMultiplex_set'))

# Start of Config_preClusterMultiplex_get

`Config_preClusterMultiplex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_preClusterMultiplex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_preClusterMultiplex_get`, 'returnType') = 'logical'
attr(`Config_preClusterMultiplex_get`, "inputTypes") = c('_p_Config')
class(`Config_preClusterMultiplex_get`) = c("SWIGFunction", class('Config_preClusterMultiplex_get'))

# Start of Config_clusterDataFile_set

`Config_clusterDataFile_set` = function(self, s_clusterDataFile)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_clusterDataFile = as(s_clusterDataFile, "character"); 
  ;.Call('R_swig_Config_clusterDataFile_set', self, s_clusterDataFile, PACKAGE='infomap');
  
}

attr(`Config_clusterDataFile_set`, 'returnType') = 'void'
attr(`Config_clusterDataFile_set`, "inputTypes") = c('_p_Config', 'character')
class(`Config_clusterDataFile_set`) = c("SWIGFunction", class('Config_clusterDataFile_set'))

# Start of Config_clusterDataFile_get

`Config_clusterDataFile_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_clusterDataFile_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_clusterDataFile_get`, 'returnType') = 'character'
attr(`Config_clusterDataFile_get`, "inputTypes") = c('_p_Config')
class(`Config_clusterDataFile_get`) = c("SWIGFunction", class('Config_clusterDataFile_get'))

# Start of Config_noInfomap_set

`Config_noInfomap_set` = function(self, s_noInfomap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_noInfomap = as.logical(s_noInfomap);
  ;.Call('R_swig_Config_noInfomap_set', self, s_noInfomap, PACKAGE='infomap');
  
}

attr(`Config_noInfomap_set`, 'returnType') = 'void'
attr(`Config_noInfomap_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_noInfomap_set`) = c("SWIGFunction", class('Config_noInfomap_set'))

# Start of Config_noInfomap_get

`Config_noInfomap_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_noInfomap_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_noInfomap_get`, 'returnType') = 'logical'
attr(`Config_noInfomap_get`, "inputTypes") = c('_p_Config')
class(`Config_noInfomap_get`) = c("SWIGFunction", class('Config_noInfomap_get'))

# Start of Config_twoLevel_set

`Config_twoLevel_set` = function(self, s_twoLevel)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_twoLevel = as.logical(s_twoLevel);
  ;.Call('R_swig_Config_twoLevel_set', self, s_twoLevel, PACKAGE='infomap');
  
}

attr(`Config_twoLevel_set`, 'returnType') = 'void'
attr(`Config_twoLevel_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_twoLevel_set`) = c("SWIGFunction", class('Config_twoLevel_set'))

# Start of Config_twoLevel_get

`Config_twoLevel_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_twoLevel_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_twoLevel_get`, 'returnType') = 'logical'
attr(`Config_twoLevel_get`, "inputTypes") = c('_p_Config')
class(`Config_twoLevel_get`) = c("SWIGFunction", class('Config_twoLevel_get'))

# Start of Config_directed_set

`Config_directed_set` = function(self, s_directed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_directed = as.logical(s_directed);
  ;.Call('R_swig_Config_directed_set', self, s_directed, PACKAGE='infomap');
  
}

attr(`Config_directed_set`, 'returnType') = 'void'
attr(`Config_directed_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_directed_set`) = c("SWIGFunction", class('Config_directed_set'))

# Start of Config_directed_get

`Config_directed_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_directed_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_directed_get`, 'returnType') = 'logical'
attr(`Config_directed_get`, "inputTypes") = c('_p_Config')
class(`Config_directed_get`) = c("SWIGFunction", class('Config_directed_get'))

# Start of Config_undirdir_set

`Config_undirdir_set` = function(self, s_undirdir)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_undirdir = as.logical(s_undirdir);
  ;.Call('R_swig_Config_undirdir_set', self, s_undirdir, PACKAGE='infomap');
  
}

attr(`Config_undirdir_set`, 'returnType') = 'void'
attr(`Config_undirdir_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_undirdir_set`) = c("SWIGFunction", class('Config_undirdir_set'))

# Start of Config_undirdir_get

`Config_undirdir_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_undirdir_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_undirdir_get`, 'returnType') = 'logical'
attr(`Config_undirdir_get`, "inputTypes") = c('_p_Config')
class(`Config_undirdir_get`) = c("SWIGFunction", class('Config_undirdir_get'))

# Start of Config_outdirdir_set

`Config_outdirdir_set` = function(self, s_outdirdir)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_outdirdir = as.logical(s_outdirdir);
  ;.Call('R_swig_Config_outdirdir_set', self, s_outdirdir, PACKAGE='infomap');
  
}

attr(`Config_outdirdir_set`, 'returnType') = 'void'
attr(`Config_outdirdir_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_outdirdir_set`) = c("SWIGFunction", class('Config_outdirdir_set'))

# Start of Config_outdirdir_get

`Config_outdirdir_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_outdirdir_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_outdirdir_get`, 'returnType') = 'logical'
attr(`Config_outdirdir_get`, "inputTypes") = c('_p_Config')
class(`Config_outdirdir_get`) = c("SWIGFunction", class('Config_outdirdir_get'))

# Start of Config_rawdir_set

`Config_rawdir_set` = function(self, s_rawdir)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_rawdir = as.logical(s_rawdir);
  ;.Call('R_swig_Config_rawdir_set', self, s_rawdir, PACKAGE='infomap');
  
}

attr(`Config_rawdir_set`, 'returnType') = 'void'
attr(`Config_rawdir_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_rawdir_set`) = c("SWIGFunction", class('Config_rawdir_set'))

# Start of Config_rawdir_get

`Config_rawdir_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_rawdir_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_rawdir_get`, 'returnType') = 'logical'
attr(`Config_rawdir_get`, "inputTypes") = c('_p_Config')
class(`Config_rawdir_get`) = c("SWIGFunction", class('Config_rawdir_get'))

# Start of Config_recordedTeleportation_set

`Config_recordedTeleportation_set` = function(self, s_recordedTeleportation)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_recordedTeleportation = as.logical(s_recordedTeleportation);
  ;.Call('R_swig_Config_recordedTeleportation_set', self, s_recordedTeleportation, PACKAGE='infomap');
  
}

attr(`Config_recordedTeleportation_set`, 'returnType') = 'void'
attr(`Config_recordedTeleportation_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_recordedTeleportation_set`) = c("SWIGFunction", class('Config_recordedTeleportation_set'))

# Start of Config_recordedTeleportation_get

`Config_recordedTeleportation_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_recordedTeleportation_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_recordedTeleportation_get`, 'returnType') = 'logical'
attr(`Config_recordedTeleportation_get`, "inputTypes") = c('_p_Config')
class(`Config_recordedTeleportation_get`) = c("SWIGFunction", class('Config_recordedTeleportation_get'))

# Start of Config_teleportToNodes_set

`Config_teleportToNodes_set` = function(self, s_teleportToNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_teleportToNodes = as.logical(s_teleportToNodes);
  ;.Call('R_swig_Config_teleportToNodes_set', self, s_teleportToNodes, PACKAGE='infomap');
  
}

attr(`Config_teleportToNodes_set`, 'returnType') = 'void'
attr(`Config_teleportToNodes_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_teleportToNodes_set`) = c("SWIGFunction", class('Config_teleportToNodes_set'))

# Start of Config_teleportToNodes_get

`Config_teleportToNodes_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_teleportToNodes_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_teleportToNodes_get`, 'returnType') = 'logical'
attr(`Config_teleportToNodes_get`, "inputTypes") = c('_p_Config')
class(`Config_teleportToNodes_get`) = c("SWIGFunction", class('Config_teleportToNodes_get'))

# Start of Config_teleportationProbability_set

`Config_teleportationProbability_set` = function(self, s_teleportationProbability)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_teleportationProbability_set', self, s_teleportationProbability, PACKAGE='infomap');
  
}

attr(`Config_teleportationProbability_set`, 'returnType') = 'void'
attr(`Config_teleportationProbability_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_teleportationProbability_set`) = c("SWIGFunction", class('Config_teleportationProbability_set'))

# Start of Config_teleportationProbability_get

`Config_teleportationProbability_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_teleportationProbability_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_teleportationProbability_get`, 'returnType') = 'numeric'
attr(`Config_teleportationProbability_get`, "inputTypes") = c('_p_Config')
class(`Config_teleportationProbability_get`) = c("SWIGFunction", class('Config_teleportationProbability_get'))

# Start of Config_selfTeleportationProbability_set

`Config_selfTeleportationProbability_set` = function(self, s_selfTeleportationProbability)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_selfTeleportationProbability_set', self, s_selfTeleportationProbability, PACKAGE='infomap');
  
}

attr(`Config_selfTeleportationProbability_set`, 'returnType') = 'void'
attr(`Config_selfTeleportationProbability_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_selfTeleportationProbability_set`) = c("SWIGFunction", class('Config_selfTeleportationProbability_set'))

# Start of Config_selfTeleportationProbability_get

`Config_selfTeleportationProbability_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_selfTeleportationProbability_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_selfTeleportationProbability_get`, 'returnType') = 'numeric'
attr(`Config_selfTeleportationProbability_get`, "inputTypes") = c('_p_Config')
class(`Config_selfTeleportationProbability_get`) = c("SWIGFunction", class('Config_selfTeleportationProbability_get'))

# Start of Config_markovTime_set

`Config_markovTime_set` = function(self, s_markovTime)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_markovTime_set', self, s_markovTime, PACKAGE='infomap');
  
}

attr(`Config_markovTime_set`, 'returnType') = 'void'
attr(`Config_markovTime_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_markovTime_set`) = c("SWIGFunction", class('Config_markovTime_set'))

# Start of Config_markovTime_get

`Config_markovTime_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_markovTime_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_markovTime_get`, 'returnType') = 'numeric'
attr(`Config_markovTime_get`, "inputTypes") = c('_p_Config')
class(`Config_markovTime_get`) = c("SWIGFunction", class('Config_markovTime_get'))

# Start of Config_variableMarkovTime_set

`Config_variableMarkovTime_set` = function(self, s_variableMarkovTime)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_variableMarkovTime = as.logical(s_variableMarkovTime);
  ;.Call('R_swig_Config_variableMarkovTime_set', self, s_variableMarkovTime, PACKAGE='infomap');
  
}

attr(`Config_variableMarkovTime_set`, 'returnType') = 'void'
attr(`Config_variableMarkovTime_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_variableMarkovTime_set`) = c("SWIGFunction", class('Config_variableMarkovTime_set'))

# Start of Config_variableMarkovTime_get

`Config_variableMarkovTime_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_variableMarkovTime_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_variableMarkovTime_get`, 'returnType') = 'logical'
attr(`Config_variableMarkovTime_get`, "inputTypes") = c('_p_Config')
class(`Config_variableMarkovTime_get`) = c("SWIGFunction", class('Config_variableMarkovTime_get'))

# Start of Config_preferredNumberOfModules_set

`Config_preferredNumberOfModules_set` = function(self, s_preferredNumberOfModules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_preferredNumberOfModules = as.integer(s_preferredNumberOfModules);
  
  if(length(s_preferredNumberOfModules) > 1) {
    warning("using only the first element of s_preferredNumberOfModules");
  };
  
  ;.Call('R_swig_Config_preferredNumberOfModules_set', self, s_preferredNumberOfModules, PACKAGE='infomap');
  
}

attr(`Config_preferredNumberOfModules_set`, 'returnType') = 'void'
attr(`Config_preferredNumberOfModules_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_preferredNumberOfModules_set`) = c("SWIGFunction", class('Config_preferredNumberOfModules_set'))

# Start of Config_preferredNumberOfModules_get

`Config_preferredNumberOfModules_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_preferredNumberOfModules_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_preferredNumberOfModules_get`, 'returnType') = 'integer'
attr(`Config_preferredNumberOfModules_get`, "inputTypes") = c('_p_Config')
class(`Config_preferredNumberOfModules_get`) = c("SWIGFunction", class('Config_preferredNumberOfModules_get'))

# Start of Config_multiplexRelaxRate_set

`Config_multiplexRelaxRate_set` = function(self, s_multiplexRelaxRate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_multiplexRelaxRate_set', self, s_multiplexRelaxRate, PACKAGE='infomap');
  
}

attr(`Config_multiplexRelaxRate_set`, 'returnType') = 'void'
attr(`Config_multiplexRelaxRate_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_multiplexRelaxRate_set`) = c("SWIGFunction", class('Config_multiplexRelaxRate_set'))

# Start of Config_multiplexRelaxRate_get

`Config_multiplexRelaxRate_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_multiplexRelaxRate_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multiplexRelaxRate_get`, 'returnType') = 'numeric'
attr(`Config_multiplexRelaxRate_get`, "inputTypes") = c('_p_Config')
class(`Config_multiplexRelaxRate_get`) = c("SWIGFunction", class('Config_multiplexRelaxRate_get'))

# Start of Config_multiplexJSRelaxRate_set

`Config_multiplexJSRelaxRate_set` = function(self, s_multiplexJSRelaxRate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_multiplexJSRelaxRate_set', self, s_multiplexJSRelaxRate, PACKAGE='infomap');
  
}

attr(`Config_multiplexJSRelaxRate_set`, 'returnType') = 'void'
attr(`Config_multiplexJSRelaxRate_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_multiplexJSRelaxRate_set`) = c("SWIGFunction", class('Config_multiplexJSRelaxRate_set'))

# Start of Config_multiplexJSRelaxRate_get

`Config_multiplexJSRelaxRate_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_multiplexJSRelaxRate_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multiplexJSRelaxRate_get`, 'returnType') = 'numeric'
attr(`Config_multiplexJSRelaxRate_get`, "inputTypes") = c('_p_Config')
class(`Config_multiplexJSRelaxRate_get`) = c("SWIGFunction", class('Config_multiplexJSRelaxRate_get'))

# Start of Config_multiplexJSRelaxLimit_set

`Config_multiplexJSRelaxLimit_set` = function(self, s_multiplexJSRelaxLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_multiplexJSRelaxLimit_set', self, s_multiplexJSRelaxLimit, PACKAGE='infomap');
  
}

attr(`Config_multiplexJSRelaxLimit_set`, 'returnType') = 'void'
attr(`Config_multiplexJSRelaxLimit_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_multiplexJSRelaxLimit_set`) = c("SWIGFunction", class('Config_multiplexJSRelaxLimit_set'))

# Start of Config_multiplexJSRelaxLimit_get

`Config_multiplexJSRelaxLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_multiplexJSRelaxLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multiplexJSRelaxLimit_get`, 'returnType') = 'numeric'
attr(`Config_multiplexJSRelaxLimit_get`, "inputTypes") = c('_p_Config')
class(`Config_multiplexJSRelaxLimit_get`) = c("SWIGFunction", class('Config_multiplexJSRelaxLimit_get'))

# Start of Config_multiplexRelaxLimit_set

`Config_multiplexRelaxLimit_set` = function(self, s_multiplexRelaxLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_multiplexRelaxLimit = as.integer(s_multiplexRelaxLimit);
  
  if(length(s_multiplexRelaxLimit) > 1) {
    warning("using only the first element of s_multiplexRelaxLimit");
  };
  
  ;.Call('R_swig_Config_multiplexRelaxLimit_set', self, s_multiplexRelaxLimit, PACKAGE='infomap');
  
}

attr(`Config_multiplexRelaxLimit_set`, 'returnType') = 'void'
attr(`Config_multiplexRelaxLimit_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_multiplexRelaxLimit_set`) = c("SWIGFunction", class('Config_multiplexRelaxLimit_set'))

# Start of Config_multiplexRelaxLimit_get

`Config_multiplexRelaxLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_multiplexRelaxLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multiplexRelaxLimit_get`, 'returnType') = 'integer'
attr(`Config_multiplexRelaxLimit_get`, "inputTypes") = c('_p_Config')
class(`Config_multiplexRelaxLimit_get`) = c("SWIGFunction", class('Config_multiplexRelaxLimit_get'))

# Start of Config_seedToRandomNumberGenerator_set

`Config_seedToRandomNumberGenerator_set` = function(self, s_seedToRandomNumberGenerator)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_seedToRandomNumberGenerator = as.integer(s_seedToRandomNumberGenerator);
  
  if(length(s_seedToRandomNumberGenerator) > 1) {
    warning("using only the first element of s_seedToRandomNumberGenerator");
  };
  
  ;.Call('R_swig_Config_seedToRandomNumberGenerator_set', self, s_seedToRandomNumberGenerator, PACKAGE='infomap');
  
}

attr(`Config_seedToRandomNumberGenerator_set`, 'returnType') = 'void'
attr(`Config_seedToRandomNumberGenerator_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_seedToRandomNumberGenerator_set`) = c("SWIGFunction", class('Config_seedToRandomNumberGenerator_set'))

# Start of Config_seedToRandomNumberGenerator_get

`Config_seedToRandomNumberGenerator_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_seedToRandomNumberGenerator_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_seedToRandomNumberGenerator_get`, 'returnType') = 'integer'
attr(`Config_seedToRandomNumberGenerator_get`, "inputTypes") = c('_p_Config')
class(`Config_seedToRandomNumberGenerator_get`) = c("SWIGFunction", class('Config_seedToRandomNumberGenerator_get'))

# Start of Config_numTrials_set

`Config_numTrials_set` = function(self, s_numTrials)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_numTrials = as.integer(s_numTrials);
  
  if(length(s_numTrials) > 1) {
    warning("using only the first element of s_numTrials");
  };
  
  ;.Call('R_swig_Config_numTrials_set', self, s_numTrials, PACKAGE='infomap');
  
}

attr(`Config_numTrials_set`, 'returnType') = 'void'
attr(`Config_numTrials_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_numTrials_set`) = c("SWIGFunction", class('Config_numTrials_set'))

# Start of Config_numTrials_get

`Config_numTrials_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_numTrials_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_numTrials_get`, 'returnType') = 'integer'
attr(`Config_numTrials_get`, "inputTypes") = c('_p_Config')
class(`Config_numTrials_get`) = c("SWIGFunction", class('Config_numTrials_get'))

# Start of Config_minimumCodelengthImprovement_set

`Config_minimumCodelengthImprovement_set` = function(self, s_minimumCodelengthImprovement)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_minimumCodelengthImprovement_set', self, s_minimumCodelengthImprovement, PACKAGE='infomap');
  
}

attr(`Config_minimumCodelengthImprovement_set`, 'returnType') = 'void'
attr(`Config_minimumCodelengthImprovement_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_minimumCodelengthImprovement_set`) = c("SWIGFunction", class('Config_minimumCodelengthImprovement_set'))

# Start of Config_minimumCodelengthImprovement_get

`Config_minimumCodelengthImprovement_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_minimumCodelengthImprovement_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_minimumCodelengthImprovement_get`, 'returnType') = 'numeric'
attr(`Config_minimumCodelengthImprovement_get`, "inputTypes") = c('_p_Config')
class(`Config_minimumCodelengthImprovement_get`) = c("SWIGFunction", class('Config_minimumCodelengthImprovement_get'))

# Start of Config_minimumSingleNodeCodelengthImprovement_set

`Config_minimumSingleNodeCodelengthImprovement_set` = function(self, s_minimumSingleNodeCodelengthImprovement)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_minimumSingleNodeCodelengthImprovement_set', self, s_minimumSingleNodeCodelengthImprovement, PACKAGE='infomap');
  
}

attr(`Config_minimumSingleNodeCodelengthImprovement_set`, 'returnType') = 'void'
attr(`Config_minimumSingleNodeCodelengthImprovement_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_minimumSingleNodeCodelengthImprovement_set`) = c("SWIGFunction", class('Config_minimumSingleNodeCodelengthImprovement_set'))

# Start of Config_minimumSingleNodeCodelengthImprovement_get

`Config_minimumSingleNodeCodelengthImprovement_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_minimumSingleNodeCodelengthImprovement_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_minimumSingleNodeCodelengthImprovement_get`, 'returnType') = 'numeric'
attr(`Config_minimumSingleNodeCodelengthImprovement_get`, "inputTypes") = c('_p_Config')
class(`Config_minimumSingleNodeCodelengthImprovement_get`) = c("SWIGFunction", class('Config_minimumSingleNodeCodelengthImprovement_get'))

# Start of Config_randomizeCoreLoopLimit_set

`Config_randomizeCoreLoopLimit_set` = function(self, s_randomizeCoreLoopLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_randomizeCoreLoopLimit = as.logical(s_randomizeCoreLoopLimit);
  ;.Call('R_swig_Config_randomizeCoreLoopLimit_set', self, s_randomizeCoreLoopLimit, PACKAGE='infomap');
  
}

attr(`Config_randomizeCoreLoopLimit_set`, 'returnType') = 'void'
attr(`Config_randomizeCoreLoopLimit_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_randomizeCoreLoopLimit_set`) = c("SWIGFunction", class('Config_randomizeCoreLoopLimit_set'))

# Start of Config_randomizeCoreLoopLimit_get

`Config_randomizeCoreLoopLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_randomizeCoreLoopLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_randomizeCoreLoopLimit_get`, 'returnType') = 'logical'
attr(`Config_randomizeCoreLoopLimit_get`, "inputTypes") = c('_p_Config')
class(`Config_randomizeCoreLoopLimit_get`) = c("SWIGFunction", class('Config_randomizeCoreLoopLimit_get'))

# Start of Config_coreLoopLimit_set

`Config_coreLoopLimit_set` = function(self, s_coreLoopLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_coreLoopLimit = as.integer(s_coreLoopLimit);
  
  if(length(s_coreLoopLimit) > 1) {
    warning("using only the first element of s_coreLoopLimit");
  };
  
  ;.Call('R_swig_Config_coreLoopLimit_set', self, s_coreLoopLimit, PACKAGE='infomap');
  
}

attr(`Config_coreLoopLimit_set`, 'returnType') = 'void'
attr(`Config_coreLoopLimit_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_coreLoopLimit_set`) = c("SWIGFunction", class('Config_coreLoopLimit_set'))

# Start of Config_coreLoopLimit_get

`Config_coreLoopLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_coreLoopLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_coreLoopLimit_get`, 'returnType') = 'integer'
attr(`Config_coreLoopLimit_get`, "inputTypes") = c('_p_Config')
class(`Config_coreLoopLimit_get`) = c("SWIGFunction", class('Config_coreLoopLimit_get'))

# Start of Config_levelAggregationLimit_set

`Config_levelAggregationLimit_set` = function(self, s_levelAggregationLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_levelAggregationLimit = as.integer(s_levelAggregationLimit);
  
  if(length(s_levelAggregationLimit) > 1) {
    warning("using only the first element of s_levelAggregationLimit");
  };
  
  ;.Call('R_swig_Config_levelAggregationLimit_set', self, s_levelAggregationLimit, PACKAGE='infomap');
  
}

attr(`Config_levelAggregationLimit_set`, 'returnType') = 'void'
attr(`Config_levelAggregationLimit_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_levelAggregationLimit_set`) = c("SWIGFunction", class('Config_levelAggregationLimit_set'))

# Start of Config_levelAggregationLimit_get

`Config_levelAggregationLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_levelAggregationLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_levelAggregationLimit_get`, 'returnType') = 'integer'
attr(`Config_levelAggregationLimit_get`, "inputTypes") = c('_p_Config')
class(`Config_levelAggregationLimit_get`) = c("SWIGFunction", class('Config_levelAggregationLimit_get'))

# Start of Config_tuneIterationLimit_set

`Config_tuneIterationLimit_set` = function(self, s_tuneIterationLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_tuneIterationLimit = as.integer(s_tuneIterationLimit);
  
  if(length(s_tuneIterationLimit) > 1) {
    warning("using only the first element of s_tuneIterationLimit");
  };
  
  ;.Call('R_swig_Config_tuneIterationLimit_set', self, s_tuneIterationLimit, PACKAGE='infomap');
  
}

attr(`Config_tuneIterationLimit_set`, 'returnType') = 'void'
attr(`Config_tuneIterationLimit_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_tuneIterationLimit_set`) = c("SWIGFunction", class('Config_tuneIterationLimit_set'))

# Start of Config_tuneIterationLimit_get

`Config_tuneIterationLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_tuneIterationLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_tuneIterationLimit_get`, 'returnType') = 'integer'
attr(`Config_tuneIterationLimit_get`, "inputTypes") = c('_p_Config')
class(`Config_tuneIterationLimit_get`) = c("SWIGFunction", class('Config_tuneIterationLimit_get'))

# Start of Config_minimumRelativeTuneIterationImprovement_set

`Config_minimumRelativeTuneIterationImprovement_set` = function(self, s_minimumRelativeTuneIterationImprovement)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Config_minimumRelativeTuneIterationImprovement_set', self, s_minimumRelativeTuneIterationImprovement, PACKAGE='infomap');
  
}

attr(`Config_minimumRelativeTuneIterationImprovement_set`, 'returnType') = 'void'
attr(`Config_minimumRelativeTuneIterationImprovement_set`, "inputTypes") = c('_p_Config', 'numeric')
class(`Config_minimumRelativeTuneIterationImprovement_set`) = c("SWIGFunction", class('Config_minimumRelativeTuneIterationImprovement_set'))

# Start of Config_minimumRelativeTuneIterationImprovement_get

`Config_minimumRelativeTuneIterationImprovement_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_minimumRelativeTuneIterationImprovement_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_minimumRelativeTuneIterationImprovement_get`, 'returnType') = 'numeric'
attr(`Config_minimumRelativeTuneIterationImprovement_get`, "inputTypes") = c('_p_Config')
class(`Config_minimumRelativeTuneIterationImprovement_get`) = c("SWIGFunction", class('Config_minimumRelativeTuneIterationImprovement_get'))

# Start of Config_fastCoarseTunePartition_set

`Config_fastCoarseTunePartition_set` = function(self, s_fastCoarseTunePartition)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_fastCoarseTunePartition = as.logical(s_fastCoarseTunePartition);
  ;.Call('R_swig_Config_fastCoarseTunePartition_set', self, s_fastCoarseTunePartition, PACKAGE='infomap');
  
}

attr(`Config_fastCoarseTunePartition_set`, 'returnType') = 'void'
attr(`Config_fastCoarseTunePartition_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_fastCoarseTunePartition_set`) = c("SWIGFunction", class('Config_fastCoarseTunePartition_set'))

# Start of Config_fastCoarseTunePartition_get

`Config_fastCoarseTunePartition_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_fastCoarseTunePartition_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_fastCoarseTunePartition_get`, 'returnType') = 'logical'
attr(`Config_fastCoarseTunePartition_get`, "inputTypes") = c('_p_Config')
class(`Config_fastCoarseTunePartition_get`) = c("SWIGFunction", class('Config_fastCoarseTunePartition_get'))

# Start of Config_alternateCoarseTuneLevel_set

`Config_alternateCoarseTuneLevel_set` = function(self, s_alternateCoarseTuneLevel)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_alternateCoarseTuneLevel = as.logical(s_alternateCoarseTuneLevel);
  ;.Call('R_swig_Config_alternateCoarseTuneLevel_set', self, s_alternateCoarseTuneLevel, PACKAGE='infomap');
  
}

attr(`Config_alternateCoarseTuneLevel_set`, 'returnType') = 'void'
attr(`Config_alternateCoarseTuneLevel_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_alternateCoarseTuneLevel_set`) = c("SWIGFunction", class('Config_alternateCoarseTuneLevel_set'))

# Start of Config_alternateCoarseTuneLevel_get

`Config_alternateCoarseTuneLevel_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_alternateCoarseTuneLevel_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_alternateCoarseTuneLevel_get`, 'returnType') = 'logical'
attr(`Config_alternateCoarseTuneLevel_get`, "inputTypes") = c('_p_Config')
class(`Config_alternateCoarseTuneLevel_get`) = c("SWIGFunction", class('Config_alternateCoarseTuneLevel_get'))

# Start of Config_coarseTuneLevel_set

`Config_coarseTuneLevel_set` = function(self, s_coarseTuneLevel)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_coarseTuneLevel = as.integer(s_coarseTuneLevel);
  
  if(length(s_coarseTuneLevel) > 1) {
    warning("using only the first element of s_coarseTuneLevel");
  };
  
  ;.Call('R_swig_Config_coarseTuneLevel_set', self, s_coarseTuneLevel, PACKAGE='infomap');
  
}

attr(`Config_coarseTuneLevel_set`, 'returnType') = 'void'
attr(`Config_coarseTuneLevel_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_coarseTuneLevel_set`) = c("SWIGFunction", class('Config_coarseTuneLevel_set'))

# Start of Config_coarseTuneLevel_get

`Config_coarseTuneLevel_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_coarseTuneLevel_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_coarseTuneLevel_get`, 'returnType') = 'integer'
attr(`Config_coarseTuneLevel_get`, "inputTypes") = c('_p_Config')
class(`Config_coarseTuneLevel_get`) = c("SWIGFunction", class('Config_coarseTuneLevel_get'))

# Start of Config_fastHierarchicalSolution_set

`Config_fastHierarchicalSolution_set` = function(self, s_fastHierarchicalSolution)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_fastHierarchicalSolution = as.integer(s_fastHierarchicalSolution);
  
  if(length(s_fastHierarchicalSolution) > 1) {
    warning("using only the first element of s_fastHierarchicalSolution");
  };
  
  ;.Call('R_swig_Config_fastHierarchicalSolution_set', self, s_fastHierarchicalSolution, PACKAGE='infomap');
  
}

attr(`Config_fastHierarchicalSolution_set`, 'returnType') = 'void'
attr(`Config_fastHierarchicalSolution_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_fastHierarchicalSolution_set`) = c("SWIGFunction", class('Config_fastHierarchicalSolution_set'))

# Start of Config_fastHierarchicalSolution_get

`Config_fastHierarchicalSolution_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_fastHierarchicalSolution_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_fastHierarchicalSolution_get`, 'returnType') = 'integer'
attr(`Config_fastHierarchicalSolution_get`, "inputTypes") = c('_p_Config')
class(`Config_fastHierarchicalSolution_get`) = c("SWIGFunction", class('Config_fastHierarchicalSolution_get'))

# Start of Config_fastFirstIteration_set

`Config_fastFirstIteration_set` = function(self, s_fastFirstIteration)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_fastFirstIteration = as.logical(s_fastFirstIteration);
  ;.Call('R_swig_Config_fastFirstIteration_set', self, s_fastFirstIteration, PACKAGE='infomap');
  
}

attr(`Config_fastFirstIteration_set`, 'returnType') = 'void'
attr(`Config_fastFirstIteration_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_fastFirstIteration_set`) = c("SWIGFunction", class('Config_fastFirstIteration_set'))

# Start of Config_fastFirstIteration_get

`Config_fastFirstIteration_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_fastFirstIteration_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_fastFirstIteration_get`, 'returnType') = 'logical'
attr(`Config_fastFirstIteration_get`, "inputTypes") = c('_p_Config')
class(`Config_fastFirstIteration_get`) = c("SWIGFunction", class('Config_fastFirstIteration_get'))

# Start of Config_lowMemoryPriority_set

`Config_lowMemoryPriority_set` = function(self, s_lowMemoryPriority)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_lowMemoryPriority = as.integer(s_lowMemoryPriority);
  
  if(length(s_lowMemoryPriority) > 1) {
    warning("using only the first element of s_lowMemoryPriority");
  };
  
  ;.Call('R_swig_Config_lowMemoryPriority_set', self, s_lowMemoryPriority, PACKAGE='infomap');
  
}

attr(`Config_lowMemoryPriority_set`, 'returnType') = 'void'
attr(`Config_lowMemoryPriority_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_lowMemoryPriority_set`) = c("SWIGFunction", class('Config_lowMemoryPriority_set'))

# Start of Config_lowMemoryPriority_get

`Config_lowMemoryPriority_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_lowMemoryPriority_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_lowMemoryPriority_get`, 'returnType') = 'integer'
attr(`Config_lowMemoryPriority_get`, "inputTypes") = c('_p_Config')
class(`Config_lowMemoryPriority_get`) = c("SWIGFunction", class('Config_lowMemoryPriority_get'))

# Start of Config_innerParallelization_set

`Config_innerParallelization_set` = function(self, s_innerParallelization)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_innerParallelization = as.logical(s_innerParallelization);
  ;.Call('R_swig_Config_innerParallelization_set', self, s_innerParallelization, PACKAGE='infomap');
  
}

attr(`Config_innerParallelization_set`, 'returnType') = 'void'
attr(`Config_innerParallelization_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_innerParallelization_set`) = c("SWIGFunction", class('Config_innerParallelization_set'))

# Start of Config_innerParallelization_get

`Config_innerParallelization_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_innerParallelization_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_innerParallelization_get`, 'returnType') = 'logical'
attr(`Config_innerParallelization_get`, "inputTypes") = c('_p_Config')
class(`Config_innerParallelization_get`) = c("SWIGFunction", class('Config_innerParallelization_get'))

# Start of Config_resetConfigBeforeRecursion_set

`Config_resetConfigBeforeRecursion_set` = function(self, s_resetConfigBeforeRecursion)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_resetConfigBeforeRecursion = as.logical(s_resetConfigBeforeRecursion);
  ;.Call('R_swig_Config_resetConfigBeforeRecursion_set', self, s_resetConfigBeforeRecursion, PACKAGE='infomap');
  
}

attr(`Config_resetConfigBeforeRecursion_set`, 'returnType') = 'void'
attr(`Config_resetConfigBeforeRecursion_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_resetConfigBeforeRecursion_set`) = c("SWIGFunction", class('Config_resetConfigBeforeRecursion_set'))

# Start of Config_resetConfigBeforeRecursion_get

`Config_resetConfigBeforeRecursion_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_resetConfigBeforeRecursion_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_resetConfigBeforeRecursion_get`, 'returnType') = 'logical'
attr(`Config_resetConfigBeforeRecursion_get`, "inputTypes") = c('_p_Config')
class(`Config_resetConfigBeforeRecursion_get`) = c("SWIGFunction", class('Config_resetConfigBeforeRecursion_get'))

# Start of Config_outDirectory_set

`Config_outDirectory_set` = function(self, s_outDirectory)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_outDirectory = as(s_outDirectory, "character"); 
  ;.Call('R_swig_Config_outDirectory_set', self, s_outDirectory, PACKAGE='infomap');
  
}

attr(`Config_outDirectory_set`, 'returnType') = 'void'
attr(`Config_outDirectory_set`, "inputTypes") = c('_p_Config', 'character')
class(`Config_outDirectory_set`) = c("SWIGFunction", class('Config_outDirectory_set'))

# Start of Config_outDirectory_get

`Config_outDirectory_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_outDirectory_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_outDirectory_get`, 'returnType') = 'character'
attr(`Config_outDirectory_get`, "inputTypes") = c('_p_Config')
class(`Config_outDirectory_get`) = c("SWIGFunction", class('Config_outDirectory_get'))

# Start of Config_outName_set

`Config_outName_set` = function(self, s_outName)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_outName = as(s_outName, "character"); 
  ;.Call('R_swig_Config_outName_set', self, s_outName, PACKAGE='infomap');
  
}

attr(`Config_outName_set`, 'returnType') = 'void'
attr(`Config_outName_set`, "inputTypes") = c('_p_Config', 'character')
class(`Config_outName_set`) = c("SWIGFunction", class('Config_outName_set'))

# Start of Config_outName_get

`Config_outName_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_outName_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_outName_get`, 'returnType') = 'character'
attr(`Config_outName_get`, "inputTypes") = c('_p_Config')
class(`Config_outName_get`) = c("SWIGFunction", class('Config_outName_get'))

# Start of Config_originallyUndirected_set

`Config_originallyUndirected_set` = function(self, s_originallyUndirected)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_originallyUndirected = as.logical(s_originallyUndirected);
  ;.Call('R_swig_Config_originallyUndirected_set', self, s_originallyUndirected, PACKAGE='infomap');
  
}

attr(`Config_originallyUndirected_set`, 'returnType') = 'void'
attr(`Config_originallyUndirected_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_originallyUndirected_set`) = c("SWIGFunction", class('Config_originallyUndirected_set'))

# Start of Config_originallyUndirected_get

`Config_originallyUndirected_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_originallyUndirected_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_originallyUndirected_get`, 'returnType') = 'logical'
attr(`Config_originallyUndirected_get`, "inputTypes") = c('_p_Config')
class(`Config_originallyUndirected_get`) = c("SWIGFunction", class('Config_originallyUndirected_get'))

# Start of Config_printTree_set

`Config_printTree_set` = function(self, s_printTree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printTree = as.logical(s_printTree);
  ;.Call('R_swig_Config_printTree_set', self, s_printTree, PACKAGE='infomap');
  
}

attr(`Config_printTree_set`, 'returnType') = 'void'
attr(`Config_printTree_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printTree_set`) = c("SWIGFunction", class('Config_printTree_set'))

# Start of Config_printTree_get

`Config_printTree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printTree_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printTree_get`, 'returnType') = 'logical'
attr(`Config_printTree_get`, "inputTypes") = c('_p_Config')
class(`Config_printTree_get`) = c("SWIGFunction", class('Config_printTree_get'))

# Start of Config_printFlowTree_set

`Config_printFlowTree_set` = function(self, s_printFlowTree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printFlowTree = as.logical(s_printFlowTree);
  ;.Call('R_swig_Config_printFlowTree_set', self, s_printFlowTree, PACKAGE='infomap');
  
}

attr(`Config_printFlowTree_set`, 'returnType') = 'void'
attr(`Config_printFlowTree_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printFlowTree_set`) = c("SWIGFunction", class('Config_printFlowTree_set'))

# Start of Config_printFlowTree_get

`Config_printFlowTree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printFlowTree_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printFlowTree_get`, 'returnType') = 'logical'
attr(`Config_printFlowTree_get`, "inputTypes") = c('_p_Config')
class(`Config_printFlowTree_get`) = c("SWIGFunction", class('Config_printFlowTree_get'))

# Start of Config_printMap_set

`Config_printMap_set` = function(self, s_printMap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printMap = as.logical(s_printMap);
  ;.Call('R_swig_Config_printMap_set', self, s_printMap, PACKAGE='infomap');
  
}

attr(`Config_printMap_set`, 'returnType') = 'void'
attr(`Config_printMap_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printMap_set`) = c("SWIGFunction", class('Config_printMap_set'))

# Start of Config_printMap_get

`Config_printMap_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printMap_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printMap_get`, 'returnType') = 'logical'
attr(`Config_printMap_get`, "inputTypes") = c('_p_Config')
class(`Config_printMap_get`) = c("SWIGFunction", class('Config_printMap_get'))

# Start of Config_printClu_set

`Config_printClu_set` = function(self, s_printClu)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printClu = as.logical(s_printClu);
  ;.Call('R_swig_Config_printClu_set', self, s_printClu, PACKAGE='infomap');
  
}

attr(`Config_printClu_set`, 'returnType') = 'void'
attr(`Config_printClu_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printClu_set`) = c("SWIGFunction", class('Config_printClu_set'))

# Start of Config_printClu_get

`Config_printClu_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printClu_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printClu_get`, 'returnType') = 'logical'
attr(`Config_printClu_get`, "inputTypes") = c('_p_Config')
class(`Config_printClu_get`) = c("SWIGFunction", class('Config_printClu_get'))

# Start of Config_printNodeRanks_set

`Config_printNodeRanks_set` = function(self, s_printNodeRanks)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printNodeRanks = as.logical(s_printNodeRanks);
  ;.Call('R_swig_Config_printNodeRanks_set', self, s_printNodeRanks, PACKAGE='infomap');
  
}

attr(`Config_printNodeRanks_set`, 'returnType') = 'void'
attr(`Config_printNodeRanks_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printNodeRanks_set`) = c("SWIGFunction", class('Config_printNodeRanks_set'))

# Start of Config_printNodeRanks_get

`Config_printNodeRanks_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printNodeRanks_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printNodeRanks_get`, 'returnType') = 'logical'
attr(`Config_printNodeRanks_get`, "inputTypes") = c('_p_Config')
class(`Config_printNodeRanks_get`) = c("SWIGFunction", class('Config_printNodeRanks_get'))

# Start of Config_printFlowNetwork_set

`Config_printFlowNetwork_set` = function(self, s_printFlowNetwork)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printFlowNetwork = as.logical(s_printFlowNetwork);
  ;.Call('R_swig_Config_printFlowNetwork_set', self, s_printFlowNetwork, PACKAGE='infomap');
  
}

attr(`Config_printFlowNetwork_set`, 'returnType') = 'void'
attr(`Config_printFlowNetwork_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printFlowNetwork_set`) = c("SWIGFunction", class('Config_printFlowNetwork_set'))

# Start of Config_printFlowNetwork_get

`Config_printFlowNetwork_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printFlowNetwork_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printFlowNetwork_get`, 'returnType') = 'logical'
attr(`Config_printFlowNetwork_get`, "inputTypes") = c('_p_Config')
class(`Config_printFlowNetwork_get`) = c("SWIGFunction", class('Config_printFlowNetwork_get'))

# Start of Config_printPajekNetwork_set

`Config_printPajekNetwork_set` = function(self, s_printPajekNetwork)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printPajekNetwork = as.logical(s_printPajekNetwork);
  ;.Call('R_swig_Config_printPajekNetwork_set', self, s_printPajekNetwork, PACKAGE='infomap');
  
}

attr(`Config_printPajekNetwork_set`, 'returnType') = 'void'
attr(`Config_printPajekNetwork_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printPajekNetwork_set`) = c("SWIGFunction", class('Config_printPajekNetwork_set'))

# Start of Config_printPajekNetwork_get

`Config_printPajekNetwork_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printPajekNetwork_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printPajekNetwork_get`, 'returnType') = 'logical'
attr(`Config_printPajekNetwork_get`, "inputTypes") = c('_p_Config')
class(`Config_printPajekNetwork_get`) = c("SWIGFunction", class('Config_printPajekNetwork_get'))

# Start of Config_printStateNetwork_set

`Config_printStateNetwork_set` = function(self, s_printStateNetwork)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printStateNetwork = as.logical(s_printStateNetwork);
  ;.Call('R_swig_Config_printStateNetwork_set', self, s_printStateNetwork, PACKAGE='infomap');
  
}

attr(`Config_printStateNetwork_set`, 'returnType') = 'void'
attr(`Config_printStateNetwork_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printStateNetwork_set`) = c("SWIGFunction", class('Config_printStateNetwork_set'))

# Start of Config_printStateNetwork_get

`Config_printStateNetwork_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printStateNetwork_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printStateNetwork_get`, 'returnType') = 'logical'
attr(`Config_printStateNetwork_get`, "inputTypes") = c('_p_Config')
class(`Config_printStateNetwork_get`) = c("SWIGFunction", class('Config_printStateNetwork_get'))

# Start of Config_printBinaryTree_set

`Config_printBinaryTree_set` = function(self, s_printBinaryTree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printBinaryTree = as.logical(s_printBinaryTree);
  ;.Call('R_swig_Config_printBinaryTree_set', self, s_printBinaryTree, PACKAGE='infomap');
  
}

attr(`Config_printBinaryTree_set`, 'returnType') = 'void'
attr(`Config_printBinaryTree_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printBinaryTree_set`) = c("SWIGFunction", class('Config_printBinaryTree_set'))

# Start of Config_printBinaryTree_get

`Config_printBinaryTree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printBinaryTree_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printBinaryTree_get`, 'returnType') = 'logical'
attr(`Config_printBinaryTree_get`, "inputTypes") = c('_p_Config')
class(`Config_printBinaryTree_get`) = c("SWIGFunction", class('Config_printBinaryTree_get'))

# Start of Config_printBinaryFlowTree_set

`Config_printBinaryFlowTree_set` = function(self, s_printBinaryFlowTree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printBinaryFlowTree = as.logical(s_printBinaryFlowTree);
  ;.Call('R_swig_Config_printBinaryFlowTree_set', self, s_printBinaryFlowTree, PACKAGE='infomap');
  
}

attr(`Config_printBinaryFlowTree_set`, 'returnType') = 'void'
attr(`Config_printBinaryFlowTree_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printBinaryFlowTree_set`) = c("SWIGFunction", class('Config_printBinaryFlowTree_set'))

# Start of Config_printBinaryFlowTree_get

`Config_printBinaryFlowTree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printBinaryFlowTree_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printBinaryFlowTree_get`, 'returnType') = 'logical'
attr(`Config_printBinaryFlowTree_get`, "inputTypes") = c('_p_Config')
class(`Config_printBinaryFlowTree_get`) = c("SWIGFunction", class('Config_printBinaryFlowTree_get'))

# Start of Config_printExpanded_set

`Config_printExpanded_set` = function(self, s_printExpanded)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_printExpanded = as.logical(s_printExpanded);
  ;.Call('R_swig_Config_printExpanded_set', self, s_printExpanded, PACKAGE='infomap');
  
}

attr(`Config_printExpanded_set`, 'returnType') = 'void'
attr(`Config_printExpanded_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_printExpanded_set`) = c("SWIGFunction", class('Config_printExpanded_set'))

# Start of Config_printExpanded_get

`Config_printExpanded_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_printExpanded_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printExpanded_get`, 'returnType') = 'logical'
attr(`Config_printExpanded_get`, "inputTypes") = c('_p_Config')
class(`Config_printExpanded_get`) = c("SWIGFunction", class('Config_printExpanded_get'))

# Start of Config_noFileOutput_set

`Config_noFileOutput_set` = function(self, s_noFileOutput)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_noFileOutput = as.logical(s_noFileOutput);
  ;.Call('R_swig_Config_noFileOutput_set', self, s_noFileOutput, PACKAGE='infomap');
  
}

attr(`Config_noFileOutput_set`, 'returnType') = 'void'
attr(`Config_noFileOutput_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_noFileOutput_set`) = c("SWIGFunction", class('Config_noFileOutput_set'))

# Start of Config_noFileOutput_get

`Config_noFileOutput_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_noFileOutput_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_noFileOutput_get`, 'returnType') = 'logical'
attr(`Config_noFileOutput_get`, "inputTypes") = c('_p_Config')
class(`Config_noFileOutput_get`) = c("SWIGFunction", class('Config_noFileOutput_get'))

# Start of Config_verbosity_set

`Config_verbosity_set` = function(self, s_verbosity)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_verbosity = as.integer(s_verbosity);
  
  if(length(s_verbosity) > 1) {
    warning("using only the first element of s_verbosity");
  };
  
  ;.Call('R_swig_Config_verbosity_set', self, s_verbosity, PACKAGE='infomap');
  
}

attr(`Config_verbosity_set`, 'returnType') = 'void'
attr(`Config_verbosity_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_verbosity_set`) = c("SWIGFunction", class('Config_verbosity_set'))

# Start of Config_verbosity_get

`Config_verbosity_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_verbosity_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_verbosity_get`, 'returnType') = 'integer'
attr(`Config_verbosity_get`, "inputTypes") = c('_p_Config')
class(`Config_verbosity_get`) = c("SWIGFunction", class('Config_verbosity_get'))

# Start of Config_verboseNumberPrecision_set

`Config_verboseNumberPrecision_set` = function(self, s_verboseNumberPrecision)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_verboseNumberPrecision = as.integer(s_verboseNumberPrecision);
  
  if(length(s_verboseNumberPrecision) > 1) {
    warning("using only the first element of s_verboseNumberPrecision");
  };
  
  ;.Call('R_swig_Config_verboseNumberPrecision_set', self, s_verboseNumberPrecision, PACKAGE='infomap');
  
}

attr(`Config_verboseNumberPrecision_set`, 'returnType') = 'void'
attr(`Config_verboseNumberPrecision_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_verboseNumberPrecision_set`) = c("SWIGFunction", class('Config_verboseNumberPrecision_set'))

# Start of Config_verboseNumberPrecision_get

`Config_verboseNumberPrecision_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_verboseNumberPrecision_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_verboseNumberPrecision_get`, 'returnType') = 'integer'
attr(`Config_verboseNumberPrecision_get`, "inputTypes") = c('_p_Config')
class(`Config_verboseNumberPrecision_get`) = c("SWIGFunction", class('Config_verboseNumberPrecision_get'))

# Start of Config_silent_set

`Config_silent_set` = function(self, s_silent)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_silent = as.logical(s_silent);
  ;.Call('R_swig_Config_silent_set', self, s_silent, PACKAGE='infomap');
  
}

attr(`Config_silent_set`, 'returnType') = 'void'
attr(`Config_silent_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_silent_set`) = c("SWIGFunction", class('Config_silent_set'))

# Start of Config_silent_get

`Config_silent_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_silent_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_silent_get`, 'returnType') = 'logical'
attr(`Config_silent_get`, "inputTypes") = c('_p_Config')
class(`Config_silent_get`) = c("SWIGFunction", class('Config_silent_get'))

# Start of Config_benchmark_set

`Config_benchmark_set` = function(self, s_benchmark)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_benchmark = as.logical(s_benchmark);
  ;.Call('R_swig_Config_benchmark_set', self, s_benchmark, PACKAGE='infomap');
  
}

attr(`Config_benchmark_set`, 'returnType') = 'void'
attr(`Config_benchmark_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_benchmark_set`) = c("SWIGFunction", class('Config_benchmark_set'))

# Start of Config_benchmark_get

`Config_benchmark_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_benchmark_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_benchmark_get`, 'returnType') = 'logical'
attr(`Config_benchmark_get`, "inputTypes") = c('_p_Config')
class(`Config_benchmark_get`) = c("SWIGFunction", class('Config_benchmark_get'))

# Start of Config_maxNodeIndexVisible_set

`Config_maxNodeIndexVisible_set` = function(self, s_maxNodeIndexVisible)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_maxNodeIndexVisible = as.integer(s_maxNodeIndexVisible);
  
  if(length(s_maxNodeIndexVisible) > 1) {
    warning("using only the first element of s_maxNodeIndexVisible");
  };
  
  ;.Call('R_swig_Config_maxNodeIndexVisible_set', self, s_maxNodeIndexVisible, PACKAGE='infomap');
  
}

attr(`Config_maxNodeIndexVisible_set`, 'returnType') = 'void'
attr(`Config_maxNodeIndexVisible_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_maxNodeIndexVisible_set`) = c("SWIGFunction", class('Config_maxNodeIndexVisible_set'))

# Start of Config_maxNodeIndexVisible_get

`Config_maxNodeIndexVisible_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_maxNodeIndexVisible_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_maxNodeIndexVisible_get`, 'returnType') = 'integer'
attr(`Config_maxNodeIndexVisible_get`, "inputTypes") = c('_p_Config')
class(`Config_maxNodeIndexVisible_get`) = c("SWIGFunction", class('Config_maxNodeIndexVisible_get'))

# Start of Config_showBiNodes_set

`Config_showBiNodes_set` = function(self, s_showBiNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_showBiNodes = as.logical(s_showBiNodes);
  ;.Call('R_swig_Config_showBiNodes_set', self, s_showBiNodes, PACKAGE='infomap');
  
}

attr(`Config_showBiNodes_set`, 'returnType') = 'void'
attr(`Config_showBiNodes_set`, "inputTypes") = c('_p_Config', 'logical')
class(`Config_showBiNodes_set`) = c("SWIGFunction", class('Config_showBiNodes_set'))

# Start of Config_showBiNodes_get

`Config_showBiNodes_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_showBiNodes_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_showBiNodes_get`, 'returnType') = 'logical'
attr(`Config_showBiNodes_get`, "inputTypes") = c('_p_Config')
class(`Config_showBiNodes_get`) = c("SWIGFunction", class('Config_showBiNodes_get'))

# Start of Config_minBipartiteNodeIndex_set

`Config_minBipartiteNodeIndex_set` = function(self, s_minBipartiteNodeIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_minBipartiteNodeIndex = as.integer(s_minBipartiteNodeIndex);
  
  if(length(s_minBipartiteNodeIndex) > 1) {
    warning("using only the first element of s_minBipartiteNodeIndex");
  };
  
  ;.Call('R_swig_Config_minBipartiteNodeIndex_set', self, s_minBipartiteNodeIndex, PACKAGE='infomap');
  
}

attr(`Config_minBipartiteNodeIndex_set`, 'returnType') = 'void'
attr(`Config_minBipartiteNodeIndex_set`, "inputTypes") = c('_p_Config', 'integer')
class(`Config_minBipartiteNodeIndex_set`) = c("SWIGFunction", class('Config_minBipartiteNodeIndex_set'))

# Start of Config_minBipartiteNodeIndex_get

`Config_minBipartiteNodeIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_minBipartiteNodeIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_minBipartiteNodeIndex_get`, 'returnType') = 'integer'
attr(`Config_minBipartiteNodeIndex_get`, "inputTypes") = c('_p_Config')
class(`Config_minBipartiteNodeIndex_get`) = c("SWIGFunction", class('Config_minBipartiteNodeIndex_get'))

# Start of Config_startDate_set

`Config_startDate_set` = function(self, s_startDate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_startDate, "ExternalReference")) s_startDate = slot(s_startDate,"ref") 
  ;.Call('R_swig_Config_startDate_set', self, s_startDate, PACKAGE='infomap');
  
}

attr(`Config_startDate_set`, 'returnType') = 'void'
attr(`Config_startDate_set`, "inputTypes") = c('_p_Config', '_p_Date')
class(`Config_startDate_set`) = c("SWIGFunction", class('Config_startDate_set'))

# Start of Config_startDate_get

`Config_startDate_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Config_startDate_get', self, PACKAGE='infomap');
  ans <- new("_p_Date", ref=ans) ;
  
  ans
  
}

attr(`Config_startDate_get`, 'returnType') = '_p_Date'
attr(`Config_startDate_get`, "inputTypes") = c('_p_Config')
class(`Config_startDate_get`) = c("SWIGFunction", class('Config_startDate_get'))

# Start of Config_version_set

`Config_version_set` = function(self, s_version)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_version = as(s_version, "character"); 
  ;.Call('R_swig_Config_version_set', self, s_version, PACKAGE='infomap');
  
}

attr(`Config_version_set`, 'returnType') = 'void'
attr(`Config_version_set`, "inputTypes") = c('_p_Config', 'character')
class(`Config_version_set`) = c("SWIGFunction", class('Config_version_set'))

# Start of Config_version_get

`Config_version_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Config_version_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_version_get`, 'returnType') = 'character'
attr(`Config_version_get`, "inputTypes") = c('_p_Config')
class(`Config_version_get`) = c("SWIGFunction", class('Config_version_get'))

# Start of delete_Config

`delete_Config` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Config', self, PACKAGE='infomap');
  
}

attr(`delete_Config`, 'returnType') = 'void'
attr(`delete_Config`, "inputTypes") = c('_p_Config')
class(`delete_Config`) = c("SWIGFunction", class('delete_Config'))

# Start of accessor method for Config
setMethod('$', '_p_Config', function(x, name)

{
  accessorFuns = list('Equal' = Config_Equal, 'setOptimizationLevel' = Config_setOptimizationLevel, 'adaptDefaults' = Config_adaptDefaults, 'reset' = Config_reset, 'isUndirected' = Config_isUndirected, 'setUndirected' = Config_setUndirected, 'isUndirectedFlow' = Config_isUndirectedFlow, 'printAsUndirected' = Config_printAsUndirected, 'parseAsUndirected' = Config_parseAsUndirected, 'useTeleportation' = Config_useTeleportation, 'isMemoryInput' = Config_isMemoryInput, 'isMemoryNetwork' = Config_isMemoryNetwork, 'isSimulatedMemoryNetwork' = Config_isSimulatedMemoryNetwork, 'isMultiplexNetwork' = Config_isMultiplexNetwork, 'isBipartite' = Config_isBipartite, 'isStateNetwork' = Config_isStateNetwork, 'haveOutput' = Config_haveOutput, 'haveModularResultOutput' = Config_haveModularResultOutput, 'elapsedTime' = Config_elapsedTime, 'parsedArgs' = Config_parsedArgs_get, 'networkFile' = Config_networkFile_get, 'additionalInput' = Config_additionalInput_get, 'inputFormat' = Config_inputFormat_get, 'withMemory' = Config_withMemory_get, 'bipartite' = Config_bipartite_get, 'skipAdjustBipartiteFlow' = Config_skipAdjustBipartiteFlow_get, 'multiplexAddMissingNodes' = Config_multiplexAddMissingNodes_get, 'hardPartitions' = Config_hardPartitions_get, 'nonBacktracking' = Config_nonBacktracking_get, 'parseWithoutIOStreams' = Config_parseWithoutIOStreams_get, 'zeroBasedNodeNumbers' = Config_zeroBasedNodeNumbers_get, 'includeSelfLinks' = Config_includeSelfLinks_get, 'ignoreEdgeWeights' = Config_ignoreEdgeWeights_get, 'completeDanglingMemoryNodes' = Config_completeDanglingMemoryNodes_get, 'nodeLimit' = Config_nodeLimit_get, 'preClusterMultiplex' = Config_preClusterMultiplex_get, 'clusterDataFile' = Config_clusterDataFile_get, 'noInfomap' = Config_noInfomap_get, 'twoLevel' = Config_twoLevel_get, 'directed' = Config_directed_get, 'undirdir' = Config_undirdir_get, 'outdirdir' = Config_outdirdir_get, 'rawdir' = Config_rawdir_get, 'recordedTeleportation' = Config_recordedTeleportation_get, 'teleportToNodes' = Config_teleportToNodes_get, 'teleportationProbability' = Config_teleportationProbability_get, 'selfTeleportationProbability' = Config_selfTeleportationProbability_get, 'markovTime' = Config_markovTime_get, 'variableMarkovTime' = Config_variableMarkovTime_get, 'preferredNumberOfModules' = Config_preferredNumberOfModules_get, 'multiplexRelaxRate' = Config_multiplexRelaxRate_get, 'multiplexJSRelaxRate' = Config_multiplexJSRelaxRate_get, 'multiplexJSRelaxLimit' = Config_multiplexJSRelaxLimit_get, 'multiplexRelaxLimit' = Config_multiplexRelaxLimit_get, 'seedToRandomNumberGenerator' = Config_seedToRandomNumberGenerator_get, 'numTrials' = Config_numTrials_get, 'minimumCodelengthImprovement' = Config_minimumCodelengthImprovement_get, 'minimumSingleNodeCodelengthImprovement' = Config_minimumSingleNodeCodelengthImprovement_get, 'randomizeCoreLoopLimit' = Config_randomizeCoreLoopLimit_get, 'coreLoopLimit' = Config_coreLoopLimit_get, 'levelAggregationLimit' = Config_levelAggregationLimit_get, 'tuneIterationLimit' = Config_tuneIterationLimit_get, 'minimumRelativeTuneIterationImprovement' = Config_minimumRelativeTuneIterationImprovement_get, 'fastCoarseTunePartition' = Config_fastCoarseTunePartition_get, 'alternateCoarseTuneLevel' = Config_alternateCoarseTuneLevel_get, 'coarseTuneLevel' = Config_coarseTuneLevel_get, 'fastHierarchicalSolution' = Config_fastHierarchicalSolution_get, 'fastFirstIteration' = Config_fastFirstIteration_get, 'lowMemoryPriority' = Config_lowMemoryPriority_get, 'innerParallelization' = Config_innerParallelization_get, 'resetConfigBeforeRecursion' = Config_resetConfigBeforeRecursion_get, 'outDirectory' = Config_outDirectory_get, 'outName' = Config_outName_get, 'originallyUndirected' = Config_originallyUndirected_get, 'printTree' = Config_printTree_get, 'printFlowTree' = Config_printFlowTree_get, 'printMap' = Config_printMap_get, 'printClu' = Config_printClu_get, 'printNodeRanks' = Config_printNodeRanks_get, 'printFlowNetwork' = Config_printFlowNetwork_get, 'printPajekNetwork' = Config_printPajekNetwork_get, 'printStateNetwork' = Config_printStateNetwork_get, 'printBinaryTree' = Config_printBinaryTree_get, 'printBinaryFlowTree' = Config_printBinaryFlowTree_get, 'printExpanded' = Config_printExpanded_get, 'noFileOutput' = Config_noFileOutput_get, 'verbosity' = Config_verbosity_get, 'verboseNumberPrecision' = Config_verboseNumberPrecision_get, 'silent' = Config_silent_get, 'benchmark' = Config_benchmark_get, 'maxNodeIndexVisible' = Config_maxNodeIndexVisible_get, 'showBiNodes' = Config_showBiNodes_get, 'minBipartiteNodeIndex' = Config_minBipartiteNodeIndex_get, 'startDate' = Config_startDate_get, 'version' = Config_version_get);
  vaccessors = c('parsedArgs', 'networkFile', 'additionalInput', 'inputFormat', 'withMemory', 'bipartite', 'skipAdjustBipartiteFlow', 'multiplexAddMissingNodes', 'hardPartitions', 'nonBacktracking', 'parseWithoutIOStreams', 'zeroBasedNodeNumbers', 'includeSelfLinks', 'ignoreEdgeWeights', 'completeDanglingMemoryNodes', 'nodeLimit', 'preClusterMultiplex', 'clusterDataFile', 'noInfomap', 'twoLevel', 'directed', 'undirdir', 'outdirdir', 'rawdir', 'recordedTeleportation', 'teleportToNodes', 'teleportationProbability', 'selfTeleportationProbability', 'markovTime', 'variableMarkovTime', 'preferredNumberOfModules', 'multiplexRelaxRate', 'multiplexJSRelaxRate', 'multiplexJSRelaxLimit', 'multiplexRelaxLimit', 'seedToRandomNumberGenerator', 'numTrials', 'minimumCodelengthImprovement', 'minimumSingleNodeCodelengthImprovement', 'randomizeCoreLoopLimit', 'coreLoopLimit', 'levelAggregationLimit', 'tuneIterationLimit', 'minimumRelativeTuneIterationImprovement', 'fastCoarseTunePartition', 'alternateCoarseTuneLevel', 'coarseTuneLevel', 'fastHierarchicalSolution', 'fastFirstIteration', 'lowMemoryPriority', 'innerParallelization', 'resetConfigBeforeRecursion', 'outDirectory', 'outName', 'originallyUndirected', 'printTree', 'printFlowTree', 'printMap', 'printClu', 'printNodeRanks', 'printFlowNetwork', 'printPajekNetwork', 'printStateNetwork', 'printBinaryTree', 'printBinaryFlowTree', 'printExpanded', 'noFileOutput', 'verbosity', 'verboseNumberPrecision', 'silent', 'benchmark', 'maxNodeIndexVisible', 'showBiNodes', 'minBipartiteNodeIndex', 'startDate', 'version');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Config
# Start of accessor method for Config
setMethod('$<-', '_p_Config', function(x, name, value)

{
  accessorFuns = list('parsedArgs' = Config_parsedArgs_set, 'networkFile' = Config_networkFile_set, 'additionalInput' = Config_additionalInput_set, 'inputFormat' = Config_inputFormat_set, 'withMemory' = Config_withMemory_set, 'bipartite' = Config_bipartite_set, 'skipAdjustBipartiteFlow' = Config_skipAdjustBipartiteFlow_set, 'multiplexAddMissingNodes' = Config_multiplexAddMissingNodes_set, 'hardPartitions' = Config_hardPartitions_set, 'nonBacktracking' = Config_nonBacktracking_set, 'parseWithoutIOStreams' = Config_parseWithoutIOStreams_set, 'zeroBasedNodeNumbers' = Config_zeroBasedNodeNumbers_set, 'includeSelfLinks' = Config_includeSelfLinks_set, 'ignoreEdgeWeights' = Config_ignoreEdgeWeights_set, 'completeDanglingMemoryNodes' = Config_completeDanglingMemoryNodes_set, 'nodeLimit' = Config_nodeLimit_set, 'preClusterMultiplex' = Config_preClusterMultiplex_set, 'clusterDataFile' = Config_clusterDataFile_set, 'noInfomap' = Config_noInfomap_set, 'twoLevel' = Config_twoLevel_set, 'directed' = Config_directed_set, 'undirdir' = Config_undirdir_set, 'outdirdir' = Config_outdirdir_set, 'rawdir' = Config_rawdir_set, 'recordedTeleportation' = Config_recordedTeleportation_set, 'teleportToNodes' = Config_teleportToNodes_set, 'teleportationProbability' = Config_teleportationProbability_set, 'selfTeleportationProbability' = Config_selfTeleportationProbability_set, 'markovTime' = Config_markovTime_set, 'variableMarkovTime' = Config_variableMarkovTime_set, 'preferredNumberOfModules' = Config_preferredNumberOfModules_set, 'multiplexRelaxRate' = Config_multiplexRelaxRate_set, 'multiplexJSRelaxRate' = Config_multiplexJSRelaxRate_set, 'multiplexJSRelaxLimit' = Config_multiplexJSRelaxLimit_set, 'multiplexRelaxLimit' = Config_multiplexRelaxLimit_set, 'seedToRandomNumberGenerator' = Config_seedToRandomNumberGenerator_set, 'numTrials' = Config_numTrials_set, 'minimumCodelengthImprovement' = Config_minimumCodelengthImprovement_set, 'minimumSingleNodeCodelengthImprovement' = Config_minimumSingleNodeCodelengthImprovement_set, 'randomizeCoreLoopLimit' = Config_randomizeCoreLoopLimit_set, 'coreLoopLimit' = Config_coreLoopLimit_set, 'levelAggregationLimit' = Config_levelAggregationLimit_set, 'tuneIterationLimit' = Config_tuneIterationLimit_set, 'minimumRelativeTuneIterationImprovement' = Config_minimumRelativeTuneIterationImprovement_set, 'fastCoarseTunePartition' = Config_fastCoarseTunePartition_set, 'alternateCoarseTuneLevel' = Config_alternateCoarseTuneLevel_set, 'coarseTuneLevel' = Config_coarseTuneLevel_set, 'fastHierarchicalSolution' = Config_fastHierarchicalSolution_set, 'fastFirstIteration' = Config_fastFirstIteration_set, 'lowMemoryPriority' = Config_lowMemoryPriority_set, 'innerParallelization' = Config_innerParallelization_set, 'resetConfigBeforeRecursion' = Config_resetConfigBeforeRecursion_set, 'outDirectory' = Config_outDirectory_set, 'outName' = Config_outName_set, 'originallyUndirected' = Config_originallyUndirected_set, 'printTree' = Config_printTree_set, 'printFlowTree' = Config_printFlowTree_set, 'printMap' = Config_printMap_set, 'printClu' = Config_printClu_set, 'printNodeRanks' = Config_printNodeRanks_set, 'printFlowNetwork' = Config_printFlowNetwork_set, 'printPajekNetwork' = Config_printPajekNetwork_set, 'printStateNetwork' = Config_printStateNetwork_set, 'printBinaryTree' = Config_printBinaryTree_set, 'printBinaryFlowTree' = Config_printBinaryFlowTree_set, 'printExpanded' = Config_printExpanded_set, 'noFileOutput' = Config_noFileOutput_set, 'verbosity' = Config_verbosity_set, 'verboseNumberPrecision' = Config_verboseNumberPrecision_set, 'silent' = Config_silent_set, 'benchmark' = Config_benchmark_set, 'maxNodeIndexVisible' = Config_maxNodeIndexVisible_set, 'showBiNodes' = Config_showBiNodes_set, 'minBipartiteNodeIndex' = Config_minBipartiteNodeIndex_set, 'startDate' = Config_startDate_set, 'version' = Config_version_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Config', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('parsedArgs' = Config_parsedArgs_set, 'networkFile' = Config_networkFile_set, 'additionalInput' = Config_additionalInput_set, 'inputFormat' = Config_inputFormat_set, 'withMemory' = Config_withMemory_set, 'bipartite' = Config_bipartite_set, 'skipAdjustBipartiteFlow' = Config_skipAdjustBipartiteFlow_set, 'multiplexAddMissingNodes' = Config_multiplexAddMissingNodes_set, 'hardPartitions' = Config_hardPartitions_set, 'nonBacktracking' = Config_nonBacktracking_set, 'parseWithoutIOStreams' = Config_parseWithoutIOStreams_set, 'zeroBasedNodeNumbers' = Config_zeroBasedNodeNumbers_set, 'includeSelfLinks' = Config_includeSelfLinks_set, 'ignoreEdgeWeights' = Config_ignoreEdgeWeights_set, 'completeDanglingMemoryNodes' = Config_completeDanglingMemoryNodes_set, 'nodeLimit' = Config_nodeLimit_set, 'preClusterMultiplex' = Config_preClusterMultiplex_set, 'clusterDataFile' = Config_clusterDataFile_set, 'noInfomap' = Config_noInfomap_set, 'twoLevel' = Config_twoLevel_set, 'directed' = Config_directed_set, 'undirdir' = Config_undirdir_set, 'outdirdir' = Config_outdirdir_set, 'rawdir' = Config_rawdir_set, 'recordedTeleportation' = Config_recordedTeleportation_set, 'teleportToNodes' = Config_teleportToNodes_set, 'teleportationProbability' = Config_teleportationProbability_set, 'selfTeleportationProbability' = Config_selfTeleportationProbability_set, 'markovTime' = Config_markovTime_set, 'variableMarkovTime' = Config_variableMarkovTime_set, 'preferredNumberOfModules' = Config_preferredNumberOfModules_set, 'multiplexRelaxRate' = Config_multiplexRelaxRate_set, 'multiplexJSRelaxRate' = Config_multiplexJSRelaxRate_set, 'multiplexJSRelaxLimit' = Config_multiplexJSRelaxLimit_set, 'multiplexRelaxLimit' = Config_multiplexRelaxLimit_set, 'seedToRandomNumberGenerator' = Config_seedToRandomNumberGenerator_set, 'numTrials' = Config_numTrials_set, 'minimumCodelengthImprovement' = Config_minimumCodelengthImprovement_set, 'minimumSingleNodeCodelengthImprovement' = Config_minimumSingleNodeCodelengthImprovement_set, 'randomizeCoreLoopLimit' = Config_randomizeCoreLoopLimit_set, 'coreLoopLimit' = Config_coreLoopLimit_set, 'levelAggregationLimit' = Config_levelAggregationLimit_set, 'tuneIterationLimit' = Config_tuneIterationLimit_set, 'minimumRelativeTuneIterationImprovement' = Config_minimumRelativeTuneIterationImprovement_set, 'fastCoarseTunePartition' = Config_fastCoarseTunePartition_set, 'alternateCoarseTuneLevel' = Config_alternateCoarseTuneLevel_set, 'coarseTuneLevel' = Config_coarseTuneLevel_set, 'fastHierarchicalSolution' = Config_fastHierarchicalSolution_set, 'fastFirstIteration' = Config_fastFirstIteration_set, 'lowMemoryPriority' = Config_lowMemoryPriority_set, 'innerParallelization' = Config_innerParallelization_set, 'resetConfigBeforeRecursion' = Config_resetConfigBeforeRecursion_set, 'outDirectory' = Config_outDirectory_set, 'outName' = Config_outName_set, 'originallyUndirected' = Config_originallyUndirected_set, 'printTree' = Config_printTree_set, 'printFlowTree' = Config_printFlowTree_set, 'printMap' = Config_printMap_set, 'printClu' = Config_printClu_set, 'printNodeRanks' = Config_printNodeRanks_set, 'printFlowNetwork' = Config_printFlowNetwork_set, 'printPajekNetwork' = Config_printPajekNetwork_set, 'printStateNetwork' = Config_printStateNetwork_set, 'printBinaryTree' = Config_printBinaryTree_set, 'printBinaryFlowTree' = Config_printBinaryFlowTree_set, 'printExpanded' = Config_printExpanded_set, 'noFileOutput' = Config_noFileOutput_set, 'verbosity' = Config_verbosity_set, 'verboseNumberPrecision' = Config_verboseNumberPrecision_set, 'silent' = Config_silent_set, 'benchmark' = Config_benchmark_set, 'maxNodeIndexVisible' = Config_maxNodeIndexVisible_set, 'showBiNodes' = Config_showBiNodes_set, 'minBipartiteNodeIndex' = Config_minBipartiteNodeIndex_set, 'startDate' = Config_startDate_set, 'version' = Config_version_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Config
setMethod('delete', '_p_Config', function(obj) {delete_Config(obj)})
# Start definition of copy functions & methods for Config
CopyToR_Config = function(value, obj = new("Config"))
{
  obj@parsedArgs = value$parsedArgs;
  obj@networkFile = value$networkFile;
  obj@additionalInput = value$additionalInput;
  obj@inputFormat = value$inputFormat;
  obj@withMemory = value$withMemory;
  obj@bipartite = value$bipartite;
  obj@skipAdjustBipartiteFlow = value$skipAdjustBipartiteFlow;
  obj@multiplexAddMissingNodes = value$multiplexAddMissingNodes;
  obj@hardPartitions = value$hardPartitions;
  obj@nonBacktracking = value$nonBacktracking;
  obj@parseWithoutIOStreams = value$parseWithoutIOStreams;
  obj@zeroBasedNodeNumbers = value$zeroBasedNodeNumbers;
  obj@includeSelfLinks = value$includeSelfLinks;
  obj@ignoreEdgeWeights = value$ignoreEdgeWeights;
  obj@completeDanglingMemoryNodes = value$completeDanglingMemoryNodes;
  obj@nodeLimit = value$nodeLimit;
  obj@preClusterMultiplex = value$preClusterMultiplex;
  obj@clusterDataFile = value$clusterDataFile;
  obj@noInfomap = value$noInfomap;
  obj@twoLevel = value$twoLevel;
  obj@directed = value$directed;
  obj@undirdir = value$undirdir;
  obj@outdirdir = value$outdirdir;
  obj@rawdir = value$rawdir;
  obj@recordedTeleportation = value$recordedTeleportation;
  obj@teleportToNodes = value$teleportToNodes;
  obj@teleportationProbability = value$teleportationProbability;
  obj@selfTeleportationProbability = value$selfTeleportationProbability;
  obj@markovTime = value$markovTime;
  obj@variableMarkovTime = value$variableMarkovTime;
  obj@preferredNumberOfModules = value$preferredNumberOfModules;
  obj@multiplexRelaxRate = value$multiplexRelaxRate;
  obj@multiplexJSRelaxRate = value$multiplexJSRelaxRate;
  obj@multiplexJSRelaxLimit = value$multiplexJSRelaxLimit;
  obj@multiplexRelaxLimit = value$multiplexRelaxLimit;
  obj@seedToRandomNumberGenerator = value$seedToRandomNumberGenerator;
  obj@numTrials = value$numTrials;
  obj@minimumCodelengthImprovement = value$minimumCodelengthImprovement;
  obj@minimumSingleNodeCodelengthImprovement = value$minimumSingleNodeCodelengthImprovement;
  obj@randomizeCoreLoopLimit = value$randomizeCoreLoopLimit;
  obj@coreLoopLimit = value$coreLoopLimit;
  obj@levelAggregationLimit = value$levelAggregationLimit;
  obj@tuneIterationLimit = value$tuneIterationLimit;
  obj@minimumRelativeTuneIterationImprovement = value$minimumRelativeTuneIterationImprovement;
  obj@fastCoarseTunePartition = value$fastCoarseTunePartition;
  obj@alternateCoarseTuneLevel = value$alternateCoarseTuneLevel;
  obj@coarseTuneLevel = value$coarseTuneLevel;
  obj@fastHierarchicalSolution = value$fastHierarchicalSolution;
  obj@fastFirstIteration = value$fastFirstIteration;
  obj@lowMemoryPriority = value$lowMemoryPriority;
  obj@innerParallelization = value$innerParallelization;
  obj@resetConfigBeforeRecursion = value$resetConfigBeforeRecursion;
  obj@outDirectory = value$outDirectory;
  obj@outName = value$outName;
  obj@originallyUndirected = value$originallyUndirected;
  obj@printTree = value$printTree;
  obj@printFlowTree = value$printFlowTree;
  obj@printMap = value$printMap;
  obj@printClu = value$printClu;
  obj@printNodeRanks = value$printNodeRanks;
  obj@printFlowNetwork = value$printFlowNetwork;
  obj@printPajekNetwork = value$printPajekNetwork;
  obj@printStateNetwork = value$printStateNetwork;
  obj@printBinaryTree = value$printBinaryTree;
  obj@printBinaryFlowTree = value$printBinaryFlowTree;
  obj@printExpanded = value$printExpanded;
  obj@noFileOutput = value$noFileOutput;
  obj@verbosity = value$verbosity;
  obj@verboseNumberPrecision = value$verboseNumberPrecision;
  obj@silent = value$silent;
  obj@benchmark = value$benchmark;
  obj@maxNodeIndexVisible = value$maxNodeIndexVisible;
  obj@showBiNodes = value$showBiNodes;
  obj@minBipartiteNodeIndex = value$minBipartiteNodeIndex;
  obj@version = value$version;
  obj;
}



CopyToC_Config = function(value, obj)
{
  obj$parsedArgs = value@parsedArgs;
  obj$networkFile = value@networkFile;
  obj$additionalInput = value@additionalInput;
  obj$inputFormat = value@inputFormat;
  obj$withMemory = value@withMemory;
  obj$bipartite = value@bipartite;
  obj$skipAdjustBipartiteFlow = value@skipAdjustBipartiteFlow;
  obj$multiplexAddMissingNodes = value@multiplexAddMissingNodes;
  obj$hardPartitions = value@hardPartitions;
  obj$nonBacktracking = value@nonBacktracking;
  obj$parseWithoutIOStreams = value@parseWithoutIOStreams;
  obj$zeroBasedNodeNumbers = value@zeroBasedNodeNumbers;
  obj$includeSelfLinks = value@includeSelfLinks;
  obj$ignoreEdgeWeights = value@ignoreEdgeWeights;
  obj$completeDanglingMemoryNodes = value@completeDanglingMemoryNodes;
  obj$nodeLimit = value@nodeLimit;
  obj$preClusterMultiplex = value@preClusterMultiplex;
  obj$clusterDataFile = value@clusterDataFile;
  obj$noInfomap = value@noInfomap;
  obj$twoLevel = value@twoLevel;
  obj$directed = value@directed;
  obj$undirdir = value@undirdir;
  obj$outdirdir = value@outdirdir;
  obj$rawdir = value@rawdir;
  obj$recordedTeleportation = value@recordedTeleportation;
  obj$teleportToNodes = value@teleportToNodes;
  obj$teleportationProbability = value@teleportationProbability;
  obj$selfTeleportationProbability = value@selfTeleportationProbability;
  obj$markovTime = value@markovTime;
  obj$variableMarkovTime = value@variableMarkovTime;
  obj$preferredNumberOfModules = value@preferredNumberOfModules;
  obj$multiplexRelaxRate = value@multiplexRelaxRate;
  obj$multiplexJSRelaxRate = value@multiplexJSRelaxRate;
  obj$multiplexJSRelaxLimit = value@multiplexJSRelaxLimit;
  obj$multiplexRelaxLimit = value@multiplexRelaxLimit;
  obj$seedToRandomNumberGenerator = value@seedToRandomNumberGenerator;
  obj$numTrials = value@numTrials;
  obj$minimumCodelengthImprovement = value@minimumCodelengthImprovement;
  obj$minimumSingleNodeCodelengthImprovement = value@minimumSingleNodeCodelengthImprovement;
  obj$randomizeCoreLoopLimit = value@randomizeCoreLoopLimit;
  obj$coreLoopLimit = value@coreLoopLimit;
  obj$levelAggregationLimit = value@levelAggregationLimit;
  obj$tuneIterationLimit = value@tuneIterationLimit;
  obj$minimumRelativeTuneIterationImprovement = value@minimumRelativeTuneIterationImprovement;
  obj$fastCoarseTunePartition = value@fastCoarseTunePartition;
  obj$alternateCoarseTuneLevel = value@alternateCoarseTuneLevel;
  obj$coarseTuneLevel = value@coarseTuneLevel;
  obj$fastHierarchicalSolution = value@fastHierarchicalSolution;
  obj$fastFirstIteration = value@fastFirstIteration;
  obj$lowMemoryPriority = value@lowMemoryPriority;
  obj$innerParallelization = value@innerParallelization;
  obj$resetConfigBeforeRecursion = value@resetConfigBeforeRecursion;
  obj$outDirectory = value@outDirectory;
  obj$outName = value@outName;
  obj$originallyUndirected = value@originallyUndirected;
  obj$printTree = value@printTree;
  obj$printFlowTree = value@printFlowTree;
  obj$printMap = value@printMap;
  obj$printClu = value@printClu;
  obj$printNodeRanks = value@printNodeRanks;
  obj$printFlowNetwork = value@printFlowNetwork;
  obj$printPajekNetwork = value@printPajekNetwork;
  obj$printStateNetwork = value@printStateNetwork;
  obj$printBinaryTree = value@printBinaryTree;
  obj$printBinaryFlowTree = value@printBinaryFlowTree;
  obj$printExpanded = value@printExpanded;
  obj$noFileOutput = value@noFileOutput;
  obj$verbosity = value@verbosity;
  obj$verboseNumberPrecision = value@verboseNumberPrecision;
  obj$silent = value@silent;
  obj$benchmark = value@benchmark;
  obj$maxNodeIndexVisible = value@maxNodeIndexVisible;
  obj$showBiNodes = value@showBiNodes;
  obj$minBipartiteNodeIndex = value@minBipartiteNodeIndex;
  obj$version = value@version;
  obj
}



# Start definition of copy methods for Config
setMethod('copyToR', '_p_Config', CopyToR_Config);
setMethod('copyToC', 'Config', CopyToC_Config);

# End definition of copy methods for Config
# End definition of copy functions & methods for Config
# Start of new_Network

`Network__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Network__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_Network", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Network)
  ans
  
}

attr(`Network__SWIG_0`, 'returnType') = '_p_Network'
class(`Network__SWIG_0`) = c("SWIGFunction", class('Network__SWIG_0'))

# Start of new_Network

`Network__SWIG_1` = function(config)
{
  if (inherits(config, "ExternalReference")) config = slot(config,"ref") 
  ;ans = .Call('R_swig_new_Network__SWIG_1', config, PACKAGE='infomap');
  ans <- new("_p_Network", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Network)
  ans
  
}

attr(`Network__SWIG_1`, 'returnType') = '_p_Network'
attr(`Network__SWIG_1`, "inputTypes") = c('_p_Config')
class(`Network__SWIG_1`) = c("SWIGFunction", class('Network__SWIG_1'))

# Start of new_Network

`Network__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_Network__SWIG_2', other, PACKAGE='infomap');
  ans <- new("_p_Network", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Network)
  ans
  
}

attr(`Network__SWIG_2`, 'returnType') = '_p_Network'
attr(`Network__SWIG_2`, "inputTypes") = c('_p_Network')
class(`Network__SWIG_2`) = c("SWIGFunction", class('Network__SWIG_2'))

`Network` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- Network__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Config') && length(argv[[1]]) == 1) {
      f <- Network__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_Network') && length(argv[[1]]) == 1) {
      f <- Network__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for Network with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Network_Equal

`Network_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_Network_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_Network", ref=ans) ;
  
  ans
  
}

attr(`Network_Equal`, 'returnType') = '_p_Network'
attr(`Network_Equal`, "inputTypes") = c('_p_Network', '_p_Network')
class(`Network_Equal`) = c("SWIGFunction", class('Network_Equal'))

# Start of delete_Network

`delete_Network` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Network', self, PACKAGE='infomap');
  
}

attr(`delete_Network`, 'returnType') = 'void'
attr(`delete_Network`, "inputTypes") = c('_p_Network')
class(`delete_Network`) = c("SWIGFunction", class('delete_Network'))

# Start of Network_setConfig

`Network_setConfig` = function(self, config)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(config, "ExternalReference")) config = slot(config,"ref") 
  ;.Call('R_swig_Network_setConfig', self, config, PACKAGE='infomap');
  
}

attr(`Network_setConfig`, 'returnType') = 'void'
attr(`Network_setConfig`, "inputTypes") = c('_p_Network', '_p_Config')
class(`Network_setConfig`) = c("SWIGFunction", class('Network_setConfig'))

# Start of Network_readInputData

`Network_readInputData__SWIG_0` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_Network_readInputData__SWIG_0', self, filename, PACKAGE='infomap');
  
}

attr(`Network_readInputData__SWIG_0`, 'returnType') = 'void'
attr(`Network_readInputData__SWIG_0`, "inputTypes") = c('_p_Network', 'character')
class(`Network_readInputData__SWIG_0`) = c("SWIGFunction", class('Network_readInputData__SWIG_0'))

# Start of Network_readInputData

`Network_readInputData__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_readInputData__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`Network_readInputData__SWIG_1`, 'returnType') = 'void'
attr(`Network_readInputData__SWIG_1`, "inputTypes") = c('_p_Network')
class(`Network_readInputData__SWIG_1`) = c("SWIGFunction", class('Network_readInputData__SWIG_1'))

`Network_readInputData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Network')) {
      f <- Network_readInputData__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Network') && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- Network_readInputData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Network_readInputData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Network_addNodes

`Network_addNodes` = function(self, names, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(names, "ExternalReference")) names = slot(names,"ref") 
  ;.Call('R_swig_Network_addNodes', self, names, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_addNodes`, 'returnType') = 'integer'
attr(`Network_addNodes`, "inputTypes") = c('_p_Network', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`Network_addNodes`) = c("SWIGFunction", class('Network_addNodes'))

# Start of Network_addLink

`Network_addLink__SWIG_0` = function(self, n1, n2, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;.Call('R_swig_Network_addLink__SWIG_0', self, n1, n2, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_addLink__SWIG_0`, 'returnType') = 'logical'
attr(`Network_addLink__SWIG_0`, "inputTypes") = c('_p_Network', 'integer', 'integer', 'numeric')
class(`Network_addLink__SWIG_0`) = c("SWIGFunction", class('Network_addLink__SWIG_0'))

# Start of Network_addLink

`Network_addLink__SWIG_1` = function(self, n1, n2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  ;.Call('R_swig_Network_addLink__SWIG_1', self, n1, n2, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_addLink__SWIG_1`, 'returnType') = 'logical'
attr(`Network_addLink__SWIG_1`, "inputTypes") = c('_p_Network', 'integer', 'integer')
class(`Network_addLink__SWIG_1`) = c("SWIGFunction", class('Network_addLink__SWIG_1'))

`Network_addLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_Network') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- Network_addLink__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_Network') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- Network_addLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Network_addLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Network_addBipartiteLink

`Network_addBipartiteLink__SWIG_0` = function(self, featureNode, node, swapOrder, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  featureNode = as.integer(featureNode);
  
  if(length(featureNode) > 1) {
    warning("using only the first element of featureNode");
  };
  
  node = as.integer(node);
  
  if(length(node) > 1) {
    warning("using only the first element of node");
  };
  
  swapOrder = as.logical(swapOrder);
  
  ;.Call('R_swig_Network_addBipartiteLink__SWIG_0', self, featureNode, node, swapOrder, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_addBipartiteLink__SWIG_0`, 'returnType') = 'logical'
attr(`Network_addBipartiteLink__SWIG_0`, "inputTypes") = c('_p_Network', 'integer', 'integer', 'logical', 'numeric')
class(`Network_addBipartiteLink__SWIG_0`) = c("SWIGFunction", class('Network_addBipartiteLink__SWIG_0'))

# Start of Network_addBipartiteLink

`Network_addBipartiteLink__SWIG_1` = function(self, featureNode, node, swapOrder, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  featureNode = as.integer(featureNode);
  
  if(length(featureNode) > 1) {
    warning("using only the first element of featureNode");
  };
  
  node = as.integer(node);
  
  if(length(node) > 1) {
    warning("using only the first element of node");
  };
  
  swapOrder = as.logical(swapOrder);
  ;.Call('R_swig_Network_addBipartiteLink__SWIG_1', self, featureNode, node, swapOrder, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_addBipartiteLink__SWIG_1`, 'returnType') = 'logical'
attr(`Network_addBipartiteLink__SWIG_1`, "inputTypes") = c('_p_Network', 'integer', 'integer', 'logical')
class(`Network_addBipartiteLink__SWIG_1`) = c("SWIGFunction", class('Network_addBipartiteLink__SWIG_1'))

`Network_addBipartiteLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 4) {
    if (extends(argtypes[1], '_p_Network') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- Network_addBipartiteLink__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_Network') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- Network_addBipartiteLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Network_addBipartiteLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Network_finalizeAndCheckNetwork

`Network_finalizeAndCheckNetwork__SWIG_0` = function(self, printSummary, desiredNumberOfNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  printSummary = as.logical(printSummary);
  desiredNumberOfNodes = as.integer(desiredNumberOfNodes);
  
  if(length(desiredNumberOfNodes) > 1) {
    warning("using only the first element of desiredNumberOfNodes");
  };
  
  ;.Call('R_swig_Network_finalizeAndCheckNetwork__SWIG_0', self, printSummary, desiredNumberOfNodes, PACKAGE='infomap');
  
}

attr(`Network_finalizeAndCheckNetwork__SWIG_0`, 'returnType') = 'void'
attr(`Network_finalizeAndCheckNetwork__SWIG_0`, "inputTypes") = c('_p_Network', 'logical', 'integer')
class(`Network_finalizeAndCheckNetwork__SWIG_0`) = c("SWIGFunction", class('Network_finalizeAndCheckNetwork__SWIG_0'))

# Start of Network_finalizeAndCheckNetwork

`Network_finalizeAndCheckNetwork__SWIG_1` = function(self, printSummary)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  printSummary = as.logical(printSummary);
  ;.Call('R_swig_Network_finalizeAndCheckNetwork__SWIG_1', self, printSummary, PACKAGE='infomap');
  
}

attr(`Network_finalizeAndCheckNetwork__SWIG_1`, 'returnType') = 'void'
attr(`Network_finalizeAndCheckNetwork__SWIG_1`, "inputTypes") = c('_p_Network', 'logical')
class(`Network_finalizeAndCheckNetwork__SWIG_1`) = c("SWIGFunction", class('Network_finalizeAndCheckNetwork__SWIG_1'))

# Start of Network_finalizeAndCheckNetwork

`Network_finalizeAndCheckNetwork__SWIG_2` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_finalizeAndCheckNetwork__SWIG_2', self, PACKAGE='infomap');
  
}

attr(`Network_finalizeAndCheckNetwork__SWIG_2`, 'returnType') = 'void'
attr(`Network_finalizeAndCheckNetwork__SWIG_2`, "inputTypes") = c('_p_Network')
class(`Network_finalizeAndCheckNetwork__SWIG_2`) = c("SWIGFunction", class('Network_finalizeAndCheckNetwork__SWIG_2'))

`Network_finalizeAndCheckNetwork` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Network')) {
      f <- Network_finalizeAndCheckNetwork__SWIG_2; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Network') && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- Network_finalizeAndCheckNetwork__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_Network') && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- Network_finalizeAndCheckNetwork__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Network_finalizeAndCheckNetwork with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Network_printParsingResult

`Network_printParsingResult__SWIG_0` = function(self, onlySummary)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  onlySummary = as.logical(onlySummary);
  ;.Call('R_swig_Network_printParsingResult__SWIG_0', self, onlySummary, PACKAGE='infomap');
  
}

attr(`Network_printParsingResult__SWIG_0`, 'returnType') = 'void'
attr(`Network_printParsingResult__SWIG_0`, "inputTypes") = c('_p_Network', 'logical')
class(`Network_printParsingResult__SWIG_0`) = c("SWIGFunction", class('Network_printParsingResult__SWIG_0'))

# Start of Network_printParsingResult

`Network_printParsingResult__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_printParsingResult__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`Network_printParsingResult__SWIG_1`, 'returnType') = 'void'
attr(`Network_printParsingResult__SWIG_1`, "inputTypes") = c('_p_Network')
class(`Network_printParsingResult__SWIG_1`) = c("SWIGFunction", class('Network_printParsingResult__SWIG_1'))

`Network_printParsingResult` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_Network')) {
      f <- Network_printParsingResult__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_Network') && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- Network_printParsingResult__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Network_printParsingResult with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Network_getParsingResultSummary

`Network_getParsingResultSummary` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_getParsingResultSummary', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_getParsingResultSummary`, 'returnType') = 'character'
attr(`Network_getParsingResultSummary`, "inputTypes") = c('_p_Network')
class(`Network_getParsingResultSummary`) = c("SWIGFunction", class('Network_getParsingResultSummary'))

# Start of Network_printNetworkAsPajek

`Network_printNetworkAsPajek` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_Network_printNetworkAsPajek', self, filename, PACKAGE='infomap');
  
}

attr(`Network_printNetworkAsPajek`, 'returnType') = 'void'
attr(`Network_printNetworkAsPajek`, "inputTypes") = c('_p_Network', 'character')
class(`Network_printNetworkAsPajek`) = c("SWIGFunction", class('Network_printNetworkAsPajek'))

# Start of Network_printStateNetwork

`Network_printStateNetwork` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_Network_printStateNetwork', self, filename, PACKAGE='infomap');
  
}

attr(`Network_printStateNetwork`, 'returnType') = 'void'
attr(`Network_printStateNetwork`, "inputTypes") = c('_p_Network', 'character')
class(`Network_printStateNetwork`) = c("SWIGFunction", class('Network_printStateNetwork'))

# Start of Network_numNodes

`Network_numNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_numNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_numNodes`, 'returnType') = 'integer'
attr(`Network_numNodes`, "inputTypes") = c('_p_Network')
class(`Network_numNodes`) = c("SWIGFunction", class('Network_numNodes'))

# Start of Network_nodeNames

`Network_nodeNames` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Network_nodeNames', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`Network_nodeNames`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`Network_nodeNames`, "inputTypes") = c('_p_Network')
class(`Network_nodeNames`) = c("SWIGFunction", class('Network_nodeNames'))

# Start of Network_nodeWeights

`Network_nodeWeights` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_nodeWeights', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_nodeWeights`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`Network_nodeWeights`, "inputTypes") = c('_p_Network')
class(`Network_nodeWeights`) = c("SWIGFunction", class('Network_nodeWeights'))

# Start of Network_sumNodeWeights

`Network_sumNodeWeights` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_sumNodeWeights', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_sumNodeWeights`, 'returnType') = 'numeric'
attr(`Network_sumNodeWeights`, "inputTypes") = c('_p_Network')
class(`Network_sumNodeWeights`) = c("SWIGFunction", class('Network_sumNodeWeights'))

# Start of Network_outDegree

`Network_outDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_outDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_outDegree`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`Network_outDegree`, "inputTypes") = c('_p_Network')
class(`Network_outDegree`) = c("SWIGFunction", class('Network_outDegree'))

# Start of Network_sumLinkOutWeight

`Network_sumLinkOutWeight` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_sumLinkOutWeight', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_sumLinkOutWeight`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`Network_sumLinkOutWeight`, "inputTypes") = c('_p_Network')
class(`Network_sumLinkOutWeight`) = c("SWIGFunction", class('Network_sumLinkOutWeight'))

# Start of Network_linkMap

`Network_linkMap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Network_linkMap', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_std__mapT_unsigned_int_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t_t_t_t", ref=ans) ;
  
  ans
  
}

attr(`Network_linkMap`, 'returnType') = '_p_std__mapT_unsigned_int_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t_t_t_t'
attr(`Network_linkMap`, "inputTypes") = c('_p_Network')
class(`Network_linkMap`) = c("SWIGFunction", class('Network_linkMap'))

# Start of Network_numLinks

`Network_numLinks` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_numLinks', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_numLinks`, 'returnType') = 'integer'
attr(`Network_numLinks`, "inputTypes") = c('_p_Network')
class(`Network_numLinks`) = c("SWIGFunction", class('Network_numLinks'))

# Start of Network_totalLinkWeight

`Network_totalLinkWeight` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_totalLinkWeight', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_totalLinkWeight`, 'returnType') = 'numeric'
attr(`Network_totalLinkWeight`, "inputTypes") = c('_p_Network')
class(`Network_totalLinkWeight`) = c("SWIGFunction", class('Network_totalLinkWeight'))

# Start of Network_totalSelfLinkWeight

`Network_totalSelfLinkWeight` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_totalSelfLinkWeight', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_totalSelfLinkWeight`, 'returnType') = 'numeric'
attr(`Network_totalSelfLinkWeight`, "inputTypes") = c('_p_Network')
class(`Network_totalSelfLinkWeight`) = c("SWIGFunction", class('Network_totalSelfLinkWeight'))

# Start of Network_isBipartite

`Network_isBipartite` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_isBipartite', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_isBipartite`, 'returnType') = 'logical'
attr(`Network_isBipartite`, "inputTypes") = c('_p_Network')
class(`Network_isBipartite`) = c("SWIGFunction", class('Network_isBipartite'))

# Start of Network_numBipartiteNodes

`Network_numBipartiteNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_numBipartiteNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_numBipartiteNodes`, 'returnType') = 'integer'
attr(`Network_numBipartiteNodes`, "inputTypes") = c('_p_Network')
class(`Network_numBipartiteNodes`) = c("SWIGFunction", class('Network_numBipartiteNodes'))

# Start of Network_initNodeNames

`Network_initNodeNames` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_initNodeNames', self, PACKAGE='infomap');
  
}

attr(`Network_initNodeNames`, 'returnType') = 'void'
attr(`Network_initNodeNames`, "inputTypes") = c('_p_Network')
class(`Network_initNodeNames`) = c("SWIGFunction", class('Network_initNodeNames'))

# Start of Network_swapNodeNames

`Network_swapNodeNames` = function(self, target)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(target, "ExternalReference")) target = slot(target,"ref") 
  ;.Call('R_swig_Network_swapNodeNames', self, target, PACKAGE='infomap');
  
}

attr(`Network_swapNodeNames`, 'returnType') = 'void'
attr(`Network_swapNodeNames`, "inputTypes") = c('_p_Network', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`Network_swapNodeNames`) = c("SWIGFunction", class('Network_swapNodeNames'))

# Start of Network_generateOppositeLinkMap

`Network_generateOppositeLinkMap` = function(self, oppositeLinks)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(oppositeLinks, "ExternalReference")) oppositeLinks = slot(oppositeLinks,"ref") 
  ;.Call('R_swig_Network_generateOppositeLinkMap', self, oppositeLinks, PACKAGE='infomap');
  
}

attr(`Network_generateOppositeLinkMap`, 'returnType') = 'void'
attr(`Network_generateOppositeLinkMap`, "inputTypes") = c('_p_Network', '_p_std__mapT_unsigned_int_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t_t_t_t')
class(`Network_generateOppositeLinkMap`) = c("SWIGFunction", class('Network_generateOppositeLinkMap'))

# Start of Network_disposeLinks

`Network_disposeLinks` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_disposeLinks', self, PACKAGE='infomap');
  
}

attr(`Network_disposeLinks`, 'returnType') = 'void'
attr(`Network_disposeLinks`, "inputTypes") = c('_p_Network')
class(`Network_disposeLinks`) = c("SWIGFunction", class('Network_disposeLinks'))

# Start of Network_config

`Network_config` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Network_config', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_Config", ref=ans) ;
  
  ans
  
}

attr(`Network_config`, 'returnType') = '_p_Config'
attr(`Network_config`, "inputTypes") = c('_p_Network')
class(`Network_config`) = c("SWIGFunction", class('Network_config'))

# Start of Network_isFinalized

`Network_isFinalized` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Network_isFinalized', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_isFinalized`, 'returnType') = 'logical'
attr(`Network_isFinalized`, "inputTypes") = c('_p_Network')
class(`Network_isFinalized`) = c("SWIGFunction", class('Network_isFinalized'))

# Start of accessor method for Network
setMethod('$', '_p_Network', function(x, name)

{
  accessorFuns = list('Equal' = Network_Equal, 'setConfig' = Network_setConfig, 'readInputData' = Network_readInputData, 'addNodes' = Network_addNodes, 'addLink' = Network_addLink, 'addBipartiteLink' = Network_addBipartiteLink, 'finalizeAndCheckNetwork' = Network_finalizeAndCheckNetwork, 'printParsingResult' = Network_printParsingResult, 'getParsingResultSummary' = Network_getParsingResultSummary, 'printNetworkAsPajek' = Network_printNetworkAsPajek, 'printStateNetwork' = Network_printStateNetwork, 'numNodes' = Network_numNodes, 'nodeNames' = Network_nodeNames, 'nodeWeights' = Network_nodeWeights, 'sumNodeWeights' = Network_sumNodeWeights, 'outDegree' = Network_outDegree, 'sumLinkOutWeight' = Network_sumLinkOutWeight, 'linkMap' = Network_linkMap, 'numLinks' = Network_numLinks, 'totalLinkWeight' = Network_totalLinkWeight, 'totalSelfLinkWeight' = Network_totalSelfLinkWeight, 'isBipartite' = Network_isBipartite, 'numBipartiteNodes' = Network_numBipartiteNodes, 'initNodeNames' = Network_initNodeNames, 'swapNodeNames' = Network_swapNodeNames, 'generateOppositeLinkMap' = Network_generateOppositeLinkMap, 'disposeLinks' = Network_disposeLinks, 'config' = Network_config, 'isFinalized' = Network_isFinalized);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for Network
setMethod('delete', '_p_Network', function(obj) {delete_Network(obj)})
# Start of Bigram_first_set

`Bigram_first_set` = function(self, s_first)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_first = as.integer(s_first);
  
  if(length(s_first) > 1) {
    warning("using only the first element of s_first");
  };
  
  ;.Call('R_swig_Bigram_first_set', self, s_first, PACKAGE='infomap');
  
}

attr(`Bigram_first_set`, 'returnType') = 'void'
attr(`Bigram_first_set`, "inputTypes") = c('_p_Bigram', 'integer')
class(`Bigram_first_set`) = c("SWIGFunction", class('Bigram_first_set'))

# Start of Bigram_first_get

`Bigram_first_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Bigram_first_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Bigram_first_get`, 'returnType') = 'integer'
attr(`Bigram_first_get`, "inputTypes") = c('_p_Bigram')
class(`Bigram_first_get`) = c("SWIGFunction", class('Bigram_first_get'))

# Start of Bigram_second_set

`Bigram_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_second = as.integer(s_second);
  
  if(length(s_second) > 1) {
    warning("using only the first element of s_second");
  };
  
  ;.Call('R_swig_Bigram_second_set', self, s_second, PACKAGE='infomap');
  
}

attr(`Bigram_second_set`, 'returnType') = 'void'
attr(`Bigram_second_set`, "inputTypes") = c('_p_Bigram', 'integer')
class(`Bigram_second_set`) = c("SWIGFunction", class('Bigram_second_set'))

# Start of Bigram_second_get

`Bigram_second_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Bigram_second_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Bigram_second_get`, 'returnType') = 'integer'
attr(`Bigram_second_get`, "inputTypes") = c('_p_Bigram')
class(`Bigram_second_get`) = c("SWIGFunction", class('Bigram_second_get'))

# Start of new_Bigram

`Bigram__SWIG_0` = function(first, second)
{
  first = as.integer(first);
  
  if(length(first) > 1) {
    warning("using only the first element of first");
  };
  
  second = as.integer(second);
  
  if(length(second) > 1) {
    warning("using only the first element of second");
  };
  
  ;ans = .Call('R_swig_new_Bigram__SWIG_0', first, second, PACKAGE='infomap');
  ans <- new("_p_Bigram", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Bigram)
  ans
  
}

attr(`Bigram__SWIG_0`, 'returnType') = '_p_Bigram'
attr(`Bigram__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`Bigram__SWIG_0`) = c("SWIGFunction", class('Bigram__SWIG_0'))

# Start of new_Bigram

`Bigram__SWIG_1` = function(first)
{
  first = as.integer(first);
  
  if(length(first) > 1) {
    warning("using only the first element of first");
  };
  
  ;ans = .Call('R_swig_new_Bigram__SWIG_1', first, PACKAGE='infomap');
  ans <- new("_p_Bigram", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Bigram)
  ans
  
}

attr(`Bigram__SWIG_1`, 'returnType') = '_p_Bigram'
attr(`Bigram__SWIG_1`, "inputTypes") = c('integer')
class(`Bigram__SWIG_1`) = c("SWIGFunction", class('Bigram__SWIG_1'))

# Start of new_Bigram

`Bigram__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_Bigram__SWIG_2', PACKAGE='infomap');
  ans <- new("_p_Bigram", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Bigram)
  ans
  
}

attr(`Bigram__SWIG_2`, 'returnType') = '_p_Bigram'
class(`Bigram__SWIG_2`) = c("SWIGFunction", class('Bigram__SWIG_2'))

`Bigram` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- Bigram__SWIG_2; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- Bigram__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- Bigram__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Bigram with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bigram_LessThan

`Bigram_LessThan` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;.Call('R_swig_Bigram_LessThan', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Bigram_LessThan`, 'returnType') = 'logical'
attr(`Bigram_LessThan`, "inputTypes") = c('_p_Bigram', '_p_Bigram')
class(`Bigram_LessThan`) = c("SWIGFunction", class('Bigram_LessThan'))

# Start of delete_Bigram

`delete_Bigram` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Bigram', self, PACKAGE='infomap');
  
}

attr(`delete_Bigram`, 'returnType') = 'void'
attr(`delete_Bigram`, "inputTypes") = c('_p_Bigram')
class(`delete_Bigram`) = c("SWIGFunction", class('delete_Bigram'))

# Start of accessor method for Bigram
setMethod('$', '_p_Bigram', function(x, name)

{
  accessorFuns = list('first' = Bigram_first_get, 'second' = Bigram_second_get, 'LessThan' = Bigram_LessThan);
  vaccessors = c('first', 'second');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Bigram
# Start of accessor method for Bigram
setMethod('$<-', '_p_Bigram', function(x, name, value)

{
  accessorFuns = list('first' = Bigram_first_set, 'second' = Bigram_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Bigram', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('first' = Bigram_first_set, 'second' = Bigram_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Bigram
setMethod('delete', '_p_Bigram', function(obj) {delete_Bigram(obj)})
# Start definition of copy functions & methods for Bigram
CopyToR_Bigram = function(value, obj = new("Bigram"))
{
  obj@first = value$first;
  obj@second = value$second;
  obj;
}



CopyToC_Bigram = function(value, obj)
{
  obj$first = value@first;
  obj$second = value@second;
  obj
}



# Start definition of copy methods for Bigram
setMethod('copyToR', '_p_Bigram', CopyToR_Bigram);
setMethod('copyToC', 'Bigram', CopyToC_Bigram);

# End definition of copy methods for Bigram
# End definition of copy functions & methods for Bigram
# Start of BipartiteLink_featureNode_set

`BipartiteLink_featureNode_set` = function(self, s_featureNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_featureNode = as.integer(s_featureNode);
  
  if(length(s_featureNode) > 1) {
    warning("using only the first element of s_featureNode");
  };
  
  ;.Call('R_swig_BipartiteLink_featureNode_set', self, s_featureNode, PACKAGE='infomap');
  
}

attr(`BipartiteLink_featureNode_set`, 'returnType') = 'void'
attr(`BipartiteLink_featureNode_set`, "inputTypes") = c('_p_BipartiteLink', 'integer')
class(`BipartiteLink_featureNode_set`) = c("SWIGFunction", class('BipartiteLink_featureNode_set'))

# Start of BipartiteLink_featureNode_get

`BipartiteLink_featureNode_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BipartiteLink_featureNode_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`BipartiteLink_featureNode_get`, 'returnType') = 'integer'
attr(`BipartiteLink_featureNode_get`, "inputTypes") = c('_p_BipartiteLink')
class(`BipartiteLink_featureNode_get`) = c("SWIGFunction", class('BipartiteLink_featureNode_get'))

# Start of BipartiteLink_node_set

`BipartiteLink_node_set` = function(self, s_node)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_node = as.integer(s_node);
  
  if(length(s_node) > 1) {
    warning("using only the first element of s_node");
  };
  
  ;.Call('R_swig_BipartiteLink_node_set', self, s_node, PACKAGE='infomap');
  
}

attr(`BipartiteLink_node_set`, 'returnType') = 'void'
attr(`BipartiteLink_node_set`, "inputTypes") = c('_p_BipartiteLink', 'integer')
class(`BipartiteLink_node_set`) = c("SWIGFunction", class('BipartiteLink_node_set'))

# Start of BipartiteLink_node_get

`BipartiteLink_node_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BipartiteLink_node_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`BipartiteLink_node_get`, 'returnType') = 'integer'
attr(`BipartiteLink_node_get`, "inputTypes") = c('_p_BipartiteLink')
class(`BipartiteLink_node_get`) = c("SWIGFunction", class('BipartiteLink_node_get'))

# Start of BipartiteLink_swapOrder_set

`BipartiteLink_swapOrder_set` = function(self, s_swapOrder)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_swapOrder = as.logical(s_swapOrder);
  ;.Call('R_swig_BipartiteLink_swapOrder_set', self, s_swapOrder, PACKAGE='infomap');
  
}

attr(`BipartiteLink_swapOrder_set`, 'returnType') = 'void'
attr(`BipartiteLink_swapOrder_set`, "inputTypes") = c('_p_BipartiteLink', 'logical')
class(`BipartiteLink_swapOrder_set`) = c("SWIGFunction", class('BipartiteLink_swapOrder_set'))

# Start of BipartiteLink_swapOrder_get

`BipartiteLink_swapOrder_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BipartiteLink_swapOrder_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`BipartiteLink_swapOrder_get`, 'returnType') = 'logical'
attr(`BipartiteLink_swapOrder_get`, "inputTypes") = c('_p_BipartiteLink')
class(`BipartiteLink_swapOrder_get`) = c("SWIGFunction", class('BipartiteLink_swapOrder_get'))

# Start of new_BipartiteLink

`BipartiteLink__SWIG_0` = function(featureNode, node, swapOrder)
{
  featureNode = as.integer(featureNode);
  
  if(length(featureNode) > 1) {
    warning("using only the first element of featureNode");
  };
  
  node = as.integer(node);
  
  if(length(node) > 1) {
    warning("using only the first element of node");
  };
  
  swapOrder = as.logical(swapOrder);
  ;ans = .Call('R_swig_new_BipartiteLink__SWIG_0', featureNode, node, swapOrder, PACKAGE='infomap');
  ans <- new("_p_BipartiteLink", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BipartiteLink)
  ans
  
}

attr(`BipartiteLink__SWIG_0`, 'returnType') = '_p_BipartiteLink'
attr(`BipartiteLink__SWIG_0`, "inputTypes") = c('integer', 'integer', 'logical')
class(`BipartiteLink__SWIG_0`) = c("SWIGFunction", class('BipartiteLink__SWIG_0'))

# Start of new_BipartiteLink

`BipartiteLink__SWIG_1` = function(featureNode, node)
{
  featureNode = as.integer(featureNode);
  
  if(length(featureNode) > 1) {
    warning("using only the first element of featureNode");
  };
  
  node = as.integer(node);
  
  if(length(node) > 1) {
    warning("using only the first element of node");
  };
  
  ;ans = .Call('R_swig_new_BipartiteLink__SWIG_1', featureNode, node, PACKAGE='infomap');
  ans <- new("_p_BipartiteLink", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BipartiteLink)
  ans
  
}

attr(`BipartiteLink__SWIG_1`, 'returnType') = '_p_BipartiteLink'
attr(`BipartiteLink__SWIG_1`, "inputTypes") = c('integer', 'integer')
class(`BipartiteLink__SWIG_1`) = c("SWIGFunction", class('BipartiteLink__SWIG_1'))

# Start of new_BipartiteLink

`BipartiteLink__SWIG_2` = function(featureNode)
{
  featureNode = as.integer(featureNode);
  
  if(length(featureNode) > 1) {
    warning("using only the first element of featureNode");
  };
  
  ;ans = .Call('R_swig_new_BipartiteLink__SWIG_2', featureNode, PACKAGE='infomap');
  ans <- new("_p_BipartiteLink", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BipartiteLink)
  ans
  
}

attr(`BipartiteLink__SWIG_2`, 'returnType') = '_p_BipartiteLink'
attr(`BipartiteLink__SWIG_2`, "inputTypes") = c('integer')
class(`BipartiteLink__SWIG_2`) = c("SWIGFunction", class('BipartiteLink__SWIG_2'))

# Start of new_BipartiteLink

`BipartiteLink__SWIG_3` = function()
{
  ;ans = .Call('R_swig_new_BipartiteLink__SWIG_3', PACKAGE='infomap');
  ans <- new("_p_BipartiteLink", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BipartiteLink)
  ans
  
}

attr(`BipartiteLink__SWIG_3`, 'returnType') = '_p_BipartiteLink'
class(`BipartiteLink__SWIG_3`) = c("SWIGFunction", class('BipartiteLink__SWIG_3'))

`BipartiteLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- BipartiteLink__SWIG_3; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- BipartiteLink__SWIG_2; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- BipartiteLink__SWIG_1; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- BipartiteLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BipartiteLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BipartiteLink_LessThan

`BipartiteLink_LessThan` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;.Call('R_swig_BipartiteLink_LessThan', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`BipartiteLink_LessThan`, 'returnType') = 'logical'
attr(`BipartiteLink_LessThan`, "inputTypes") = c('_p_BipartiteLink', '_p_BipartiteLink')
class(`BipartiteLink_LessThan`) = c("SWIGFunction", class('BipartiteLink_LessThan'))

# Start of delete_BipartiteLink

`delete_BipartiteLink` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_BipartiteLink', self, PACKAGE='infomap');
  
}

attr(`delete_BipartiteLink`, 'returnType') = 'void'
attr(`delete_BipartiteLink`, "inputTypes") = c('_p_BipartiteLink')
class(`delete_BipartiteLink`) = c("SWIGFunction", class('delete_BipartiteLink'))

# Start of accessor method for BipartiteLink
setMethod('$', '_p_BipartiteLink', function(x, name)

{
  accessorFuns = list('featureNode' = BipartiteLink_featureNode_get, 'node' = BipartiteLink_node_get, 'swapOrder' = BipartiteLink_swapOrder_get, 'LessThan' = BipartiteLink_LessThan);
  vaccessors = c('featureNode', 'node', 'swapOrder');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for BipartiteLink
# Start of accessor method for BipartiteLink
setMethod('$<-', '_p_BipartiteLink', function(x, name, value)

{
  accessorFuns = list('featureNode' = BipartiteLink_featureNode_set, 'node' = BipartiteLink_node_set, 'swapOrder' = BipartiteLink_swapOrder_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_BipartiteLink', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('featureNode' = BipartiteLink_featureNode_set, 'node' = BipartiteLink_node_set, 'swapOrder' = BipartiteLink_swapOrder_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for BipartiteLink
setMethod('delete', '_p_BipartiteLink', function(obj) {delete_BipartiteLink(obj)})
# Start definition of copy functions & methods for BipartiteLink
CopyToR_BipartiteLink = function(value, obj = new("BipartiteLink"))
{
  obj@featureNode = value$featureNode;
  obj@node = value$node;
  obj@swapOrder = value$swapOrder;
  obj;
}



CopyToC_BipartiteLink = function(value, obj)
{
  obj$featureNode = value@featureNode;
  obj$node = value@node;
  obj$swapOrder = value@swapOrder;
  obj
}



# Start definition of copy methods for BipartiteLink
setMethod('copyToR', '_p_BipartiteLink', CopyToR_BipartiteLink);
setMethod('copyToC', 'BipartiteLink', CopyToC_BipartiteLink);

# End definition of copy methods for BipartiteLink
# End definition of copy functions & methods for BipartiteLink
# Start of Weight_weight_set

`Weight_weight_set` = function(self, s_weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Weight_weight_set', self, s_weight, PACKAGE='infomap');
  
}

attr(`Weight_weight_set`, 'returnType') = 'void'
attr(`Weight_weight_set`, "inputTypes") = c('_p_Weight', 'numeric')
class(`Weight_weight_set`) = c("SWIGFunction", class('Weight_weight_set'))

# Start of Weight_weight_get

`Weight_weight_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Weight_weight_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Weight_weight_get`, 'returnType') = 'numeric'
attr(`Weight_weight_get`, "inputTypes") = c('_p_Weight')
class(`Weight_weight_get`) = c("SWIGFunction", class('Weight_weight_get'))

# Start of new_Weight

`Weight__SWIG_0` = function(weight)
{
  ;ans = .Call('R_swig_new_Weight__SWIG_0', weight, PACKAGE='infomap');
  ans <- new("_p_Weight", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Weight)
  ans
  
}

attr(`Weight__SWIG_0`, 'returnType') = '_p_Weight'
attr(`Weight__SWIG_0`, "inputTypes") = c('numeric')
class(`Weight__SWIG_0`) = c("SWIGFunction", class('Weight__SWIG_0'))

# Start of new_Weight

`Weight__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Weight__SWIG_1', PACKAGE='infomap');
  ans <- new("_p_Weight", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Weight)
  ans
  
}

attr(`Weight__SWIG_1`, 'returnType') = '_p_Weight'
class(`Weight__SWIG_1`) = c("SWIGFunction", class('Weight__SWIG_1'))

`Weight` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Weight__SWIG_1; 
  } else if (argc == 1) {
    if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 )) {
      f <- Weight__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Weight with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Weight_PlusEqual

`Weight_PlusEqual` = function(self, w, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_Weight_PlusEqual', self, w, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_Weight", ref=ans) ;
  
  ans
  
}

attr(`Weight_PlusEqual`, 'returnType') = '_p_Weight'
attr(`Weight_PlusEqual`, "inputTypes") = c('_p_Weight', 'numeric')
class(`Weight_PlusEqual`) = c("SWIGFunction", class('Weight_PlusEqual'))

# Start of delete_Weight

`delete_Weight` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Weight', self, PACKAGE='infomap');
  
}

attr(`delete_Weight`, 'returnType') = 'void'
attr(`delete_Weight`, "inputTypes") = c('_p_Weight')
class(`delete_Weight`) = c("SWIGFunction", class('delete_Weight'))

# Start of accessor method for Weight
setMethod('$', '_p_Weight', function(x, name)

{
  accessorFuns = list('weight' = Weight_weight_get, 'PlusEqual' = Weight_PlusEqual);
  vaccessors = c('weight');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Weight
# Start of accessor method for Weight
setMethod('$<-', '_p_Weight', function(x, name, value)

{
  accessorFuns = list('weight' = Weight_weight_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Weight', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('weight' = Weight_weight_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Weight
setMethod('delete', '_p_Weight', function(obj) {delete_Weight(obj)})
# Start definition of copy functions & methods for Weight
CopyToR_Weight = function(value, obj = new("Weight"))
{
  obj@weight = value$weight;
  obj;
}



CopyToC_Weight = function(value, obj)
{
  obj$weight = value@weight;
  obj
}



# Start definition of copy methods for Weight
setMethod('copyToR', '_p_Weight', CopyToR_Weight);
setMethod('copyToC', 'Weight', CopyToC_Weight);

# End definition of copy methods for Weight
# End definition of copy functions & methods for Weight
# Start of new_Triple

`Triple__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Triple__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_Triple", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Triple)
  ans
  
}

attr(`Triple__SWIG_0`, 'returnType') = '_p_Triple'
class(`Triple__SWIG_0`) = c("SWIGFunction", class('Triple__SWIG_0'))

# Start of new_Triple

`Triple__SWIG_1` = function(value1, value2, value3)
{
  value1 = as.integer(value1);
  
  if(length(value1) > 1) {
    warning("using only the first element of value1");
  };
  
  value2 = as.integer(value2);
  
  if(length(value2) > 1) {
    warning("using only the first element of value2");
  };
  
  value3 = as.integer(value3);
  
  if(length(value3) > 1) {
    warning("using only the first element of value3");
  };
  
  ;ans = .Call('R_swig_new_Triple__SWIG_1', value1, value2, value3, PACKAGE='infomap');
  ans <- new("_p_Triple", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Triple)
  ans
  
}

attr(`Triple__SWIG_1`, 'returnType') = '_p_Triple'
attr(`Triple__SWIG_1`, "inputTypes") = c('integer', 'integer', 'integer')
class(`Triple__SWIG_1`) = c("SWIGFunction", class('Triple__SWIG_1'))

# Start of new_Triple

`Triple__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_Triple__SWIG_2', other, PACKAGE='infomap');
  ans <- new("_p_Triple", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Triple)
  ans
  
}

attr(`Triple__SWIG_2`, 'returnType') = '_p_Triple'
attr(`Triple__SWIG_2`, "inputTypes") = c('_p_Triple')
class(`Triple__SWIG_2`) = c("SWIGFunction", class('Triple__SWIG_2'))

`Triple` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- Triple__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Triple') && length(argv[[1]]) == 1) {
      f <- Triple__SWIG_2; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- Triple__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Triple with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Triple

`delete_Triple` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Triple', self, PACKAGE='infomap');
  
}

attr(`delete_Triple`, 'returnType') = 'void'
attr(`delete_Triple`, "inputTypes") = c('_p_Triple')
class(`delete_Triple`) = c("SWIGFunction", class('delete_Triple'))

# Start of Triple_LessThan

`Triple_LessThan` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;.Call('R_swig_Triple_LessThan', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_LessThan`, 'returnType') = 'logical'
attr(`Triple_LessThan`, "inputTypes") = c('_p_Triple', '_p_Triple')
class(`Triple_LessThan`) = c("SWIGFunction", class('Triple_LessThan'))

# Start of Triple_EqualEqual

`Triple_EqualEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;.Call('R_swig_Triple_EqualEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_EqualEqual`, 'returnType') = 'logical'
attr(`Triple_EqualEqual`, "inputTypes") = c('_p_Triple', '_p_Triple')
class(`Triple_EqualEqual`) = c("SWIGFunction", class('Triple_EqualEqual'))

# Start of Triple_n1_set

`Triple_n1_set` = function(self, s_n1)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_n1 = as.integer(s_n1);
  
  if(length(s_n1) > 1) {
    warning("using only the first element of s_n1");
  };
  
  ;.Call('R_swig_Triple_n1_set', self, s_n1, PACKAGE='infomap');
  
}

attr(`Triple_n1_set`, 'returnType') = 'void'
attr(`Triple_n1_set`, "inputTypes") = c('_p_Triple', 'integer')
class(`Triple_n1_set`) = c("SWIGFunction", class('Triple_n1_set'))

# Start of Triple_n1_get

`Triple_n1_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Triple_n1_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_n1_get`, 'returnType') = 'integer'
attr(`Triple_n1_get`, "inputTypes") = c('_p_Triple')
class(`Triple_n1_get`) = c("SWIGFunction", class('Triple_n1_get'))

# Start of Triple_n2_set

`Triple_n2_set` = function(self, s_n2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_n2 = as.integer(s_n2);
  
  if(length(s_n2) > 1) {
    warning("using only the first element of s_n2");
  };
  
  ;.Call('R_swig_Triple_n2_set', self, s_n2, PACKAGE='infomap');
  
}

attr(`Triple_n2_set`, 'returnType') = 'void'
attr(`Triple_n2_set`, "inputTypes") = c('_p_Triple', 'integer')
class(`Triple_n2_set`) = c("SWIGFunction", class('Triple_n2_set'))

# Start of Triple_n2_get

`Triple_n2_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Triple_n2_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_n2_get`, 'returnType') = 'integer'
attr(`Triple_n2_get`, "inputTypes") = c('_p_Triple')
class(`Triple_n2_get`) = c("SWIGFunction", class('Triple_n2_get'))

# Start of Triple_n3_set

`Triple_n3_set` = function(self, s_n3)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_n3 = as.integer(s_n3);
  
  if(length(s_n3) > 1) {
    warning("using only the first element of s_n3");
  };
  
  ;.Call('R_swig_Triple_n3_set', self, s_n3, PACKAGE='infomap');
  
}

attr(`Triple_n3_set`, 'returnType') = 'void'
attr(`Triple_n3_set`, "inputTypes") = c('_p_Triple', 'integer')
class(`Triple_n3_set`) = c("SWIGFunction", class('Triple_n3_set'))

# Start of Triple_n3_get

`Triple_n3_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Triple_n3_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_n3_get`, 'returnType') = 'integer'
attr(`Triple_n3_get`, "inputTypes") = c('_p_Triple')
class(`Triple_n3_get`) = c("SWIGFunction", class('Triple_n3_get'))

# Start of accessor method for Triple
setMethod('$', '_p_Triple', function(x, name)

{
  accessorFuns = list('LessThan' = Triple_LessThan, 'EqualEqual' = Triple_EqualEqual, 'n1' = Triple_n1_get, 'n2' = Triple_n2_get, 'n3' = Triple_n3_get);
  vaccessors = c('n1', 'n2', 'n3');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Triple
# Start of accessor method for Triple
setMethod('$<-', '_p_Triple', function(x, name, value)

{
  accessorFuns = list('n1' = Triple_n1_set, 'n2' = Triple_n2_set, 'n3' = Triple_n3_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Triple', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('n1' = Triple_n1_set, 'n2' = Triple_n2_set, 'n3' = Triple_n3_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Triple
setMethod('delete', '_p_Triple', function(obj) {delete_Triple(obj)})
# Start definition of copy functions & methods for Triple
CopyToR_Triple = function(value, obj = new("Triple"))
{
  obj@n1 = value$n1;
  obj@n2 = value$n2;
  obj@n3 = value$n3;
  obj;
}



CopyToC_Triple = function(value, obj)
{
  obj$n1 = value@n1;
  obj$n2 = value@n2;
  obj$n3 = value@n3;
  obj
}



# Start definition of copy methods for Triple
setMethod('copyToR', '_p_Triple', CopyToR_Triple);
setMethod('copyToC', 'Triple', CopyToC_Triple);

# End definition of copy methods for Triple
# End definition of copy functions & methods for Triple
# Start of new_Link

`Link__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Link__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_Link", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Link)
  ans
  
}

attr(`Link__SWIG_0`, 'returnType') = '_p_Link'
class(`Link__SWIG_0`) = c("SWIGFunction", class('Link__SWIG_0'))

# Start of new_Link

`Link__SWIG_1` = function(n1, n2, weight)
{
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;ans = .Call('R_swig_new_Link__SWIG_1', n1, n2, weight, PACKAGE='infomap');
  ans <- new("_p_Link", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Link)
  ans
  
}

attr(`Link__SWIG_1`, 'returnType') = '_p_Link'
attr(`Link__SWIG_1`, "inputTypes") = c('integer', 'integer', 'numeric')
class(`Link__SWIG_1`) = c("SWIGFunction", class('Link__SWIG_1'))

`Link` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Link__SWIG_0; 
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- Link__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Link with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Link_n1_set

`Link_n1_set` = function(self, s_n1)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_n1 = as.integer(s_n1);
  
  if(length(s_n1) > 1) {
    warning("using only the first element of s_n1");
  };
  
  ;.Call('R_swig_Link_n1_set', self, s_n1, PACKAGE='infomap');
  
}

attr(`Link_n1_set`, 'returnType') = 'void'
attr(`Link_n1_set`, "inputTypes") = c('_p_Link', 'integer')
class(`Link_n1_set`) = c("SWIGFunction", class('Link_n1_set'))

# Start of Link_n1_get

`Link_n1_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Link_n1_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Link_n1_get`, 'returnType') = 'integer'
attr(`Link_n1_get`, "inputTypes") = c('_p_Link')
class(`Link_n1_get`) = c("SWIGFunction", class('Link_n1_get'))

# Start of Link_n2_set

`Link_n2_set` = function(self, s_n2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_n2 = as.integer(s_n2);
  
  if(length(s_n2) > 1) {
    warning("using only the first element of s_n2");
  };
  
  ;.Call('R_swig_Link_n2_set', self, s_n2, PACKAGE='infomap');
  
}

attr(`Link_n2_set`, 'returnType') = 'void'
attr(`Link_n2_set`, "inputTypes") = c('_p_Link', 'integer')
class(`Link_n2_set`) = c("SWIGFunction", class('Link_n2_set'))

# Start of Link_n2_get

`Link_n2_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Link_n2_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Link_n2_get`, 'returnType') = 'integer'
attr(`Link_n2_get`, "inputTypes") = c('_p_Link')
class(`Link_n2_get`) = c("SWIGFunction", class('Link_n2_get'))

# Start of Link_weight_set

`Link_weight_set` = function(self, s_weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_Link_weight_set', self, s_weight, PACKAGE='infomap');
  
}

attr(`Link_weight_set`, 'returnType') = 'void'
attr(`Link_weight_set`, "inputTypes") = c('_p_Link', 'numeric')
class(`Link_weight_set`) = c("SWIGFunction", class('Link_weight_set'))

# Start of Link_weight_get

`Link_weight_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Link_weight_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Link_weight_get`, 'returnType') = 'numeric'
attr(`Link_weight_get`, "inputTypes") = c('_p_Link')
class(`Link_weight_get`) = c("SWIGFunction", class('Link_weight_get'))

# Start of delete_Link

`delete_Link` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Link', self, PACKAGE='infomap');
  
}

attr(`delete_Link`, 'returnType') = 'void'
attr(`delete_Link`, "inputTypes") = c('_p_Link')
class(`delete_Link`) = c("SWIGFunction", class('delete_Link'))

# Start of accessor method for Link
setMethod('$', '_p_Link', function(x, name)

{
  accessorFuns = list('n1' = Link_n1_get, 'n2' = Link_n2_get, 'weight' = Link_weight_get);
  vaccessors = c('n1', 'n2', 'weight');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Link
# Start of accessor method for Link
setMethod('$<-', '_p_Link', function(x, name, value)

{
  accessorFuns = list('n1' = Link_n1_set, 'n2' = Link_n2_set, 'weight' = Link_weight_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Link', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('n1' = Link_n1_set, 'n2' = Link_n2_set, 'weight' = Link_weight_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Link
setMethod('delete', '_p_Link', function(obj) {delete_Link(obj)})
# Start definition of copy functions & methods for Link
CopyToR_Link = function(value, obj = new("Link"))
{
  obj@n1 = value$n1;
  obj@n2 = value$n2;
  obj@weight = value$weight;
  obj;
}



CopyToC_Link = function(value, obj)
{
  obj$n1 = value@n1;
  obj$n2 = value@n2;
  obj$weight = value@weight;
  obj
}



# Start definition of copy methods for Link
setMethod('copyToR', '_p_Link', CopyToR_Link);
setMethod('copyToC', 'Link', CopyToC_Link);

# End definition of copy methods for Link
# End definition of copy functions & methods for Link
# Start of new_ComplementaryData

`ComplementaryData` = function(n1, n2, weight)
{
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;ans = .Call('R_swig_new_ComplementaryData', n1, n2, weight, PACKAGE='infomap');
  ans <- new("_p_ComplementaryData", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ComplementaryData)
  ans
  
}

attr(`ComplementaryData`, 'returnType') = '_p_ComplementaryData'
attr(`ComplementaryData`, "inputTypes") = c('integer', 'integer', 'numeric')
class(`ComplementaryData`) = c("SWIGFunction", class('ComplementaryData'))

# Start of ComplementaryData_addExactMatch

`ComplementaryData_addExactMatch` = function(self, missing, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  missing = as.integer(missing);
  
  if(length(missing) > 1) {
    warning("using only the first element of missing");
  };
  
  
  ;.Call('R_swig_ComplementaryData_addExactMatch', self, missing, weight, PACKAGE='infomap');
  
}

attr(`ComplementaryData_addExactMatch`, 'returnType') = 'void'
attr(`ComplementaryData_addExactMatch`, "inputTypes") = c('_p_ComplementaryData', 'integer', 'numeric')
class(`ComplementaryData_addExactMatch`) = c("SWIGFunction", class('ComplementaryData_addExactMatch'))

# Start of ComplementaryData_addPartialMatch

`ComplementaryData_addPartialMatch` = function(self, missing, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  missing = as.integer(missing);
  
  if(length(missing) > 1) {
    warning("using only the first element of missing");
  };
  
  
  ;.Call('R_swig_ComplementaryData_addPartialMatch', self, missing, weight, PACKAGE='infomap');
  
}

attr(`ComplementaryData_addPartialMatch`, 'returnType') = 'void'
attr(`ComplementaryData_addPartialMatch`, "inputTypes") = c('_p_ComplementaryData', 'integer', 'numeric')
class(`ComplementaryData_addPartialMatch`) = c("SWIGFunction", class('ComplementaryData_addPartialMatch'))

# Start of ComplementaryData_addShiftedMatch

`ComplementaryData_addShiftedMatch` = function(self, missing, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  missing = as.integer(missing);
  
  if(length(missing) > 1) {
    warning("using only the first element of missing");
  };
  
  
  ;.Call('R_swig_ComplementaryData_addShiftedMatch', self, missing, weight, PACKAGE='infomap');
  
}

attr(`ComplementaryData_addShiftedMatch`, 'returnType') = 'void'
attr(`ComplementaryData_addShiftedMatch`, "inputTypes") = c('_p_ComplementaryData', 'integer', 'numeric')
class(`ComplementaryData_addShiftedMatch`) = c("SWIGFunction", class('ComplementaryData_addShiftedMatch'))

# Start of ComplementaryData_incompleteLink_set

`ComplementaryData_incompleteLink_set` = function(self, s_incompleteLink)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_incompleteLink, "ExternalReference")) s_incompleteLink = slot(s_incompleteLink,"ref") 
  ;.Call('R_swig_ComplementaryData_incompleteLink_set', self, s_incompleteLink, PACKAGE='infomap');
  
}

attr(`ComplementaryData_incompleteLink_set`, 'returnType') = 'void'
attr(`ComplementaryData_incompleteLink_set`, "inputTypes") = c('_p_ComplementaryData', '_p_Link')
class(`ComplementaryData_incompleteLink_set`) = c("SWIGFunction", class('ComplementaryData_incompleteLink_set'))

# Start of ComplementaryData_incompleteLink_get

`ComplementaryData_incompleteLink_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ComplementaryData_incompleteLink_get', self, PACKAGE='infomap');
  ans <- new("_p_Link", ref=ans) ;
  
  ans
  
}

attr(`ComplementaryData_incompleteLink_get`, 'returnType') = '_p_Link'
attr(`ComplementaryData_incompleteLink_get`, "inputTypes") = c('_p_ComplementaryData')
class(`ComplementaryData_incompleteLink_get`) = c("SWIGFunction", class('ComplementaryData_incompleteLink_get'))

# Start of ComplementaryData_exactMatch_set

`ComplementaryData_exactMatch_set` = function(self, s_exactMatch)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_exactMatch, "ExternalReference")) s_exactMatch = slot(s_exactMatch,"ref") 
  ;.Call('R_swig_ComplementaryData_exactMatch_set', self, s_exactMatch, PACKAGE='infomap');
  
}

attr(`ComplementaryData_exactMatch_set`, 'returnType') = 'void'
attr(`ComplementaryData_exactMatch_set`, "inputTypes") = c('_p_ComplementaryData', '_p_EasyMapT_unsigned_int_double_t')
class(`ComplementaryData_exactMatch_set`) = c("SWIGFunction", class('ComplementaryData_exactMatch_set'))

# Start of ComplementaryData_exactMatch_get

`ComplementaryData_exactMatch_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ComplementaryData_exactMatch_get', self, PACKAGE='infomap');
  ans <- new("_p_EasyMapT_unsigned_int_double_t", ref=ans) ;
  
  ans
  
}

attr(`ComplementaryData_exactMatch_get`, 'returnType') = '_p_EasyMapT_unsigned_int_double_t'
attr(`ComplementaryData_exactMatch_get`, "inputTypes") = c('_p_ComplementaryData')
class(`ComplementaryData_exactMatch_get`) = c("SWIGFunction", class('ComplementaryData_exactMatch_get'))

# Start of ComplementaryData_sumWeightExactMatch_set

`ComplementaryData_sumWeightExactMatch_set` = function(self, s_sumWeightExactMatch)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_ComplementaryData_sumWeightExactMatch_set', self, s_sumWeightExactMatch, PACKAGE='infomap');
  
}

attr(`ComplementaryData_sumWeightExactMatch_set`, 'returnType') = 'void'
attr(`ComplementaryData_sumWeightExactMatch_set`, "inputTypes") = c('_p_ComplementaryData', 'numeric')
class(`ComplementaryData_sumWeightExactMatch_set`) = c("SWIGFunction", class('ComplementaryData_sumWeightExactMatch_set'))

# Start of ComplementaryData_sumWeightExactMatch_get

`ComplementaryData_sumWeightExactMatch_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ComplementaryData_sumWeightExactMatch_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ComplementaryData_sumWeightExactMatch_get`, 'returnType') = 'numeric'
attr(`ComplementaryData_sumWeightExactMatch_get`, "inputTypes") = c('_p_ComplementaryData')
class(`ComplementaryData_sumWeightExactMatch_get`) = c("SWIGFunction", class('ComplementaryData_sumWeightExactMatch_get'))

# Start of ComplementaryData_partialMatch_set

`ComplementaryData_partialMatch_set` = function(self, s_partialMatch)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_partialMatch, "ExternalReference")) s_partialMatch = slot(s_partialMatch,"ref") 
  ;.Call('R_swig_ComplementaryData_partialMatch_set', self, s_partialMatch, PACKAGE='infomap');
  
}

attr(`ComplementaryData_partialMatch_set`, 'returnType') = 'void'
attr(`ComplementaryData_partialMatch_set`, "inputTypes") = c('_p_ComplementaryData', '_p_EasyMapT_unsigned_int_double_t')
class(`ComplementaryData_partialMatch_set`) = c("SWIGFunction", class('ComplementaryData_partialMatch_set'))

# Start of ComplementaryData_partialMatch_get

`ComplementaryData_partialMatch_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ComplementaryData_partialMatch_get', self, PACKAGE='infomap');
  ans <- new("_p_EasyMapT_unsigned_int_double_t", ref=ans) ;
  
  ans
  
}

attr(`ComplementaryData_partialMatch_get`, 'returnType') = '_p_EasyMapT_unsigned_int_double_t'
attr(`ComplementaryData_partialMatch_get`, "inputTypes") = c('_p_ComplementaryData')
class(`ComplementaryData_partialMatch_get`) = c("SWIGFunction", class('ComplementaryData_partialMatch_get'))

# Start of ComplementaryData_sumWeightPartialMatch_set

`ComplementaryData_sumWeightPartialMatch_set` = function(self, s_sumWeightPartialMatch)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_ComplementaryData_sumWeightPartialMatch_set', self, s_sumWeightPartialMatch, PACKAGE='infomap');
  
}

attr(`ComplementaryData_sumWeightPartialMatch_set`, 'returnType') = 'void'
attr(`ComplementaryData_sumWeightPartialMatch_set`, "inputTypes") = c('_p_ComplementaryData', 'numeric')
class(`ComplementaryData_sumWeightPartialMatch_set`) = c("SWIGFunction", class('ComplementaryData_sumWeightPartialMatch_set'))

# Start of ComplementaryData_sumWeightPartialMatch_get

`ComplementaryData_sumWeightPartialMatch_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ComplementaryData_sumWeightPartialMatch_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ComplementaryData_sumWeightPartialMatch_get`, 'returnType') = 'numeric'
attr(`ComplementaryData_sumWeightPartialMatch_get`, "inputTypes") = c('_p_ComplementaryData')
class(`ComplementaryData_sumWeightPartialMatch_get`) = c("SWIGFunction", class('ComplementaryData_sumWeightPartialMatch_get'))

# Start of ComplementaryData_shiftedMatch_set

`ComplementaryData_shiftedMatch_set` = function(self, s_shiftedMatch)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_shiftedMatch, "ExternalReference")) s_shiftedMatch = slot(s_shiftedMatch,"ref") 
  ;.Call('R_swig_ComplementaryData_shiftedMatch_set', self, s_shiftedMatch, PACKAGE='infomap');
  
}

attr(`ComplementaryData_shiftedMatch_set`, 'returnType') = 'void'
attr(`ComplementaryData_shiftedMatch_set`, "inputTypes") = c('_p_ComplementaryData', '_p_EasyMapT_unsigned_int_double_t')
class(`ComplementaryData_shiftedMatch_set`) = c("SWIGFunction", class('ComplementaryData_shiftedMatch_set'))

# Start of ComplementaryData_shiftedMatch_get

`ComplementaryData_shiftedMatch_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ComplementaryData_shiftedMatch_get', self, PACKAGE='infomap');
  ans <- new("_p_EasyMapT_unsigned_int_double_t", ref=ans) ;
  
  ans
  
}

attr(`ComplementaryData_shiftedMatch_get`, 'returnType') = '_p_EasyMapT_unsigned_int_double_t'
attr(`ComplementaryData_shiftedMatch_get`, "inputTypes") = c('_p_ComplementaryData')
class(`ComplementaryData_shiftedMatch_get`) = c("SWIGFunction", class('ComplementaryData_shiftedMatch_get'))

# Start of ComplementaryData_sumWeightShiftedMatch_set

`ComplementaryData_sumWeightShiftedMatch_set` = function(self, s_sumWeightShiftedMatch)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_ComplementaryData_sumWeightShiftedMatch_set', self, s_sumWeightShiftedMatch, PACKAGE='infomap');
  
}

attr(`ComplementaryData_sumWeightShiftedMatch_set`, 'returnType') = 'void'
attr(`ComplementaryData_sumWeightShiftedMatch_set`, "inputTypes") = c('_p_ComplementaryData', 'numeric')
class(`ComplementaryData_sumWeightShiftedMatch_set`) = c("SWIGFunction", class('ComplementaryData_sumWeightShiftedMatch_set'))

# Start of ComplementaryData_sumWeightShiftedMatch_get

`ComplementaryData_sumWeightShiftedMatch_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ComplementaryData_sumWeightShiftedMatch_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ComplementaryData_sumWeightShiftedMatch_get`, 'returnType') = 'numeric'
attr(`ComplementaryData_sumWeightShiftedMatch_get`, "inputTypes") = c('_p_ComplementaryData')
class(`ComplementaryData_sumWeightShiftedMatch_get`) = c("SWIGFunction", class('ComplementaryData_sumWeightShiftedMatch_get'))

# Start of delete_ComplementaryData

`delete_ComplementaryData` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_ComplementaryData', self, PACKAGE='infomap');
  
}

attr(`delete_ComplementaryData`, 'returnType') = 'void'
attr(`delete_ComplementaryData`, "inputTypes") = c('_p_ComplementaryData')
class(`delete_ComplementaryData`) = c("SWIGFunction", class('delete_ComplementaryData'))

# Start of accessor method for ComplementaryData
setMethod('$', '_p_ComplementaryData', function(x, name)

{
  accessorFuns = list('addExactMatch' = ComplementaryData_addExactMatch, 'addPartialMatch' = ComplementaryData_addPartialMatch, 'addShiftedMatch' = ComplementaryData_addShiftedMatch, 'incompleteLink' = ComplementaryData_incompleteLink_get, 'exactMatch' = ComplementaryData_exactMatch_get, 'sumWeightExactMatch' = ComplementaryData_sumWeightExactMatch_get, 'partialMatch' = ComplementaryData_partialMatch_get, 'sumWeightPartialMatch' = ComplementaryData_sumWeightPartialMatch_get, 'shiftedMatch' = ComplementaryData_shiftedMatch_get, 'sumWeightShiftedMatch' = ComplementaryData_sumWeightShiftedMatch_get);
  vaccessors = c('incompleteLink', 'exactMatch', 'sumWeightExactMatch', 'partialMatch', 'sumWeightPartialMatch', 'shiftedMatch', 'sumWeightShiftedMatch');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ComplementaryData
# Start of accessor method for ComplementaryData
setMethod('$<-', '_p_ComplementaryData', function(x, name, value)

{
  accessorFuns = list('incompleteLink' = ComplementaryData_incompleteLink_set, 'exactMatch' = ComplementaryData_exactMatch_set, 'sumWeightExactMatch' = ComplementaryData_sumWeightExactMatch_set, 'partialMatch' = ComplementaryData_partialMatch_set, 'sumWeightPartialMatch' = ComplementaryData_sumWeightPartialMatch_set, 'shiftedMatch' = ComplementaryData_shiftedMatch_set, 'sumWeightShiftedMatch' = ComplementaryData_sumWeightShiftedMatch_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ComplementaryData', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('incompleteLink' = ComplementaryData_incompleteLink_set, 'exactMatch' = ComplementaryData_exactMatch_set, 'sumWeightExactMatch' = ComplementaryData_sumWeightExactMatch_set, 'partialMatch' = ComplementaryData_partialMatch_set, 'sumWeightPartialMatch' = ComplementaryData_sumWeightPartialMatch_set, 'shiftedMatch' = ComplementaryData_shiftedMatch_set, 'sumWeightShiftedMatch' = ComplementaryData_sumWeightShiftedMatch_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ComplementaryData
setMethod('delete', '_p_ComplementaryData', function(obj) {delete_ComplementaryData(obj)})
# Start definition of copy functions & methods for ComplementaryData
CopyToR_ComplementaryData = function(value, obj = new("ComplementaryData"))
{
  obj@sumWeightExactMatch = value$sumWeightExactMatch;
  obj@sumWeightPartialMatch = value$sumWeightPartialMatch;
  obj@sumWeightShiftedMatch = value$sumWeightShiftedMatch;
  obj;
}



CopyToC_ComplementaryData = function(value, obj)
{
  obj$sumWeightExactMatch = value@sumWeightExactMatch;
  obj$sumWeightPartialMatch = value@sumWeightPartialMatch;
  obj$sumWeightShiftedMatch = value@sumWeightShiftedMatch;
  obj
}



# Start definition of copy methods for ComplementaryData
setMethod('copyToR', '_p_ComplementaryData', CopyToR_ComplementaryData);
setMethod('copyToC', 'ComplementaryData', CopyToC_ComplementaryData);

# End definition of copy methods for ComplementaryData
# End definition of copy functions & methods for ComplementaryData
# Start of new_MemNetwork

`MemNetwork__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_MemNetwork__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_MemNetwork", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_MemNetwork)
  ans
  
}

attr(`MemNetwork__SWIG_0`, 'returnType') = '_p_MemNetwork'
class(`MemNetwork__SWIG_0`) = c("SWIGFunction", class('MemNetwork__SWIG_0'))

# Start of new_MemNetwork

`MemNetwork__SWIG_1` = function(config)
{
  if (inherits(config, "ExternalReference")) config = slot(config,"ref") 
  ;ans = .Call('R_swig_new_MemNetwork__SWIG_1', config, PACKAGE='infomap');
  ans <- new("_p_MemNetwork", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_MemNetwork)
  ans
  
}

attr(`MemNetwork__SWIG_1`, 'returnType') = '_p_MemNetwork'
attr(`MemNetwork__SWIG_1`, "inputTypes") = c('_p_Config')
class(`MemNetwork__SWIG_1`) = c("SWIGFunction", class('MemNetwork__SWIG_1'))

# Start of new_MemNetwork

`MemNetwork__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_MemNetwork__SWIG_2', other, PACKAGE='infomap');
  ans <- new("_p_MemNetwork", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_MemNetwork)
  ans
  
}

attr(`MemNetwork__SWIG_2`, 'returnType') = '_p_MemNetwork'
attr(`MemNetwork__SWIG_2`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork__SWIG_2`) = c("SWIGFunction", class('MemNetwork__SWIG_2'))

`MemNetwork` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- MemNetwork__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Config') && length(argv[[1]]) == 1) {
      f <- MemNetwork__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_MemNetwork') && length(argv[[1]]) == 1) {
      f <- MemNetwork__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for MemNetwork with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemNetwork_Equal

`MemNetwork_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_MemNetwork_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_MemNetwork", ref=ans) ;
  
  ans
  
}

attr(`MemNetwork_Equal`, 'returnType') = '_p_MemNetwork'
attr(`MemNetwork_Equal`, "inputTypes") = c('_p_MemNetwork', '_p_MemNetwork')
class(`MemNetwork_Equal`) = c("SWIGFunction", class('MemNetwork_Equal'))

# Start of delete_MemNetwork

`delete_MemNetwork` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_MemNetwork', self, PACKAGE='infomap');
  
}

attr(`delete_MemNetwork`, 'returnType') = 'void'
attr(`delete_MemNetwork`, "inputTypes") = c('_p_MemNetwork')
class(`delete_MemNetwork`) = c("SWIGFunction", class('delete_MemNetwork'))

# Start of MemNetwork_readInputData

`MemNetwork_readInputData__SWIG_0` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_MemNetwork_readInputData__SWIG_0', self, filename, PACKAGE='infomap');
  
}

attr(`MemNetwork_readInputData__SWIG_0`, 'returnType') = 'void'
attr(`MemNetwork_readInputData__SWIG_0`, "inputTypes") = c('_p_MemNetwork', 'character')
class(`MemNetwork_readInputData__SWIG_0`) = c("SWIGFunction", class('MemNetwork_readInputData__SWIG_0'))

# Start of MemNetwork_readInputData

`MemNetwork_readInputData__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_readInputData__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`MemNetwork_readInputData__SWIG_1`, 'returnType') = 'void'
attr(`MemNetwork_readInputData__SWIG_1`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_readInputData__SWIG_1`) = c("SWIGFunction", class('MemNetwork_readInputData__SWIG_1'))

`MemNetwork_readInputData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_MemNetwork')) {
      f <- MemNetwork_readInputData__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_MemNetwork') && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- MemNetwork_readInputData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MemNetwork_readInputData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemNetwork_addStateLink

`MemNetwork_addStateLink__SWIG_0` = function(self, n1PriorState, n1, n2PriorState, n2, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1PriorState = as.integer(n1PriorState);
  
  if(length(n1PriorState) > 1) {
    warning("using only the first element of n1PriorState");
  };
  
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2PriorState = as.integer(n2PriorState);
  
  if(length(n2PriorState) > 1) {
    warning("using only the first element of n2PriorState");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;.Call('R_swig_MemNetwork_addStateLink__SWIG_0', self, n1PriorState, n1, n2PriorState, n2, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_addStateLink__SWIG_0`, 'returnType') = 'logical'
attr(`MemNetwork_addStateLink__SWIG_0`, "inputTypes") = c('_p_MemNetwork', 'integer', 'integer', 'integer', 'integer', 'numeric')
class(`MemNetwork_addStateLink__SWIG_0`) = c("SWIGFunction", class('MemNetwork_addStateLink__SWIG_0'))

# Start of MemNetwork_addStateLink

`MemNetwork_addStateLink__SWIG_1` = function(self, n1PriorState, n1, n2PriorState, n2, weight, firstStateNodeWeight, secondStateNodeWeight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n1PriorState = as.integer(n1PriorState);
  
  if(length(n1PriorState) > 1) {
    warning("using only the first element of n1PriorState");
  };
  
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2PriorState = as.integer(n2PriorState);
  
  if(length(n2PriorState) > 1) {
    warning("using only the first element of n2PriorState");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  
  
  ;.Call('R_swig_MemNetwork_addStateLink__SWIG_1', self, n1PriorState, n1, n2PriorState, n2, weight, firstStateNodeWeight, secondStateNodeWeight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_addStateLink__SWIG_1`, 'returnType') = 'logical'
attr(`MemNetwork_addStateLink__SWIG_1`, "inputTypes") = c('_p_MemNetwork', 'integer', 'integer', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`MemNetwork_addStateLink__SWIG_1`) = c("SWIGFunction", class('MemNetwork_addStateLink__SWIG_1'))

# Start of MemNetwork_addStateLink

`MemNetwork_addStateLink__SWIG_2` = function(self, firstStateNode, n2PriorState, n2, weight, firstStateNodeWeight, secondStateNodeWeight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(firstStateNode, "ExternalReference")) firstStateNode = slot(firstStateNode,"ref") 
  n2PriorState = as.integer(n2PriorState);
  
  if(length(n2PriorState) > 1) {
    warning("using only the first element of n2PriorState");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  
  
  ;.Call('R_swig_MemNetwork_addStateLink__SWIG_2', self, firstStateNode, n2PriorState, n2, weight, firstStateNodeWeight, secondStateNodeWeight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_addStateLink__SWIG_2`, 'returnType') = 'logical'
attr(`MemNetwork_addStateLink__SWIG_2`, "inputTypes") = c('_p_MemNetwork', '_p_mapT_StateNode_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t_t_t_t__iterator', 'integer', 'integer', 'numeric', 'numeric', 'numeric')
class(`MemNetwork_addStateLink__SWIG_2`) = c("SWIGFunction", class('MemNetwork_addStateLink__SWIG_2'))

# Start of MemNetwork_addStateLink

`MemNetwork_addStateLink__SWIG_3` = function(self, s1, s2, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s1, "ExternalReference")) s1 = slot(s1,"ref") 
  if (inherits(s2, "ExternalReference")) s2 = slot(s2,"ref") 
  
  ;.Call('R_swig_MemNetwork_addStateLink__SWIG_3', self, s1, s2, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_addStateLink__SWIG_3`, 'returnType') = 'logical'
attr(`MemNetwork_addStateLink__SWIG_3`, "inputTypes") = c('_p_MemNetwork', '_p_StateNode', '_p_StateNode', 'numeric')
class(`MemNetwork_addStateLink__SWIG_3`) = c("SWIGFunction", class('MemNetwork_addStateLink__SWIG_3'))

`MemNetwork_addStateLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 4) {
    if (extends(argtypes[1], '_p_MemNetwork') && extends(argtypes[2], '_p_StateNode') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_StateNode') && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- MemNetwork_addStateLink__SWIG_3; 
    }
  } else if (argc == 6) {
    if (extends(argtypes[1], '_p_MemNetwork') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 )) {
      f <- MemNetwork_addStateLink__SWIG_0; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_MemNetwork') && extends(argtypes[2], '_p_mapT_StateNode_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t_t_t_t__iterator') && length(argv[[2]]) == 1 && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 ) && ( is.numeric(argv[[7]]) && length(argv[[7]]) == 1 )) {
      f <- MemNetwork_addStateLink__SWIG_2; 
    }
  } else if (argc == 8) {
    if (extends(argtypes[1], '_p_MemNetwork') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 ) && ( is.numeric(argv[[7]]) && length(argv[[7]]) == 1 ) && ( is.numeric(argv[[8]]) && length(argv[[8]]) == 1 )) {
      f <- MemNetwork_addStateLink__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for MemNetwork_addStateLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemNetwork_addStateNode

`MemNetwork_addStateNode__SWIG_0` = function(self, priorState, nodeIndex, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  priorState = as.integer(priorState);
  
  if(length(priorState) > 1) {
    warning("using only the first element of priorState");
  };
  
  nodeIndex = as.integer(nodeIndex);
  
  if(length(nodeIndex) > 1) {
    warning("using only the first element of nodeIndex");
  };
  
  
  ;.Call('R_swig_MemNetwork_addStateNode__SWIG_0', self, priorState, nodeIndex, weight, PACKAGE='infomap');
  
}

attr(`MemNetwork_addStateNode__SWIG_0`, 'returnType') = 'void'
attr(`MemNetwork_addStateNode__SWIG_0`, "inputTypes") = c('_p_MemNetwork', 'integer', 'integer', 'numeric')
class(`MemNetwork_addStateNode__SWIG_0`) = c("SWIGFunction", class('MemNetwork_addStateNode__SWIG_0'))

# Start of MemNetwork_addStateNode

`MemNetwork_addStateNode__SWIG_1` = function(self, stateNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(stateNode, "ExternalReference")) stateNode = slot(stateNode,"ref") 
  ;.Call('R_swig_MemNetwork_addStateNode__SWIG_1', self, stateNode, PACKAGE='infomap');
  
}

attr(`MemNetwork_addStateNode__SWIG_1`, 'returnType') = 'void'
attr(`MemNetwork_addStateNode__SWIG_1`, "inputTypes") = c('_p_MemNetwork', '_p_StateNode')
class(`MemNetwork_addStateNode__SWIG_1`) = c("SWIGFunction", class('MemNetwork_addStateNode__SWIG_1'))

`MemNetwork_addStateNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_MemNetwork') && extends(argtypes[2], '_p_StateNode') && length(argv[[2]]) == 1) {
      f <- MemNetwork_addStateNode__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_MemNetwork') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- MemNetwork_addStateNode__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MemNetwork_addStateNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemNetwork_finalizeAndCheckNetwork

`MemNetwork_finalizeAndCheckNetwork__SWIG_0` = function(self, printSummary)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  printSummary = as.logical(printSummary);
  ;.Call('R_swig_MemNetwork_finalizeAndCheckNetwork__SWIG_0', self, printSummary, PACKAGE='infomap');
  
}

attr(`MemNetwork_finalizeAndCheckNetwork__SWIG_0`, 'returnType') = 'void'
attr(`MemNetwork_finalizeAndCheckNetwork__SWIG_0`, "inputTypes") = c('_p_MemNetwork', 'logical')
class(`MemNetwork_finalizeAndCheckNetwork__SWIG_0`) = c("SWIGFunction", class('MemNetwork_finalizeAndCheckNetwork__SWIG_0'))

# Start of MemNetwork_finalizeAndCheckNetwork

`MemNetwork_finalizeAndCheckNetwork__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_finalizeAndCheckNetwork__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`MemNetwork_finalizeAndCheckNetwork__SWIG_1`, 'returnType') = 'void'
attr(`MemNetwork_finalizeAndCheckNetwork__SWIG_1`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_finalizeAndCheckNetwork__SWIG_1`) = c("SWIGFunction", class('MemNetwork_finalizeAndCheckNetwork__SWIG_1'))

`MemNetwork_finalizeAndCheckNetwork` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_MemNetwork')) {
      f <- MemNetwork_finalizeAndCheckNetwork__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_MemNetwork') && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- MemNetwork_finalizeAndCheckNetwork__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MemNetwork_finalizeAndCheckNetwork with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemNetwork_printParsingResult

`MemNetwork_printParsingResult__SWIG_0` = function(self, includeFirstOrderData)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  includeFirstOrderData = as.logical(includeFirstOrderData);
  ;.Call('R_swig_MemNetwork_printParsingResult__SWIG_0', self, includeFirstOrderData, PACKAGE='infomap');
  
}

attr(`MemNetwork_printParsingResult__SWIG_0`, 'returnType') = 'void'
attr(`MemNetwork_printParsingResult__SWIG_0`, "inputTypes") = c('_p_MemNetwork', 'logical')
class(`MemNetwork_printParsingResult__SWIG_0`) = c("SWIGFunction", class('MemNetwork_printParsingResult__SWIG_0'))

# Start of MemNetwork_printParsingResult

`MemNetwork_printParsingResult__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_printParsingResult__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`MemNetwork_printParsingResult__SWIG_1`, 'returnType') = 'void'
attr(`MemNetwork_printParsingResult__SWIG_1`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_printParsingResult__SWIG_1`) = c("SWIGFunction", class('MemNetwork_printParsingResult__SWIG_1'))

`MemNetwork_printParsingResult` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_MemNetwork')) {
      f <- MemNetwork_printParsingResult__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_MemNetwork') && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- MemNetwork_printParsingResult__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MemNetwork_printParsingResult with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemNetwork_numStateNodes

`MemNetwork_numStateNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_numStateNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_numStateNodes`, 'returnType') = 'integer'
attr(`MemNetwork_numStateNodes`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_numStateNodes`) = c("SWIGFunction", class('MemNetwork_numStateNodes'))

# Start of MemNetwork_stateNodeMap

`MemNetwork_stateNodeMap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_MemNetwork_stateNodeMap', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_mapT_StateNode_unsigned_int_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_unsigned_int_t_t_t", ref=ans) ;
  
  ans
  
}

attr(`MemNetwork_stateNodeMap`, 'returnType') = '_p_mapT_StateNode_unsigned_int_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_unsigned_int_t_t_t'
attr(`MemNetwork_stateNodeMap`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_stateNodeMap`) = c("SWIGFunction", class('MemNetwork_stateNodeMap'))

# Start of MemNetwork_stateNodeWeights

`MemNetwork_stateNodeWeights` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_stateNodeWeights', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_stateNodeWeights`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`MemNetwork_stateNodeWeights`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_stateNodeWeights`) = c("SWIGFunction", class('MemNetwork_stateNodeWeights'))

# Start of MemNetwork_totalStateNodeWeight

`MemNetwork_totalStateNodeWeight` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_totalStateNodeWeight', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_totalStateNodeWeight`, 'returnType') = 'numeric'
attr(`MemNetwork_totalStateNodeWeight`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_totalStateNodeWeight`) = c("SWIGFunction", class('MemNetwork_totalStateNodeWeight'))

# Start of MemNetwork_stateLinkMap

`MemNetwork_stateLinkMap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_MemNetwork_stateLinkMap', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_mapT_StateNode_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t_t_t_t", ref=ans) ;
  
  ans
  
}

attr(`MemNetwork_stateLinkMap`, 'returnType') = '_p_mapT_StateNode_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_std__mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t_t_t_t'
attr(`MemNetwork_stateLinkMap`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_stateLinkMap`) = c("SWIGFunction", class('MemNetwork_stateLinkMap'))

# Start of MemNetwork_numStateLinks

`MemNetwork_numStateLinks` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_numStateLinks', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_numStateLinks`, 'returnType') = 'integer'
attr(`MemNetwork_numStateLinks`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_numStateLinks`) = c("SWIGFunction", class('MemNetwork_numStateLinks'))

# Start of MemNetwork_totalStateLinkWeight

`MemNetwork_totalStateLinkWeight` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_totalStateLinkWeight', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_totalStateLinkWeight`, 'returnType') = 'numeric'
attr(`MemNetwork_totalStateLinkWeight`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_totalStateLinkWeight`) = c("SWIGFunction", class('MemNetwork_totalStateLinkWeight'))

# Start of MemNetwork_totalMemorySelfLinkWeight

`MemNetwork_totalMemorySelfLinkWeight` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_totalMemorySelfLinkWeight', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNetwork_totalMemorySelfLinkWeight`, 'returnType') = 'numeric'
attr(`MemNetwork_totalMemorySelfLinkWeight`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_totalMemorySelfLinkWeight`) = c("SWIGFunction", class('MemNetwork_totalMemorySelfLinkWeight'))

# Start of MemNetwork_stateNodes

`MemNetwork_stateNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_MemNetwork_stateNodes', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t", ref=ans) ;
  
  ans
  
}

attr(`MemNetwork_stateNodes`, 'returnType') = '_p_mapT_StateNode_double_std__lessT_StateNode_t_std__allocatorT_std__pairT_StateNode_const_double_t_t_t'
attr(`MemNetwork_stateNodes`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_stateNodes`) = c("SWIGFunction", class('MemNetwork_stateNodes'))

# Start of MemNetwork_printNetworkAsPajek

`MemNetwork_printNetworkAsPajek` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_MemNetwork_printNetworkAsPajek', self, filename, PACKAGE='infomap');
  
}

attr(`MemNetwork_printNetworkAsPajek`, 'returnType') = 'void'
attr(`MemNetwork_printNetworkAsPajek`, "inputTypes") = c('_p_MemNetwork', 'character')
class(`MemNetwork_printNetworkAsPajek`) = c("SWIGFunction", class('MemNetwork_printNetworkAsPajek'))

# Start of MemNetwork_printStateNetwork

`MemNetwork_printStateNetwork` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_MemNetwork_printStateNetwork', self, filename, PACKAGE='infomap');
  
}

attr(`MemNetwork_printStateNetwork`, 'returnType') = 'void'
attr(`MemNetwork_printStateNetwork`, "inputTypes") = c('_p_MemNetwork', 'character')
class(`MemNetwork_printStateNetwork`) = c("SWIGFunction", class('MemNetwork_printStateNetwork'))

# Start of MemNetwork_disposeLinks

`MemNetwork_disposeLinks` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MemNetwork_disposeLinks', self, PACKAGE='infomap');
  
}

attr(`MemNetwork_disposeLinks`, 'returnType') = 'void'
attr(`MemNetwork_disposeLinks`, "inputTypes") = c('_p_MemNetwork')
class(`MemNetwork_disposeLinks`) = c("SWIGFunction", class('MemNetwork_disposeLinks'))

# Start of accessor method for MemNetwork
setMethod('$', '_p_MemNetwork', function(x, name)

{
  accessorFuns = list('Equal' = MemNetwork_Equal, 'readInputData' = MemNetwork_readInputData, 'addStateLink' = MemNetwork_addStateLink, 'addStateNode' = MemNetwork_addStateNode, 'finalizeAndCheckNetwork' = MemNetwork_finalizeAndCheckNetwork, 'printParsingResult' = MemNetwork_printParsingResult, 'numStateNodes' = MemNetwork_numStateNodes, 'stateNodeMap' = MemNetwork_stateNodeMap, 'stateNodeWeights' = MemNetwork_stateNodeWeights, 'totalStateNodeWeight' = MemNetwork_totalStateNodeWeight, 'stateLinkMap' = MemNetwork_stateLinkMap, 'numStateLinks' = MemNetwork_numStateLinks, 'totalStateLinkWeight' = MemNetwork_totalStateLinkWeight, 'totalMemorySelfLinkWeight' = MemNetwork_totalMemorySelfLinkWeight, 'stateNodes' = MemNetwork_stateNodes, 'printNetworkAsPajek' = MemNetwork_printNetworkAsPajek, 'printStateNetwork' = MemNetwork_printStateNetwork, 'disposeLinks' = MemNetwork_disposeLinks);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for MemNetwork
setMethod('delete', '_p_MemNetwork', function(obj) {delete_MemNetwork(obj)})
# Start of new_MultiplexNetwork

`MultiplexNetwork__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_MultiplexNetwork__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_MultiplexNetwork", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_MultiplexNetwork)
  ans
  
}

attr(`MultiplexNetwork__SWIG_0`, 'returnType') = '_p_MultiplexNetwork'
class(`MultiplexNetwork__SWIG_0`) = c("SWIGFunction", class('MultiplexNetwork__SWIG_0'))

# Start of new_MultiplexNetwork

`MultiplexNetwork__SWIG_1` = function(config)
{
  if (inherits(config, "ExternalReference")) config = slot(config,"ref") 
  ;ans = .Call('R_swig_new_MultiplexNetwork__SWIG_1', config, PACKAGE='infomap');
  ans <- new("_p_MultiplexNetwork", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_MultiplexNetwork)
  ans
  
}

attr(`MultiplexNetwork__SWIG_1`, 'returnType') = '_p_MultiplexNetwork'
attr(`MultiplexNetwork__SWIG_1`, "inputTypes") = c('_p_Config')
class(`MultiplexNetwork__SWIG_1`) = c("SWIGFunction", class('MultiplexNetwork__SWIG_1'))

`MultiplexNetwork` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- MultiplexNetwork__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_Config') && length(argv[[1]]) == 1) {
      f <- MultiplexNetwork__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for MultiplexNetwork with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_MultiplexNetwork

`delete_MultiplexNetwork` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_MultiplexNetwork', self, PACKAGE='infomap');
  
}

attr(`delete_MultiplexNetwork`, 'returnType') = 'void'
attr(`delete_MultiplexNetwork`, "inputTypes") = c('_p_MultiplexNetwork')
class(`delete_MultiplexNetwork`) = c("SWIGFunction", class('delete_MultiplexNetwork'))

# Start of MultiplexNetwork_readInputData

`MultiplexNetwork_readInputData__SWIG_0` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filename = as(filename, "character"); 
  ;.Call('R_swig_MultiplexNetwork_readInputData__SWIG_0', self, filename, PACKAGE='infomap');
  
}

attr(`MultiplexNetwork_readInputData__SWIG_0`, 'returnType') = 'void'
attr(`MultiplexNetwork_readInputData__SWIG_0`, "inputTypes") = c('_p_MultiplexNetwork', 'character')
class(`MultiplexNetwork_readInputData__SWIG_0`) = c("SWIGFunction", class('MultiplexNetwork_readInputData__SWIG_0'))

# Start of MultiplexNetwork_readInputData

`MultiplexNetwork_readInputData__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MultiplexNetwork_readInputData__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`MultiplexNetwork_readInputData__SWIG_1`, 'returnType') = 'void'
attr(`MultiplexNetwork_readInputData__SWIG_1`, "inputTypes") = c('_p_MultiplexNetwork')
class(`MultiplexNetwork_readInputData__SWIG_1`) = c("SWIGFunction", class('MultiplexNetwork_readInputData__SWIG_1'))

`MultiplexNetwork_readInputData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_MultiplexNetwork')) {
      f <- MultiplexNetwork_readInputData__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_MultiplexNetwork') && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- MultiplexNetwork_readInputData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MultiplexNetwork_readInputData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MultiplexNetwork_finalizeAndCheckNetwork

`MultiplexNetwork_finalizeAndCheckNetwork__SWIG_0` = function(self, printSummary)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  printSummary = as.logical(printSummary);
  ;.Call('R_swig_MultiplexNetwork_finalizeAndCheckNetwork__SWIG_0', self, printSummary, PACKAGE='infomap');
  
}

attr(`MultiplexNetwork_finalizeAndCheckNetwork__SWIG_0`, 'returnType') = 'void'
attr(`MultiplexNetwork_finalizeAndCheckNetwork__SWIG_0`, "inputTypes") = c('_p_MultiplexNetwork', 'logical')
class(`MultiplexNetwork_finalizeAndCheckNetwork__SWIG_0`) = c("SWIGFunction", class('MultiplexNetwork_finalizeAndCheckNetwork__SWIG_0'))

# Start of MultiplexNetwork_finalizeAndCheckNetwork

`MultiplexNetwork_finalizeAndCheckNetwork__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MultiplexNetwork_finalizeAndCheckNetwork__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`MultiplexNetwork_finalizeAndCheckNetwork__SWIG_1`, 'returnType') = 'void'
attr(`MultiplexNetwork_finalizeAndCheckNetwork__SWIG_1`, "inputTypes") = c('_p_MultiplexNetwork')
class(`MultiplexNetwork_finalizeAndCheckNetwork__SWIG_1`) = c("SWIGFunction", class('MultiplexNetwork_finalizeAndCheckNetwork__SWIG_1'))

`MultiplexNetwork_finalizeAndCheckNetwork` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_MultiplexNetwork')) {
      f <- MultiplexNetwork_finalizeAndCheckNetwork__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_MultiplexNetwork') && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- MultiplexNetwork_finalizeAndCheckNetwork__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MultiplexNetwork_finalizeAndCheckNetwork with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MultiplexNetwork_addMultiplexLink

`MultiplexNetwork_addMultiplexLink` = function(self, layer1, node1, layer2, node2, w)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  layer1 = as.integer(layer1);
  
  if(length(layer1) > 1) {
    warning("using only the first element of layer1");
  };
  
  node1 = as.integer(node1);
  
  if(length(node1) > 1) {
    warning("using only the first element of node1");
  };
  
  layer2 = as.integer(layer2);
  
  if(length(layer2) > 1) {
    warning("using only the first element of layer2");
  };
  
  node2 = as.integer(node2);
  
  if(length(node2) > 1) {
    warning("using only the first element of node2");
  };
  
  
  ;.Call('R_swig_MultiplexNetwork_addMultiplexLink', self, layer1, node1, layer2, node2, w, PACKAGE='infomap');
  
}

attr(`MultiplexNetwork_addMultiplexLink`, 'returnType') = 'void'
attr(`MultiplexNetwork_addMultiplexLink`, "inputTypes") = c('_p_MultiplexNetwork', 'integer', 'integer', 'integer', 'integer', 'numeric')
class(`MultiplexNetwork_addMultiplexLink`) = c("SWIGFunction", class('MultiplexNetwork_addMultiplexLink'))

# Start of MultiplexNetwork_addMemoryNetworkFromMultiplexLinks

`MultiplexNetwork_addMemoryNetworkFromMultiplexLinks` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_MultiplexNetwork_addMemoryNetworkFromMultiplexLinks', self, PACKAGE='infomap');
  
}

attr(`MultiplexNetwork_addMemoryNetworkFromMultiplexLinks`, 'returnType') = 'void'
attr(`MultiplexNetwork_addMemoryNetworkFromMultiplexLinks`, "inputTypes") = c('_p_MultiplexNetwork')
class(`MultiplexNetwork_addMemoryNetworkFromMultiplexLinks`) = c("SWIGFunction", class('MultiplexNetwork_addMemoryNetworkFromMultiplexLinks'))

# Start of accessor method for MultiplexNetwork
setMethod('$', '_p_MultiplexNetwork', function(x, name)

{
  accessorFuns = list('readInputData' = MultiplexNetwork_readInputData, 'finalizeAndCheckNetwork' = MultiplexNetwork_finalizeAndCheckNetwork, 'addMultiplexLink' = MultiplexNetwork_addMultiplexLink, 'addMemoryNetworkFromMultiplexLinks' = MultiplexNetwork_addMemoryNetworkFromMultiplexLinks);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for MultiplexNetwork
setMethod('delete', '_p_MultiplexNetwork', function(obj) {delete_MultiplexNetwork(obj)})
defineEnumeration('_EdgeAggregationPolicy',
                    .values = c(
                        'NONE' = 0, 
                        'PARTIAL' = 1, 
                        'FULL' = 2
))
# Start of new_NodeData

`NodeData__SWIG_0` = function(flow, exitFlow, name)
{
  name = as(name, "character"); 
  ;ans = .Call('R_swig_new_NodeData__SWIG_0', flow, exitFlow, name, PACKAGE='infomap');
  ans <- new("_p_NodeData", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_NodeData)
  ans
  
}

attr(`NodeData__SWIG_0`, 'returnType') = '_p_NodeData'
attr(`NodeData__SWIG_0`, "inputTypes") = c('numeric', 'numeric', 'character')
class(`NodeData__SWIG_0`) = c("SWIGFunction", class('NodeData__SWIG_0'))

# Start of new_NodeData

`NodeData__SWIG_1` = function(flow, exitFlow)
{
  ;ans = .Call('R_swig_new_NodeData__SWIG_1', flow, exitFlow, PACKAGE='infomap');
  ans <- new("_p_NodeData", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_NodeData)
  ans
  
}

attr(`NodeData__SWIG_1`, 'returnType') = '_p_NodeData'
attr(`NodeData__SWIG_1`, "inputTypes") = c('numeric', 'numeric')
class(`NodeData__SWIG_1`) = c("SWIGFunction", class('NodeData__SWIG_1'))

# Start of new_NodeData

`NodeData__SWIG_2` = function(flow)
{
  ;ans = .Call('R_swig_new_NodeData__SWIG_2', flow, PACKAGE='infomap');
  ans <- new("_p_NodeData", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_NodeData)
  ans
  
}

attr(`NodeData__SWIG_2`, 'returnType') = '_p_NodeData'
attr(`NodeData__SWIG_2`, "inputTypes") = c('numeric')
class(`NodeData__SWIG_2`) = c("SWIGFunction", class('NodeData__SWIG_2'))

# Start of new_NodeData

`NodeData__SWIG_3` = function()
{
  ;ans = .Call('R_swig_new_NodeData__SWIG_3', PACKAGE='infomap');
  ans <- new("_p_NodeData", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_NodeData)
  ans
  
}

attr(`NodeData__SWIG_3`, 'returnType') = '_p_NodeData'
class(`NodeData__SWIG_3`) = c("SWIGFunction", class('NodeData__SWIG_3'))

`NodeData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- NodeData__SWIG_3; 
  } else if (argc == 1) {
    if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 )) {
      f <- NodeData__SWIG_2; 
    }
  } else if (argc == 2) {
    if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- NodeData__SWIG_1; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- NodeData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for NodeData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of NodeData_flow_set

`NodeData_flow_set` = function(self, s_flow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_NodeData_flow_set', self, s_flow, PACKAGE='infomap');
  
}

attr(`NodeData_flow_set`, 'returnType') = 'void'
attr(`NodeData_flow_set`, "inputTypes") = c('_p_NodeData', 'numeric')
class(`NodeData_flow_set`) = c("SWIGFunction", class('NodeData_flow_set'))

# Start of NodeData_flow_get

`NodeData_flow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_NodeData_flow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`NodeData_flow_get`, 'returnType') = 'numeric'
attr(`NodeData_flow_get`, "inputTypes") = c('_p_NodeData')
class(`NodeData_flow_get`) = c("SWIGFunction", class('NodeData_flow_get'))

# Start of NodeData_enterFlow_set

`NodeData_enterFlow_set` = function(self, s_enterFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_NodeData_enterFlow_set', self, s_enterFlow, PACKAGE='infomap');
  
}

attr(`NodeData_enterFlow_set`, 'returnType') = 'void'
attr(`NodeData_enterFlow_set`, "inputTypes") = c('_p_NodeData', 'numeric')
class(`NodeData_enterFlow_set`) = c("SWIGFunction", class('NodeData_enterFlow_set'))

# Start of NodeData_enterFlow_get

`NodeData_enterFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_NodeData_enterFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`NodeData_enterFlow_get`, 'returnType') = 'numeric'
attr(`NodeData_enterFlow_get`, "inputTypes") = c('_p_NodeData')
class(`NodeData_enterFlow_get`) = c("SWIGFunction", class('NodeData_enterFlow_get'))

# Start of NodeData_exitFlow_set

`NodeData_exitFlow_set` = function(self, s_exitFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_NodeData_exitFlow_set', self, s_exitFlow, PACKAGE='infomap');
  
}

attr(`NodeData_exitFlow_set`, 'returnType') = 'void'
attr(`NodeData_exitFlow_set`, "inputTypes") = c('_p_NodeData', 'numeric')
class(`NodeData_exitFlow_set`) = c("SWIGFunction", class('NodeData_exitFlow_set'))

# Start of NodeData_exitFlow_get

`NodeData_exitFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_NodeData_exitFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`NodeData_exitFlow_get`, 'returnType') = 'numeric'
attr(`NodeData_exitFlow_get`, "inputTypes") = c('_p_NodeData')
class(`NodeData_exitFlow_get`) = c("SWIGFunction", class('NodeData_exitFlow_get'))

# Start of NodeData_teleportRate_set

`NodeData_teleportRate_set` = function(self, s_teleportRate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_NodeData_teleportRate_set', self, s_teleportRate, PACKAGE='infomap');
  
}

attr(`NodeData_teleportRate_set`, 'returnType') = 'void'
attr(`NodeData_teleportRate_set`, "inputTypes") = c('_p_NodeData', 'numeric')
class(`NodeData_teleportRate_set`) = c("SWIGFunction", class('NodeData_teleportRate_set'))

# Start of NodeData_teleportRate_get

`NodeData_teleportRate_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_NodeData_teleportRate_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`NodeData_teleportRate_get`, 'returnType') = 'numeric'
attr(`NodeData_teleportRate_get`, "inputTypes") = c('_p_NodeData')
class(`NodeData_teleportRate_get`) = c("SWIGFunction", class('NodeData_teleportRate_get'))

# Start of NodeData_danglingFlow_set

`NodeData_danglingFlow_set` = function(self, s_danglingFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_NodeData_danglingFlow_set', self, s_danglingFlow, PACKAGE='infomap');
  
}

attr(`NodeData_danglingFlow_set`, 'returnType') = 'void'
attr(`NodeData_danglingFlow_set`, "inputTypes") = c('_p_NodeData', 'numeric')
class(`NodeData_danglingFlow_set`) = c("SWIGFunction", class('NodeData_danglingFlow_set'))

# Start of NodeData_danglingFlow_get

`NodeData_danglingFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_NodeData_danglingFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`NodeData_danglingFlow_get`, 'returnType') = 'numeric'
attr(`NodeData_danglingFlow_get`, "inputTypes") = c('_p_NodeData')
class(`NodeData_danglingFlow_get`) = c("SWIGFunction", class('NodeData_danglingFlow_get'))

# Start of NodeData_indexCodelength_set

`NodeData_indexCodelength_set` = function(self, s_indexCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_NodeData_indexCodelength_set', self, s_indexCodelength, PACKAGE='infomap');
  
}

attr(`NodeData_indexCodelength_set`, 'returnType') = 'void'
attr(`NodeData_indexCodelength_set`, "inputTypes") = c('_p_NodeData', 'numeric')
class(`NodeData_indexCodelength_set`) = c("SWIGFunction", class('NodeData_indexCodelength_set'))

# Start of NodeData_indexCodelength_get

`NodeData_indexCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_NodeData_indexCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`NodeData_indexCodelength_get`, 'returnType') = 'numeric'
attr(`NodeData_indexCodelength_get`, "inputTypes") = c('_p_NodeData')
class(`NodeData_indexCodelength_get`) = c("SWIGFunction", class('NodeData_indexCodelength_get'))

# Start of NodeData_moduleCodelength_set

`NodeData_moduleCodelength_set` = function(self, s_moduleCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_NodeData_moduleCodelength_set', self, s_moduleCodelength, PACKAGE='infomap');
  
}

attr(`NodeData_moduleCodelength_set`, 'returnType') = 'void'
attr(`NodeData_moduleCodelength_set`, "inputTypes") = c('_p_NodeData', 'numeric')
class(`NodeData_moduleCodelength_set`) = c("SWIGFunction", class('NodeData_moduleCodelength_set'))

# Start of NodeData_moduleCodelength_get

`NodeData_moduleCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_NodeData_moduleCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`NodeData_moduleCodelength_get`, 'returnType') = 'numeric'
attr(`NodeData_moduleCodelength_get`, "inputTypes") = c('_p_NodeData')
class(`NodeData_moduleCodelength_get`) = c("SWIGFunction", class('NodeData_moduleCodelength_get'))

# Start of NodeData_name_set

`NodeData_name_set` = function(self, s_name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_name = as(s_name, "character"); 
  ;.Call('R_swig_NodeData_name_set', self, s_name, PACKAGE='infomap');
  
}

attr(`NodeData_name_set`, 'returnType') = 'void'
attr(`NodeData_name_set`, "inputTypes") = c('_p_NodeData', 'character')
class(`NodeData_name_set`) = c("SWIGFunction", class('NodeData_name_set'))

# Start of NodeData_name_get

`NodeData_name_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_NodeData_name_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`NodeData_name_get`, 'returnType') = 'character'
attr(`NodeData_name_get`, "inputTypes") = c('_p_NodeData')
class(`NodeData_name_get`) = c("SWIGFunction", class('NodeData_name_get'))

# Start of delete_NodeData

`delete_NodeData` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_NodeData', self, PACKAGE='infomap');
  
}

attr(`delete_NodeData`, 'returnType') = 'void'
attr(`delete_NodeData`, "inputTypes") = c('_p_NodeData')
class(`delete_NodeData`) = c("SWIGFunction", class('delete_NodeData'))

# Start of accessor method for NodeData
setMethod('$', '_p_NodeData', function(x, name)

{
  accessorFuns = list('flow' = NodeData_flow_get, 'enterFlow' = NodeData_enterFlow_get, 'exitFlow' = NodeData_exitFlow_get, 'teleportRate' = NodeData_teleportRate_get, 'danglingFlow' = NodeData_danglingFlow_get, 'indexCodelength' = NodeData_indexCodelength_get, 'moduleCodelength' = NodeData_moduleCodelength_get, 'name' = NodeData_name_get);
  vaccessors = c('flow', 'enterFlow', 'exitFlow', 'teleportRate', 'danglingFlow', 'indexCodelength', 'moduleCodelength', 'name');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for NodeData
# Start of accessor method for NodeData
setMethod('$<-', '_p_NodeData', function(x, name, value)

{
  accessorFuns = list('flow' = NodeData_flow_set, 'enterFlow' = NodeData_enterFlow_set, 'exitFlow' = NodeData_exitFlow_set, 'teleportRate' = NodeData_teleportRate_set, 'danglingFlow' = NodeData_danglingFlow_set, 'indexCodelength' = NodeData_indexCodelength_set, 'moduleCodelength' = NodeData_moduleCodelength_set, 'name' = NodeData_name_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_NodeData', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('flow' = NodeData_flow_set, 'enterFlow' = NodeData_enterFlow_set, 'exitFlow' = NodeData_exitFlow_set, 'teleportRate' = NodeData_teleportRate_set, 'danglingFlow' = NodeData_danglingFlow_set, 'indexCodelength' = NodeData_indexCodelength_set, 'moduleCodelength' = NodeData_moduleCodelength_set, 'name' = NodeData_name_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for NodeData
setMethod('delete', '_p_NodeData', function(obj) {delete_NodeData(obj)})
# Start definition of copy functions & methods for NodeData
CopyToR_NodeData = function(value, obj = new("NodeData"))
{
  obj@flow = value$flow;
  obj@enterFlow = value$enterFlow;
  obj@exitFlow = value$exitFlow;
  obj@teleportRate = value$teleportRate;
  obj@danglingFlow = value$danglingFlow;
  obj@indexCodelength = value$indexCodelength;
  obj@moduleCodelength = value$moduleCodelength;
  obj@name = value$name;
  obj;
}



CopyToC_NodeData = function(value, obj)
{
  obj$flow = value@flow;
  obj$enterFlow = value@enterFlow;
  obj$exitFlow = value@exitFlow;
  obj$teleportRate = value@teleportRate;
  obj$danglingFlow = value@danglingFlow;
  obj$indexCodelength = value@indexCodelength;
  obj$moduleCodelength = value@moduleCodelength;
  obj$name = value@name;
  obj
}



# Start definition of copy methods for NodeData
setMethod('copyToR', '_p_NodeData', CopyToR_NodeData);
setMethod('copyToC', 'NodeData', CopyToC_NodeData);

# End definition of copy methods for NodeData
# End definition of copy functions & methods for NodeData
# Start of new_ChildEdge

`ChildEdge` = function(source, target, flow)
{
  source = as.integer(source);
  
  if(length(source) > 1) {
    warning("using only the first element of source");
  };
  
  target = as.integer(target);
  
  if(length(target) > 1) {
    warning("using only the first element of target");
  };
  
  
  ;ans = .Call('R_swig_new_ChildEdge', source, target, flow, PACKAGE='infomap');
  ans <- new("_p_ChildEdge", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ChildEdge)
  ans
  
}

attr(`ChildEdge`, 'returnType') = '_p_ChildEdge'
attr(`ChildEdge`, "inputTypes") = c('integer', 'integer', 'numeric')
class(`ChildEdge`) = c("SWIGFunction", class('ChildEdge'))

# Start of ChildEdge_source_set

`ChildEdge_source_set` = function(self, s_source)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_source = as.integer(s_source);
  
  if(length(s_source) > 1) {
    warning("using only the first element of s_source");
  };
  
  ;.Call('R_swig_ChildEdge_source_set', self, s_source, PACKAGE='infomap');
  
}

attr(`ChildEdge_source_set`, 'returnType') = 'void'
attr(`ChildEdge_source_set`, "inputTypes") = c('_p_ChildEdge', 'integer')
class(`ChildEdge_source_set`) = c("SWIGFunction", class('ChildEdge_source_set'))

# Start of ChildEdge_source_get

`ChildEdge_source_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildEdge_source_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildEdge_source_get`, 'returnType') = 'integer'
attr(`ChildEdge_source_get`, "inputTypes") = c('_p_ChildEdge')
class(`ChildEdge_source_get`) = c("SWIGFunction", class('ChildEdge_source_get'))

# Start of ChildEdge_target_set

`ChildEdge_target_set` = function(self, s_target)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_target = as.integer(s_target);
  
  if(length(s_target) > 1) {
    warning("using only the first element of s_target");
  };
  
  ;.Call('R_swig_ChildEdge_target_set', self, s_target, PACKAGE='infomap');
  
}

attr(`ChildEdge_target_set`, 'returnType') = 'void'
attr(`ChildEdge_target_set`, "inputTypes") = c('_p_ChildEdge', 'integer')
class(`ChildEdge_target_set`) = c("SWIGFunction", class('ChildEdge_target_set'))

# Start of ChildEdge_target_get

`ChildEdge_target_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildEdge_target_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildEdge_target_get`, 'returnType') = 'integer'
attr(`ChildEdge_target_get`, "inputTypes") = c('_p_ChildEdge')
class(`ChildEdge_target_get`) = c("SWIGFunction", class('ChildEdge_target_get'))

# Start of ChildEdge_flow_set

`ChildEdge_flow_set` = function(self, s_flow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_ChildEdge_flow_set', self, s_flow, PACKAGE='infomap');
  
}

attr(`ChildEdge_flow_set`, 'returnType') = 'void'
attr(`ChildEdge_flow_set`, "inputTypes") = c('_p_ChildEdge', 'numeric')
class(`ChildEdge_flow_set`) = c("SWIGFunction", class('ChildEdge_flow_set'))

# Start of ChildEdge_flow_get

`ChildEdge_flow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildEdge_flow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildEdge_flow_get`, 'returnType') = 'numeric'
attr(`ChildEdge_flow_get`, "inputTypes") = c('_p_ChildEdge')
class(`ChildEdge_flow_get`) = c("SWIGFunction", class('ChildEdge_flow_get'))

# Start of delete_ChildEdge

`delete_ChildEdge` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_ChildEdge', self, PACKAGE='infomap');
  
}

attr(`delete_ChildEdge`, 'returnType') = 'void'
attr(`delete_ChildEdge`, "inputTypes") = c('_p_ChildEdge')
class(`delete_ChildEdge`) = c("SWIGFunction", class('delete_ChildEdge'))

# Start of accessor method for ChildEdge
setMethod('$', '_p_ChildEdge', function(x, name)

{
  accessorFuns = list('source' = ChildEdge_source_get, 'target' = ChildEdge_target_get, 'flow' = ChildEdge_flow_get);
  vaccessors = c('source', 'target', 'flow');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ChildEdge
# Start of accessor method for ChildEdge
setMethod('$<-', '_p_ChildEdge', function(x, name, value)

{
  accessorFuns = list('source' = ChildEdge_source_set, 'target' = ChildEdge_target_set, 'flow' = ChildEdge_flow_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ChildEdge', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('source' = ChildEdge_source_set, 'target' = ChildEdge_target_set, 'flow' = ChildEdge_flow_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ChildEdge
setMethod('delete', '_p_ChildEdge', function(obj) {delete_ChildEdge(obj)})
# Start definition of copy functions & methods for ChildEdge
CopyToR_ChildEdge = function(value, obj = new("ChildEdge"))
{
  obj@source = value$source;
  obj@target = value$target;
  obj@flow = value$flow;
  obj;
}



CopyToC_ChildEdge = function(value, obj)
{
  obj$source = value@source;
  obj$target = value@target;
  obj$flow = value@flow;
  obj
}



# Start definition of copy methods for ChildEdge
setMethod('copyToR', '_p_ChildEdge', CopyToR_ChildEdge);
setMethod('copyToC', 'ChildEdge', CopyToC_ChildEdge);

# End definition of copy methods for ChildEdge
# End definition of copy functions & methods for ChildEdge
# Start of EdgeComp_Functor

`EdgeComp_Functor` = function(self, lhs, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(lhs, "ExternalReference")) lhs = slot(lhs,"ref") 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref") 
  ;.Call('R_swig_EdgeComp_Functor', self, lhs, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`EdgeComp_Functor`, 'returnType') = 'logical'
attr(`EdgeComp_Functor`, "inputTypes") = c('_p_EdgeComp', '_p_ChildEdge', '_p_ChildEdge')
class(`EdgeComp_Functor`) = c("SWIGFunction", class('EdgeComp_Functor'))

# Start of new_EdgeComp

`EdgeComp` = function()
{
  ;ans = .Call('R_swig_new_EdgeComp', PACKAGE='infomap');
  ans <- new("_p_EdgeComp", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_EdgeComp)
  ans
  
}

attr(`EdgeComp`, 'returnType') = '_p_EdgeComp'
class(`EdgeComp`) = c("SWIGFunction", class('EdgeComp'))

# Start of delete_EdgeComp

`delete_EdgeComp` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_EdgeComp', self, PACKAGE='infomap');
  
}

attr(`delete_EdgeComp`, 'returnType') = 'void'
attr(`delete_EdgeComp`, "inputTypes") = c('_p_EdgeComp')
class(`delete_EdgeComp`) = c("SWIGFunction", class('delete_EdgeComp'))

# Start of accessor method for EdgeComp
setMethod('$', '_p_EdgeComp', function(x, name)

{
  accessorFuns = list('Functor' = EdgeComp_Functor);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for EdgeComp
setMethod('delete', '_p_EdgeComp', function(obj) {delete_EdgeComp(obj)})
# Start definition of copy functions & methods for EdgeComp
CopyToR_EdgeComp = function(value, obj = new("EdgeComp"))
{
  obj;
}



CopyToC_EdgeComp = function(value, obj)
{
  obj
}



# Start definition of copy methods for EdgeComp
setMethod('copyToR', '_p_EdgeComp', CopyToR_EdgeComp);
setMethod('copyToC', 'EdgeComp', CopyToC_EdgeComp);

# End definition of copy methods for EdgeComp
# End definition of copy functions & methods for EdgeComp
# Start of new_SNode

`SNode__SWIG_0` = function(data, depth, parentIndex, id)
{
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  depth = as.integer(depth);
  
  if(length(depth) > 1) {
    warning("using only the first element of depth");
  };
  
  parentIndex = as.integer(parentIndex);
  
  if(length(parentIndex) > 1) {
    warning("using only the first element of parentIndex");
  };
  
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  ;ans = .Call('R_swig_new_SNode__SWIG_0', data, depth, parentIndex, id, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_SNode)
  ans
  
}

attr(`SNode__SWIG_0`, 'returnType') = '_p_SNode'
attr(`SNode__SWIG_0`, "inputTypes") = c('_p_NodeData', 'integer', 'integer', 'integer')
class(`SNode__SWIG_0`) = c("SWIGFunction", class('SNode__SWIG_0'))

# Start of new_SNode

`SNode__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_SNode__SWIG_1', other, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_SNode)
  ans
  
}

attr(`SNode__SWIG_1`, 'returnType') = '_p_SNode'
attr(`SNode__SWIG_1`, "inputTypes") = c('_p_SNode')
class(`SNode__SWIG_1`) = c("SWIGFunction", class('SNode__SWIG_1'))

`SNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_SNode') && length(argv[[1]]) == 1) {
      f <- SNode__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_NodeData') && length(argv[[1]]) == 1 && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- SNode__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SNode_Equal

`SNode_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_SNode_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`SNode_Equal`, 'returnType') = '_p_SNode'
attr(`SNode_Equal`, "inputTypes") = c('_p_SNode', '_p_SNode')
class(`SNode_Equal`) = c("SWIGFunction", class('SNode_Equal'))

# Start of delete_SNode

`delete_SNode` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_SNode', self, PACKAGE='infomap');
  
}

attr(`delete_SNode`, 'returnType') = 'void'
attr(`delete_SNode`, "inputTypes") = c('_p_SNode')
class(`delete_SNode`) = c("SWIGFunction", class('delete_SNode'))

# Start of SNode_childDegree

`SNode_childDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_childDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_childDegree`, 'returnType') = 'integer'
attr(`SNode_childDegree`, "inputTypes") = c('_p_SNode')
class(`SNode_childDegree`) = c("SWIGFunction", class('SNode_childDegree'))

# Start of SNode_clear

`SNode_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_clear', self, PACKAGE='infomap');
  
}

attr(`SNode_clear`, 'returnType') = 'void'
attr(`SNode_clear`, "inputTypes") = c('_p_SNode')
class(`SNode_clear`) = c("SWIGFunction", class('SNode_clear'))

# Start of SNode_addChild

`SNode_addChild` = function(self, child)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(child, "ExternalReference")) child = slot(child,"ref") 
  ;.Call('R_swig_SNode_addChild', self, child, PACKAGE='infomap');
  
}

attr(`SNode_addChild`, 'returnType') = 'void'
attr(`SNode_addChild`, "inputTypes") = c('_p_SNode', '_p_SNode')
class(`SNode_addChild`) = c("SWIGFunction", class('SNode_addChild'))

# Start of SNode_numSerializableChildEdges

`SNode_numSerializableChildEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_numSerializableChildEdges', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_numSerializableChildEdges`, 'returnType') = 'integer'
attr(`SNode_numSerializableChildEdges`, "inputTypes") = c('_p_SNode')
class(`SNode_numSerializableChildEdges`) = c("SWIGFunction", class('SNode_numSerializableChildEdges'))

# Start of SNode_printState

`SNode_printState__SWIG_0` = function(self, indexOffset, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  indexOffset = as.integer(indexOffset);
  
  if(length(indexOffset) > 1) {
    warning("using only the first element of indexOffset");
  };
  
  ;.Call('R_swig_SNode_printState__SWIG_0', self, indexOffset, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_printState__SWIG_0`, 'returnType') = 'character'
attr(`SNode_printState__SWIG_0`, "inputTypes") = c('_p_SNode', 'integer')
class(`SNode_printState__SWIG_0`) = c("SWIGFunction", class('SNode_printState__SWIG_0'))

# Start of SNode_printState

`SNode_printState__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_printState__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_printState__SWIG_1`, 'returnType') = 'character'
attr(`SNode_printState__SWIG_1`, "inputTypes") = c('_p_SNode')
class(`SNode_printState__SWIG_1`) = c("SWIGFunction", class('SNode_printState__SWIG_1'))

`SNode_printState` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_SNode')) {
      f <- SNode_printState__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_SNode') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- SNode_printState__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SNode_printState with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SNode_data_set

`SNode_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_SNode_data_set', self, s_data, PACKAGE='infomap');
  
}

attr(`SNode_data_set`, 'returnType') = 'void'
attr(`SNode_data_set`, "inputTypes") = c('_p_SNode', '_p_NodeData')
class(`SNode_data_set`) = c("SWIGFunction", class('SNode_data_set'))

# Start of SNode_data_get

`SNode_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_SNode_data_get', self, PACKAGE='infomap');
  ans <- new("_p_NodeData", ref=ans) ;
  
  ans
  
}

attr(`SNode_data_get`, 'returnType') = '_p_NodeData'
attr(`SNode_data_get`, "inputTypes") = c('_p_SNode')
class(`SNode_data_get`) = c("SWIGFunction", class('SNode_data_get'))

# Start of SNode_depth_set

`SNode_depth_set` = function(self, s_depth)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_depth = as.integer(s_depth);
  
  if(length(s_depth) > 1) {
    warning("using only the first element of s_depth");
  };
  
  ;.Call('R_swig_SNode_depth_set', self, s_depth, PACKAGE='infomap');
  
}

attr(`SNode_depth_set`, 'returnType') = 'void'
attr(`SNode_depth_set`, "inputTypes") = c('_p_SNode', 'integer')
class(`SNode_depth_set`) = c("SWIGFunction", class('SNode_depth_set'))

# Start of SNode_depth_get

`SNode_depth_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_depth_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_depth_get`, 'returnType') = 'integer'
attr(`SNode_depth_get`, "inputTypes") = c('_p_SNode')
class(`SNode_depth_get`) = c("SWIGFunction", class('SNode_depth_get'))

# Start of SNode_depthBelow_set

`SNode_depthBelow_set` = function(self, s_depthBelow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_depthBelow = as.integer(s_depthBelow);
  
  if(length(s_depthBelow) > 1) {
    warning("using only the first element of s_depthBelow");
  };
  
  ;.Call('R_swig_SNode_depthBelow_set', self, s_depthBelow, PACKAGE='infomap');
  
}

attr(`SNode_depthBelow_set`, 'returnType') = 'void'
attr(`SNode_depthBelow_set`, "inputTypes") = c('_p_SNode', 'integer')
class(`SNode_depthBelow_set`) = c("SWIGFunction", class('SNode_depthBelow_set'))

# Start of SNode_depthBelow_get

`SNode_depthBelow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_depthBelow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_depthBelow_get`, 'returnType') = 'integer'
attr(`SNode_depthBelow_get`, "inputTypes") = c('_p_SNode')
class(`SNode_depthBelow_get`) = c("SWIGFunction", class('SNode_depthBelow_get'))

# Start of SNode_parentNode_set

`SNode_parentNode_set` = function(self, s_parentNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_parentNode, "ExternalReference")) s_parentNode = slot(s_parentNode,"ref") 
  ;.Call('R_swig_SNode_parentNode_set', self, s_parentNode, PACKAGE='infomap');
  
}

attr(`SNode_parentNode_set`, 'returnType') = 'void'
attr(`SNode_parentNode_set`, "inputTypes") = c('_p_SNode', '_p_SNode')
class(`SNode_parentNode_set`) = c("SWIGFunction", class('SNode_parentNode_set'))

# Start of SNode_parentNode_get

`SNode_parentNode_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_SNode_parentNode_get', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`SNode_parentNode_get`, 'returnType') = '_p_SNode'
attr(`SNode_parentNode_get`, "inputTypes") = c('_p_SNode')
class(`SNode_parentNode_get`) = c("SWIGFunction", class('SNode_parentNode_get'))

# Start of SNode_parentIndex_set

`SNode_parentIndex_set` = function(self, s_parentIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_parentIndex = as.integer(s_parentIndex);
  
  if(length(s_parentIndex) > 1) {
    warning("using only the first element of s_parentIndex");
  };
  
  ;.Call('R_swig_SNode_parentIndex_set', self, s_parentIndex, PACKAGE='infomap');
  
}

attr(`SNode_parentIndex_set`, 'returnType') = 'void'
attr(`SNode_parentIndex_set`, "inputTypes") = c('_p_SNode', 'integer')
class(`SNode_parentIndex_set`) = c("SWIGFunction", class('SNode_parentIndex_set'))

# Start of SNode_parentIndex_get

`SNode_parentIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_parentIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_parentIndex_get`, 'returnType') = 'integer'
attr(`SNode_parentIndex_get`, "inputTypes") = c('_p_SNode')
class(`SNode_parentIndex_get`) = c("SWIGFunction", class('SNode_parentIndex_get'))

# Start of SNode_isLeaf_set

`SNode_isLeaf_set` = function(self, s_isLeaf)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_isLeaf = as.logical(s_isLeaf);
  ;.Call('R_swig_SNode_isLeaf_set', self, s_isLeaf, PACKAGE='infomap');
  
}

attr(`SNode_isLeaf_set`, 'returnType') = 'void'
attr(`SNode_isLeaf_set`, "inputTypes") = c('_p_SNode', 'logical')
class(`SNode_isLeaf_set`) = c("SWIGFunction", class('SNode_isLeaf_set'))

# Start of SNode_isLeaf_get

`SNode_isLeaf_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_isLeaf_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_isLeaf_get`, 'returnType') = 'logical'
attr(`SNode_isLeaf_get`, "inputTypes") = c('_p_SNode')
class(`SNode_isLeaf_get`) = c("SWIGFunction", class('SNode_isLeaf_get'))

# Start of SNode_originalLeafIndex_set

`SNode_originalLeafIndex_set` = function(self, s_originalLeafIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_originalLeafIndex = as.integer(s_originalLeafIndex);
  
  if(length(s_originalLeafIndex) > 1) {
    warning("using only the first element of s_originalLeafIndex");
  };
  
  ;.Call('R_swig_SNode_originalLeafIndex_set', self, s_originalLeafIndex, PACKAGE='infomap');
  
}

attr(`SNode_originalLeafIndex_set`, 'returnType') = 'void'
attr(`SNode_originalLeafIndex_set`, "inputTypes") = c('_p_SNode', 'integer')
class(`SNode_originalLeafIndex_set`) = c("SWIGFunction", class('SNode_originalLeafIndex_set'))

# Start of SNode_originalLeafIndex_get

`SNode_originalLeafIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_originalLeafIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_originalLeafIndex_get`, 'returnType') = 'integer'
attr(`SNode_originalLeafIndex_get`, "inputTypes") = c('_p_SNode')
class(`SNode_originalLeafIndex_get`) = c("SWIGFunction", class('SNode_originalLeafIndex_get'))

# Start of SNode_id_set

`SNode_id_set` = function(self, s_id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_id = as.integer(s_id);
  
  if(length(s_id) > 1) {
    warning("using only the first element of s_id");
  };
  
  ;.Call('R_swig_SNode_id_set', self, s_id, PACKAGE='infomap');
  
}

attr(`SNode_id_set`, 'returnType') = 'void'
attr(`SNode_id_set`, "inputTypes") = c('_p_SNode', 'integer')
class(`SNode_id_set`) = c("SWIGFunction", class('SNode_id_set'))

# Start of SNode_id_get

`SNode_id_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_id_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_id_get`, 'returnType') = 'integer'
attr(`SNode_id_get`, "inputTypes") = c('_p_SNode')
class(`SNode_id_get`) = c("SWIGFunction", class('SNode_id_get'))

# Start of SNode_children_set

`SNode_children_set` = function(self, s_children)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_children, "ExternalReference")) s_children = slot(s_children,"ref") 
  ;.Call('R_swig_SNode_children_set', self, s_children, PACKAGE='infomap');
  
}

attr(`SNode_children_set`, 'returnType') = 'void'
attr(`SNode_children_set`, "inputTypes") = c('_p_SNode', '_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t')
class(`SNode_children_set`) = c("SWIGFunction", class('SNode_children_set'))

# Start of SNode_children_get

`SNode_children_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_SNode_children_get', self, PACKAGE='infomap');
  ans <- new("_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t", ref=ans) ;
  
  ans
  
}

attr(`SNode_children_get`, 'returnType') = '_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t'
attr(`SNode_children_get`, "inputTypes") = c('_p_SNode')
class(`SNode_children_get`) = c("SWIGFunction", class('SNode_children_get'))

# Start of SNode_childEdges_set

`SNode_childEdges_set` = function(self, s_childEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_childEdges, "ExternalReference")) s_childEdges = slot(s_childEdges,"ref") 
  ;.Call('R_swig_SNode_childEdges_set', self, s_childEdges, PACKAGE='infomap');
  
}

attr(`SNode_childEdges_set`, 'returnType') = 'void'
attr(`SNode_childEdges_set`, "inputTypes") = c('_p_SNode', '_p_std__setT_ChildEdge_EdgeComp_t')
class(`SNode_childEdges_set`) = c("SWIGFunction", class('SNode_childEdges_set'))

# Start of SNode_childEdges_get

`SNode_childEdges_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_SNode_childEdges_get', self, PACKAGE='infomap');
  ans <- new("_p_std__setT_ChildEdge_EdgeComp_t", ref=ans) ;
  
  ans
  
}

attr(`SNode_childEdges_get`, 'returnType') = '_p_std__setT_ChildEdge_EdgeComp_t'
attr(`SNode_childEdges_get`, "inputTypes") = c('_p_SNode')
class(`SNode_childEdges_get`) = c("SWIGFunction", class('SNode_childEdges_get'))

# Start of SNode_skip_set

`SNode_skip_set` = function(self, s_skip)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_skip = as.logical(s_skip);
  ;.Call('R_swig_SNode_skip_set', self, s_skip, PACKAGE='infomap');
  
}

attr(`SNode_skip_set`, 'returnType') = 'void'
attr(`SNode_skip_set`, "inputTypes") = c('_p_SNode', 'logical')
class(`SNode_skip_set`) = c("SWIGFunction", class('SNode_skip_set'))

# Start of SNode_skip_get

`SNode_skip_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_skip_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_skip_get`, 'returnType') = 'logical'
attr(`SNode_skip_get`, "inputTypes") = c('_p_SNode')
class(`SNode_skip_get`) = c("SWIGFunction", class('SNode_skip_get'))

# Start of SNode_isMemoryNode_set

`SNode_isMemoryNode_set` = function(self, s_isMemoryNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_isMemoryNode = as.logical(s_isMemoryNode);
  ;.Call('R_swig_SNode_isMemoryNode_set', self, s_isMemoryNode, PACKAGE='infomap');
  
}

attr(`SNode_isMemoryNode_set`, 'returnType') = 'void'
attr(`SNode_isMemoryNode_set`, "inputTypes") = c('_p_SNode', 'logical')
class(`SNode_isMemoryNode_set`) = c("SWIGFunction", class('SNode_isMemoryNode_set'))

# Start of SNode_isMemoryNode_get

`SNode_isMemoryNode_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_isMemoryNode_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_isMemoryNode_get`, 'returnType') = 'logical'
attr(`SNode_isMemoryNode_get`, "inputTypes") = c('_p_SNode')
class(`SNode_isMemoryNode_get`) = c("SWIGFunction", class('SNode_isMemoryNode_get'))

# Start of SNode_stateIndex_set

`SNode_stateIndex_set` = function(self, s_stateIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_stateIndex = as.integer(s_stateIndex);
  
  if(length(s_stateIndex) > 1) {
    warning("using only the first element of s_stateIndex");
  };
  
  ;.Call('R_swig_SNode_stateIndex_set', self, s_stateIndex, PACKAGE='infomap');
  
}

attr(`SNode_stateIndex_set`, 'returnType') = 'void'
attr(`SNode_stateIndex_set`, "inputTypes") = c('_p_SNode', 'integer')
class(`SNode_stateIndex_set`) = c("SWIGFunction", class('SNode_stateIndex_set'))

# Start of SNode_stateIndex_get

`SNode_stateIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_stateIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_stateIndex_get`, 'returnType') = 'integer'
attr(`SNode_stateIndex_get`, "inputTypes") = c('_p_SNode')
class(`SNode_stateIndex_get`) = c("SWIGFunction", class('SNode_stateIndex_get'))

# Start of SNode_physIndex_set

`SNode_physIndex_set` = function(self, s_physIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_physIndex = as.integer(s_physIndex);
  
  if(length(s_physIndex) > 1) {
    warning("using only the first element of s_physIndex");
  };
  
  ;.Call('R_swig_SNode_physIndex_set', self, s_physIndex, PACKAGE='infomap');
  
}

attr(`SNode_physIndex_set`, 'returnType') = 'void'
attr(`SNode_physIndex_set`, "inputTypes") = c('_p_SNode', 'integer')
class(`SNode_physIndex_set`) = c("SWIGFunction", class('SNode_physIndex_set'))

# Start of SNode_physIndex_get

`SNode_physIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_physIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_physIndex_get`, 'returnType') = 'integer'
attr(`SNode_physIndex_get`, "inputTypes") = c('_p_SNode')
class(`SNode_physIndex_get`) = c("SWIGFunction", class('SNode_physIndex_get'))

# Start of SNode_serializationSize

`SNode_serializationSize` = function(self, writeEdges, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_SNode_serializationSize', self, writeEdges, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_serializationSize`, 'returnType') = 'integer'
attr(`SNode_serializationSize`, "inputTypes") = c('_p_SNode', 'logical')
class(`SNode_serializationSize`) = c("SWIGFunction", class('SNode_serializationSize'))

# Start of SNode_serialize

`SNode_serialize` = function(self, outFile, childPosition, writeEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(outFile, "ExternalReference")) outFile = slot(outFile,"ref") 
  childPosition = as.integer(childPosition);
  
  if(length(childPosition) > 1) {
    warning("using only the first element of childPosition");
  };
  
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_SNode_serialize', self, outFile, childPosition, writeEdges, PACKAGE='infomap');
  
}

attr(`SNode_serialize`, 'returnType') = 'void'
attr(`SNode_serialize`, "inputTypes") = c('_p_SNode', '_p_SafeBinaryOutFile', 'integer', 'logical')
class(`SNode_serialize`) = c("SWIGFunction", class('SNode_serialize'))

# Start of SNode_deserialize

`SNode_deserialize` = function(self, dataStream, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dataStream, "ExternalReference")) dataStream = slot(dataStream,"ref") 
  ;.Call('R_swig_SNode_deserialize', self, dataStream, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_deserialize`, 'returnType') = 'integer'
attr(`SNode_deserialize`, "inputTypes") = c('_p_SNode', '_p_SafeBinaryInFile')
class(`SNode_deserialize`) = c("SWIGFunction", class('SNode_deserialize'))

# Start of SNode_deserializeEdges

`SNode_deserializeEdges` = function(self, dataStream, directedEdges, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dataStream, "ExternalReference")) dataStream = slot(dataStream,"ref") 
  directedEdges = as.logical(directedEdges);
  ;.Call('R_swig_SNode_deserializeEdges', self, dataStream, directedEdges, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_deserializeEdges`, 'returnType') = 'integer'
attr(`SNode_deserializeEdges`, "inputTypes") = c('_p_SNode', '_p_SafeBinaryInFile', 'logical')
class(`SNode_deserializeEdges`) = c("SWIGFunction", class('SNode_deserializeEdges'))

# Start of SNode_lastChild

`SNode_lastChild` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_SNode_lastChild', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`SNode_lastChild`, 'returnType') = '_p_SNode'
attr(`SNode_lastChild`, "inputTypes") = c('_p_SNode')
class(`SNode_lastChild`) = c("SWIGFunction", class('SNode_lastChild'))

# Start of SNode_firstChild

`SNode_firstChild` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_SNode_firstChild', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`SNode_firstChild`, 'returnType') = '_p_SNode'
attr(`SNode_firstChild`, "inputTypes") = c('_p_SNode')
class(`SNode_firstChild`) = c("SWIGFunction", class('SNode_firstChild'))

# Start of SNode_nextSibling

`SNode_nextSibling` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_SNode_nextSibling', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`SNode_nextSibling`, 'returnType') = '_p_SNode'
attr(`SNode_nextSibling`, "inputTypes") = c('_p_SNode')
class(`SNode_nextSibling`) = c("SWIGFunction", class('SNode_nextSibling'))

# Start of SNode_isLeafNode

`SNode_isLeafNode` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_isLeafNode', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_isLeafNode`, 'returnType') = 'logical'
attr(`SNode_isLeafNode`, "inputTypes") = c('_p_SNode')
class(`SNode_isLeafNode`) = c("SWIGFunction", class('SNode_isLeafNode'))

# Start of SNode_isLeafModule

`SNode_isLeafModule` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SNode_isLeafModule', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_isLeafModule`, 'returnType') = 'logical'
attr(`SNode_isLeafModule`, "inputTypes") = c('_p_SNode')
class(`SNode_isLeafModule`) = c("SWIGFunction", class('SNode_isLeafModule'))

# Start of SNode_createChildEdge

`SNode_createChildEdge` = function(self, sourceIndex, targetIndex, flow, directed, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  sourceIndex = as.integer(sourceIndex);
  
  if(length(sourceIndex) > 1) {
    warning("using only the first element of sourceIndex");
  };
  
  targetIndex = as.integer(targetIndex);
  
  if(length(targetIndex) > 1) {
    warning("using only the first element of targetIndex");
  };
  
  
  directed = as.logical(directed);
  ;.Call('R_swig_SNode_createChildEdge', self, sourceIndex, targetIndex, flow, directed, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`SNode_createChildEdge`, 'returnType') = 'logical'
attr(`SNode_createChildEdge`, "inputTypes") = c('_p_SNode', 'integer', 'integer', 'numeric', 'logical')
class(`SNode_createChildEdge`) = c("SWIGFunction", class('SNode_createChildEdge'))

# Start of accessor method for SNode
setMethod('$', '_p_SNode', function(x, name)

{
  accessorFuns = list('Equal' = SNode_Equal, 'childDegree' = SNode_childDegree, 'clear' = SNode_clear, 'addChild' = SNode_addChild, 'numSerializableChildEdges' = SNode_numSerializableChildEdges, 'printState' = SNode_printState, 'data' = SNode_data_get, 'depth' = SNode_depth_get, 'depthBelow' = SNode_depthBelow_get, 'parentNode' = SNode_parentNode_get, 'parentIndex' = SNode_parentIndex_get, 'isLeaf' = SNode_isLeaf_get, 'originalLeafIndex' = SNode_originalLeafIndex_get, 'id' = SNode_id_get, 'children' = SNode_children_get, 'childEdges' = SNode_childEdges_get, 'skip' = SNode_skip_get, 'isMemoryNode' = SNode_isMemoryNode_get, 'stateIndex' = SNode_stateIndex_get, 'physIndex' = SNode_physIndex_get, 'serializationSize' = SNode_serializationSize, 'serialize' = SNode_serialize, 'deserialize' = SNode_deserialize, 'deserializeEdges' = SNode_deserializeEdges, 'lastChild' = SNode_lastChild, 'firstChild' = SNode_firstChild, 'nextSibling' = SNode_nextSibling, 'isLeafNode' = SNode_isLeafNode, 'isLeafModule' = SNode_isLeafModule, 'createChildEdge' = SNode_createChildEdge);
  vaccessors = c('data', 'depth', 'depthBelow', 'parentNode', 'parentIndex', 'isLeaf', 'originalLeafIndex', 'id', 'children', 'childEdges', 'skip', 'isMemoryNode', 'stateIndex', 'physIndex');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for SNode
# Start of accessor method for SNode
setMethod('$<-', '_p_SNode', function(x, name, value)

{
  accessorFuns = list('data' = SNode_data_set, 'depth' = SNode_depth_set, 'depthBelow' = SNode_depthBelow_set, 'parentNode' = SNode_parentNode_set, 'parentIndex' = SNode_parentIndex_set, 'isLeaf' = SNode_isLeaf_set, 'originalLeafIndex' = SNode_originalLeafIndex_set, 'id' = SNode_id_set, 'children' = SNode_children_set, 'childEdges' = SNode_childEdges_set, 'skip' = SNode_skip_set, 'isMemoryNode' = SNode_isMemoryNode_set, 'stateIndex' = SNode_stateIndex_set, 'physIndex' = SNode_physIndex_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_SNode', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = SNode_data_set, 'depth' = SNode_depth_set, 'depthBelow' = SNode_depthBelow_set, 'parentNode' = SNode_parentNode_set, 'parentIndex' = SNode_parentIndex_set, 'isLeaf' = SNode_isLeaf_set, 'originalLeafIndex' = SNode_originalLeafIndex_set, 'id' = SNode_id_set, 'children' = SNode_children_set, 'childEdges' = SNode_childEdges_set, 'skip' = SNode_skip_set, 'isMemoryNode' = SNode_isMemoryNode_set, 'stateIndex' = SNode_stateIndex_set, 'physIndex' = SNode_physIndex_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for SNode
setMethod('delete', '_p_SNode', function(obj) {delete_SNode(obj)})
# Start of new_LeafIterator

`LeafIterator__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_LeafIterator__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_LeafIterator)
  ans
  
}

attr(`LeafIterator__SWIG_0`, 'returnType') = '_p_LeafIterator'
class(`LeafIterator__SWIG_0`) = c("SWIGFunction", class('LeafIterator__SWIG_0'))

# Start of new_LeafIterator

`LeafIterator__SWIG_1` = function(nodePointer, moduleIndexDepth)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref") 
  moduleIndexDepth = as.integer(moduleIndexDepth);
  
  if(length(moduleIndexDepth) > 1) {
    warning("using only the first element of moduleIndexDepth");
  };
  
  ;ans = .Call('R_swig_new_LeafIterator__SWIG_1', nodePointer, moduleIndexDepth, PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_LeafIterator)
  ans
  
}

attr(`LeafIterator__SWIG_1`, 'returnType') = '_p_LeafIterator'
attr(`LeafIterator__SWIG_1`, "inputTypes") = c('_p_SNode', 'integer')
class(`LeafIterator__SWIG_1`) = c("SWIGFunction", class('LeafIterator__SWIG_1'))

# Start of new_LeafIterator

`LeafIterator__SWIG_2` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref") 
  ;ans = .Call('R_swig_new_LeafIterator__SWIG_2', nodePointer, PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_LeafIterator)
  ans
  
}

attr(`LeafIterator__SWIG_2`, 'returnType') = '_p_LeafIterator'
attr(`LeafIterator__SWIG_2`, "inputTypes") = c('_p_SNode')
class(`LeafIterator__SWIG_2`) = c("SWIGFunction", class('LeafIterator__SWIG_2'))

# Start of new_LeafIterator

`LeafIterator__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_LeafIterator__SWIG_3', other, PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_LeafIterator)
  ans
  
}

attr(`LeafIterator__SWIG_3`, 'returnType') = '_p_LeafIterator'
attr(`LeafIterator__SWIG_3`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator__SWIG_3`) = c("SWIGFunction", class('LeafIterator__SWIG_3'))

`LeafIterator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- LeafIterator__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_SNode')) {
      f <- LeafIterator__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_LeafIterator') && length(argv[[1]]) == 1) {
      f <- LeafIterator__SWIG_3; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_SNode') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- LeafIterator__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for LeafIterator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LeafIterator_Equal

`LeafIterator_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_LeafIterator_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_Equal`, 'returnType') = '_p_LeafIterator'
attr(`LeafIterator_Equal`, "inputTypes") = c('_p_LeafIterator', '_p_LeafIterator')
class(`LeafIterator_Equal`) = c("SWIGFunction", class('LeafIterator_Equal'))

# Start of LeafIterator_base

`LeafIterator_base` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_base', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_base`, 'returnType') = '_p_SNode'
attr(`LeafIterator_base`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_base`) = c("SWIGFunction", class('LeafIterator_base'))

# Start of LeafIterator_isEnd

`LeafIterator_isEnd` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_isEnd', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_isEnd`, 'returnType') = 'logical'
attr(`LeafIterator_isEnd`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_isEnd`) = c("SWIGFunction", class('LeafIterator_isEnd'))

# Start of LeafIterator___ref__

`LeafIterator___ref__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator___ref__', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator___ref__`, 'returnType') = '_p_SNode'
attr(`LeafIterator___ref__`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator___ref__`) = c("SWIGFunction", class('LeafIterator___ref__'))

# Start of LeafIterator___deref__

`LeafIterator___deref__` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator___deref__', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator___deref__`, 'returnType') = '_p_SNode'
attr(`LeafIterator___deref__`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator___deref__`) = c("SWIGFunction", class('LeafIterator___deref__'))

# Start of LeafIterator_PlusPlusPrefix

`LeafIterator_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_PlusPlusPrefix`, 'returnType') = '_p_LeafIterator'
attr(`LeafIterator_PlusPlusPrefix`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_PlusPlusPrefix`) = c("SWIGFunction", class('LeafIterator_PlusPlusPrefix'))

# Start of LeafIterator_PlusPlusPostfix

`LeafIterator_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_LeafIterator_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans);
  
  ans
  
}

attr(`LeafIterator_PlusPlusPostfix`, 'returnType') = '_p_LeafIterator'
attr(`LeafIterator_PlusPlusPostfix`, "inputTypes") = c('_p_LeafIterator', 'integer')
class(`LeafIterator_PlusPlusPostfix`) = c("SWIGFunction", class('LeafIterator_PlusPlusPostfix'))

# Start of LeafIterator_stepForward

`LeafIterator_stepForward` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_stepForward', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_stepForward`, 'returnType') = '_p_LeafIterator'
attr(`LeafIterator_stepForward`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_stepForward`) = c("SWIGFunction", class('LeafIterator_stepForward'))

# Start of LeafIterator_depth

`LeafIterator_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_depth`, 'returnType') = 'integer'
attr(`LeafIterator_depth`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_depth`) = c("SWIGFunction", class('LeafIterator_depth'))

# Start of LeafIterator_moduleIndex

`LeafIterator_moduleIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_moduleIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_moduleIndex`, 'returnType') = 'integer'
attr(`LeafIterator_moduleIndex`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_moduleIndex`) = c("SWIGFunction", class('LeafIterator_moduleIndex'))

# Start of LeafIterator_EqualEqual

`LeafIterator_EqualEqual` = function(self, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref") 
  ;.Call('R_swig_LeafIterator_EqualEqual', self, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_EqualEqual`, 'returnType') = 'logical'
attr(`LeafIterator_EqualEqual`, "inputTypes") = c('_p_LeafIterator', '_p_LeafIterator')
class(`LeafIterator_EqualEqual`) = c("SWIGFunction", class('LeafIterator_EqualEqual'))

# Start of LeafIterator_NotEqual

`LeafIterator_NotEqual` = function(self, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref") 
  ;.Call('R_swig_LeafIterator_NotEqual', self, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_NotEqual`, 'returnType') = 'logical'
attr(`LeafIterator_NotEqual`, "inputTypes") = c('_p_LeafIterator', '_p_LeafIterator')
class(`LeafIterator_NotEqual`) = c("SWIGFunction", class('LeafIterator_NotEqual'))

# Start of delete_LeafIterator

`delete_LeafIterator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_LeafIterator', self, PACKAGE='infomap');
  
}

attr(`delete_LeafIterator`, 'returnType') = 'void'
attr(`delete_LeafIterator`, "inputTypes") = c('_p_LeafIterator')
class(`delete_LeafIterator`) = c("SWIGFunction", class('delete_LeafIterator'))

# Start of LeafIterator_childDegree

`LeafIterator_childDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_childDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_childDegree`, 'returnType') = 'integer'
attr(`LeafIterator_childDegree`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_childDegree`) = c("SWIGFunction", class('LeafIterator_childDegree'))

# Start of LeafIterator_clear

`LeafIterator_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_clear', self, PACKAGE='infomap');
  
}

attr(`LeafIterator_clear`, 'returnType') = 'void'
attr(`LeafIterator_clear`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_clear`) = c("SWIGFunction", class('LeafIterator_clear'))

# Start of LeafIterator_addChild

`LeafIterator_addChild` = function(self, child)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(child, "ExternalReference")) child = slot(child,"ref") 
  ;.Call('R_swig_LeafIterator_addChild', self, child, PACKAGE='infomap');
  
}

attr(`LeafIterator_addChild`, 'returnType') = 'void'
attr(`LeafIterator_addChild`, "inputTypes") = c('_p_LeafIterator', '_p_SNode')
class(`LeafIterator_addChild`) = c("SWIGFunction", class('LeafIterator_addChild'))

# Start of LeafIterator_numSerializableChildEdges

`LeafIterator_numSerializableChildEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_numSerializableChildEdges', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_numSerializableChildEdges`, 'returnType') = 'integer'
attr(`LeafIterator_numSerializableChildEdges`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_numSerializableChildEdges`) = c("SWIGFunction", class('LeafIterator_numSerializableChildEdges'))

# Start of LeafIterator_printState

`LeafIterator_printState__SWIG_0` = function(self, indexOffset, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  indexOffset = as.integer(indexOffset);
  
  if(length(indexOffset) > 1) {
    warning("using only the first element of indexOffset");
  };
  
  ;.Call('R_swig_LeafIterator_printState__SWIG_0', self, indexOffset, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_printState__SWIG_0`, 'returnType') = 'character'
attr(`LeafIterator_printState__SWIG_0`, "inputTypes") = c('_p_LeafIterator', 'integer')
class(`LeafIterator_printState__SWIG_0`) = c("SWIGFunction", class('LeafIterator_printState__SWIG_0'))

# Start of LeafIterator_printState

`LeafIterator_printState__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_printState__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_printState__SWIG_1`, 'returnType') = 'character'
attr(`LeafIterator_printState__SWIG_1`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_printState__SWIG_1`) = c("SWIGFunction", class('LeafIterator_printState__SWIG_1'))

`LeafIterator_printState` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_LeafIterator')) {
      f <- LeafIterator_printState__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_LeafIterator') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- LeafIterator_printState__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LeafIterator_printState with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LeafIterator_data_set

`LeafIterator_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_LeafIterator_data_set', self, s_data, PACKAGE='infomap');
  
}

attr(`LeafIterator_data_set`, 'returnType') = 'void'
attr(`LeafIterator_data_set`, "inputTypes") = c('_p_LeafIterator', '_p_NodeData')
class(`LeafIterator_data_set`) = c("SWIGFunction", class('LeafIterator_data_set'))

# Start of LeafIterator_data_get

`LeafIterator_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_data_get', self, PACKAGE='infomap');
  ans <- new("_p_NodeData", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_data_get`, 'returnType') = '_p_NodeData'
attr(`LeafIterator_data_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_data_get`) = c("SWIGFunction", class('LeafIterator_data_get'))

# Start of LeafIterator_depthBelow_set

`LeafIterator_depthBelow_set` = function(self, s_depthBelow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_depthBelow = as.integer(s_depthBelow);
  
  if(length(s_depthBelow) > 1) {
    warning("using only the first element of s_depthBelow");
  };
  
  ;.Call('R_swig_LeafIterator_depthBelow_set', self, s_depthBelow, PACKAGE='infomap');
  
}

attr(`LeafIterator_depthBelow_set`, 'returnType') = 'void'
attr(`LeafIterator_depthBelow_set`, "inputTypes") = c('_p_LeafIterator', 'integer')
class(`LeafIterator_depthBelow_set`) = c("SWIGFunction", class('LeafIterator_depthBelow_set'))

# Start of LeafIterator_depthBelow_get

`LeafIterator_depthBelow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_depthBelow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_depthBelow_get`, 'returnType') = 'integer'
attr(`LeafIterator_depthBelow_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_depthBelow_get`) = c("SWIGFunction", class('LeafIterator_depthBelow_get'))

# Start of LeafIterator_parentNode_set

`LeafIterator_parentNode_set` = function(self, s_parentNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_parentNode, "ExternalReference")) s_parentNode = slot(s_parentNode,"ref") 
  ;.Call('R_swig_LeafIterator_parentNode_set', self, s_parentNode, PACKAGE='infomap');
  
}

attr(`LeafIterator_parentNode_set`, 'returnType') = 'void'
attr(`LeafIterator_parentNode_set`, "inputTypes") = c('_p_LeafIterator', '_p_SNode')
class(`LeafIterator_parentNode_set`) = c("SWIGFunction", class('LeafIterator_parentNode_set'))

# Start of LeafIterator_parentNode_get

`LeafIterator_parentNode_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_parentNode_get', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_parentNode_get`, 'returnType') = '_p_SNode'
attr(`LeafIterator_parentNode_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_parentNode_get`) = c("SWIGFunction", class('LeafIterator_parentNode_get'))

# Start of LeafIterator_parentIndex_set

`LeafIterator_parentIndex_set` = function(self, s_parentIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_parentIndex = as.integer(s_parentIndex);
  
  if(length(s_parentIndex) > 1) {
    warning("using only the first element of s_parentIndex");
  };
  
  ;.Call('R_swig_LeafIterator_parentIndex_set', self, s_parentIndex, PACKAGE='infomap');
  
}

attr(`LeafIterator_parentIndex_set`, 'returnType') = 'void'
attr(`LeafIterator_parentIndex_set`, "inputTypes") = c('_p_LeafIterator', 'integer')
class(`LeafIterator_parentIndex_set`) = c("SWIGFunction", class('LeafIterator_parentIndex_set'))

# Start of LeafIterator_parentIndex_get

`LeafIterator_parentIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_parentIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_parentIndex_get`, 'returnType') = 'integer'
attr(`LeafIterator_parentIndex_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_parentIndex_get`) = c("SWIGFunction", class('LeafIterator_parentIndex_get'))

# Start of LeafIterator_isLeaf_set

`LeafIterator_isLeaf_set` = function(self, s_isLeaf)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_isLeaf = as.logical(s_isLeaf);
  ;.Call('R_swig_LeafIterator_isLeaf_set', self, s_isLeaf, PACKAGE='infomap');
  
}

attr(`LeafIterator_isLeaf_set`, 'returnType') = 'void'
attr(`LeafIterator_isLeaf_set`, "inputTypes") = c('_p_LeafIterator', 'logical')
class(`LeafIterator_isLeaf_set`) = c("SWIGFunction", class('LeafIterator_isLeaf_set'))

# Start of LeafIterator_isLeaf_get

`LeafIterator_isLeaf_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_isLeaf_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_isLeaf_get`, 'returnType') = 'logical'
attr(`LeafIterator_isLeaf_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_isLeaf_get`) = c("SWIGFunction", class('LeafIterator_isLeaf_get'))

# Start of LeafIterator_originalLeafIndex_set

`LeafIterator_originalLeafIndex_set` = function(self, s_originalLeafIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_originalLeafIndex = as.integer(s_originalLeafIndex);
  
  if(length(s_originalLeafIndex) > 1) {
    warning("using only the first element of s_originalLeafIndex");
  };
  
  ;.Call('R_swig_LeafIterator_originalLeafIndex_set', self, s_originalLeafIndex, PACKAGE='infomap');
  
}

attr(`LeafIterator_originalLeafIndex_set`, 'returnType') = 'void'
attr(`LeafIterator_originalLeafIndex_set`, "inputTypes") = c('_p_LeafIterator', 'integer')
class(`LeafIterator_originalLeafIndex_set`) = c("SWIGFunction", class('LeafIterator_originalLeafIndex_set'))

# Start of LeafIterator_originalLeafIndex_get

`LeafIterator_originalLeafIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_originalLeafIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_originalLeafIndex_get`, 'returnType') = 'integer'
attr(`LeafIterator_originalLeafIndex_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_originalLeafIndex_get`) = c("SWIGFunction", class('LeafIterator_originalLeafIndex_get'))

# Start of LeafIterator_id_set

`LeafIterator_id_set` = function(self, s_id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_id = as.integer(s_id);
  
  if(length(s_id) > 1) {
    warning("using only the first element of s_id");
  };
  
  ;.Call('R_swig_LeafIterator_id_set', self, s_id, PACKAGE='infomap');
  
}

attr(`LeafIterator_id_set`, 'returnType') = 'void'
attr(`LeafIterator_id_set`, "inputTypes") = c('_p_LeafIterator', 'integer')
class(`LeafIterator_id_set`) = c("SWIGFunction", class('LeafIterator_id_set'))

# Start of LeafIterator_id_get

`LeafIterator_id_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_id_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_id_get`, 'returnType') = 'integer'
attr(`LeafIterator_id_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_id_get`) = c("SWIGFunction", class('LeafIterator_id_get'))

# Start of LeafIterator_children_set

`LeafIterator_children_set` = function(self, s_children)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_children, "ExternalReference")) s_children = slot(s_children,"ref") 
  ;.Call('R_swig_LeafIterator_children_set', self, s_children, PACKAGE='infomap');
  
}

attr(`LeafIterator_children_set`, 'returnType') = 'void'
attr(`LeafIterator_children_set`, "inputTypes") = c('_p_LeafIterator', '_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t')
class(`LeafIterator_children_set`) = c("SWIGFunction", class('LeafIterator_children_set'))

# Start of LeafIterator_children_get

`LeafIterator_children_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_children_get', self, PACKAGE='infomap');
  ans <- new("_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_children_get`, 'returnType') = '_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t'
attr(`LeafIterator_children_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_children_get`) = c("SWIGFunction", class('LeafIterator_children_get'))

# Start of LeafIterator_childEdges_set

`LeafIterator_childEdges_set` = function(self, s_childEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_childEdges, "ExternalReference")) s_childEdges = slot(s_childEdges,"ref") 
  ;.Call('R_swig_LeafIterator_childEdges_set', self, s_childEdges, PACKAGE='infomap');
  
}

attr(`LeafIterator_childEdges_set`, 'returnType') = 'void'
attr(`LeafIterator_childEdges_set`, "inputTypes") = c('_p_LeafIterator', '_p_std__setT_ChildEdge_EdgeComp_t')
class(`LeafIterator_childEdges_set`) = c("SWIGFunction", class('LeafIterator_childEdges_set'))

# Start of LeafIterator_childEdges_get

`LeafIterator_childEdges_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_childEdges_get', self, PACKAGE='infomap');
  ans <- new("_p_std__setT_ChildEdge_EdgeComp_t", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_childEdges_get`, 'returnType') = '_p_std__setT_ChildEdge_EdgeComp_t'
attr(`LeafIterator_childEdges_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_childEdges_get`) = c("SWIGFunction", class('LeafIterator_childEdges_get'))

# Start of LeafIterator_skip_set

`LeafIterator_skip_set` = function(self, s_skip)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_skip = as.logical(s_skip);
  ;.Call('R_swig_LeafIterator_skip_set', self, s_skip, PACKAGE='infomap');
  
}

attr(`LeafIterator_skip_set`, 'returnType') = 'void'
attr(`LeafIterator_skip_set`, "inputTypes") = c('_p_LeafIterator', 'logical')
class(`LeafIterator_skip_set`) = c("SWIGFunction", class('LeafIterator_skip_set'))

# Start of LeafIterator_skip_get

`LeafIterator_skip_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_skip_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_skip_get`, 'returnType') = 'logical'
attr(`LeafIterator_skip_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_skip_get`) = c("SWIGFunction", class('LeafIterator_skip_get'))

# Start of LeafIterator_isMemoryNode_set

`LeafIterator_isMemoryNode_set` = function(self, s_isMemoryNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_isMemoryNode = as.logical(s_isMemoryNode);
  ;.Call('R_swig_LeafIterator_isMemoryNode_set', self, s_isMemoryNode, PACKAGE='infomap');
  
}

attr(`LeafIterator_isMemoryNode_set`, 'returnType') = 'void'
attr(`LeafIterator_isMemoryNode_set`, "inputTypes") = c('_p_LeafIterator', 'logical')
class(`LeafIterator_isMemoryNode_set`) = c("SWIGFunction", class('LeafIterator_isMemoryNode_set'))

# Start of LeafIterator_isMemoryNode_get

`LeafIterator_isMemoryNode_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_isMemoryNode_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_isMemoryNode_get`, 'returnType') = 'logical'
attr(`LeafIterator_isMemoryNode_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_isMemoryNode_get`) = c("SWIGFunction", class('LeafIterator_isMemoryNode_get'))

# Start of LeafIterator_stateIndex_set

`LeafIterator_stateIndex_set` = function(self, s_stateIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_stateIndex = as.integer(s_stateIndex);
  
  if(length(s_stateIndex) > 1) {
    warning("using only the first element of s_stateIndex");
  };
  
  ;.Call('R_swig_LeafIterator_stateIndex_set', self, s_stateIndex, PACKAGE='infomap');
  
}

attr(`LeafIterator_stateIndex_set`, 'returnType') = 'void'
attr(`LeafIterator_stateIndex_set`, "inputTypes") = c('_p_LeafIterator', 'integer')
class(`LeafIterator_stateIndex_set`) = c("SWIGFunction", class('LeafIterator_stateIndex_set'))

# Start of LeafIterator_stateIndex_get

`LeafIterator_stateIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_stateIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_stateIndex_get`, 'returnType') = 'integer'
attr(`LeafIterator_stateIndex_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_stateIndex_get`) = c("SWIGFunction", class('LeafIterator_stateIndex_get'))

# Start of LeafIterator_physIndex_set

`LeafIterator_physIndex_set` = function(self, s_physIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_physIndex = as.integer(s_physIndex);
  
  if(length(s_physIndex) > 1) {
    warning("using only the first element of s_physIndex");
  };
  
  ;.Call('R_swig_LeafIterator_physIndex_set', self, s_physIndex, PACKAGE='infomap');
  
}

attr(`LeafIterator_physIndex_set`, 'returnType') = 'void'
attr(`LeafIterator_physIndex_set`, "inputTypes") = c('_p_LeafIterator', 'integer')
class(`LeafIterator_physIndex_set`) = c("SWIGFunction", class('LeafIterator_physIndex_set'))

# Start of LeafIterator_physIndex_get

`LeafIterator_physIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_physIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_physIndex_get`, 'returnType') = 'integer'
attr(`LeafIterator_physIndex_get`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_physIndex_get`) = c("SWIGFunction", class('LeafIterator_physIndex_get'))

# Start of LeafIterator_serializationSize

`LeafIterator_serializationSize` = function(self, writeEdges, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_LeafIterator_serializationSize', self, writeEdges, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_serializationSize`, 'returnType') = 'integer'
attr(`LeafIterator_serializationSize`, "inputTypes") = c('_p_LeafIterator', 'logical')
class(`LeafIterator_serializationSize`) = c("SWIGFunction", class('LeafIterator_serializationSize'))

# Start of LeafIterator_serialize

`LeafIterator_serialize` = function(self, outFile, childPosition, writeEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(outFile, "ExternalReference")) outFile = slot(outFile,"ref") 
  childPosition = as.integer(childPosition);
  
  if(length(childPosition) > 1) {
    warning("using only the first element of childPosition");
  };
  
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_LeafIterator_serialize', self, outFile, childPosition, writeEdges, PACKAGE='infomap');
  
}

attr(`LeafIterator_serialize`, 'returnType') = 'void'
attr(`LeafIterator_serialize`, "inputTypes") = c('_p_LeafIterator', '_p_SafeBinaryOutFile', 'integer', 'logical')
class(`LeafIterator_serialize`) = c("SWIGFunction", class('LeafIterator_serialize'))

# Start of LeafIterator_deserialize

`LeafIterator_deserialize` = function(self, dataStream, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dataStream, "ExternalReference")) dataStream = slot(dataStream,"ref") 
  ;.Call('R_swig_LeafIterator_deserialize', self, dataStream, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_deserialize`, 'returnType') = 'integer'
attr(`LeafIterator_deserialize`, "inputTypes") = c('_p_LeafIterator', '_p_SafeBinaryInFile')
class(`LeafIterator_deserialize`) = c("SWIGFunction", class('LeafIterator_deserialize'))

# Start of LeafIterator_deserializeEdges

`LeafIterator_deserializeEdges` = function(self, dataStream, directedEdges, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dataStream, "ExternalReference")) dataStream = slot(dataStream,"ref") 
  directedEdges = as.logical(directedEdges);
  ;.Call('R_swig_LeafIterator_deserializeEdges', self, dataStream, directedEdges, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_deserializeEdges`, 'returnType') = 'integer'
attr(`LeafIterator_deserializeEdges`, "inputTypes") = c('_p_LeafIterator', '_p_SafeBinaryInFile', 'logical')
class(`LeafIterator_deserializeEdges`) = c("SWIGFunction", class('LeafIterator_deserializeEdges'))

# Start of LeafIterator_lastChild

`LeafIterator_lastChild` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_lastChild', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_lastChild`, 'returnType') = '_p_SNode'
attr(`LeafIterator_lastChild`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_lastChild`) = c("SWIGFunction", class('LeafIterator_lastChild'))

# Start of LeafIterator_firstChild

`LeafIterator_firstChild` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_firstChild', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_firstChild`, 'returnType') = '_p_SNode'
attr(`LeafIterator_firstChild`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_firstChild`) = c("SWIGFunction", class('LeafIterator_firstChild'))

# Start of LeafIterator_nextSibling

`LeafIterator_nextSibling` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_LeafIterator_nextSibling', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`LeafIterator_nextSibling`, 'returnType') = '_p_SNode'
attr(`LeafIterator_nextSibling`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_nextSibling`) = c("SWIGFunction", class('LeafIterator_nextSibling'))

# Start of LeafIterator_isLeafNode

`LeafIterator_isLeafNode` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_isLeafNode', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_isLeafNode`, 'returnType') = 'logical'
attr(`LeafIterator_isLeafNode`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_isLeafNode`) = c("SWIGFunction", class('LeafIterator_isLeafNode'))

# Start of LeafIterator_isLeafModule

`LeafIterator_isLeafModule` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_LeafIterator_isLeafModule', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_isLeafModule`, 'returnType') = 'logical'
attr(`LeafIterator_isLeafModule`, "inputTypes") = c('_p_LeafIterator')
class(`LeafIterator_isLeafModule`) = c("SWIGFunction", class('LeafIterator_isLeafModule'))

# Start of LeafIterator_createChildEdge

`LeafIterator_createChildEdge` = function(self, sourceIndex, targetIndex, flow, directed, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  sourceIndex = as.integer(sourceIndex);
  
  if(length(sourceIndex) > 1) {
    warning("using only the first element of sourceIndex");
  };
  
  targetIndex = as.integer(targetIndex);
  
  if(length(targetIndex) > 1) {
    warning("using only the first element of targetIndex");
  };
  
  
  directed = as.logical(directed);
  ;.Call('R_swig_LeafIterator_createChildEdge', self, sourceIndex, targetIndex, flow, directed, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LeafIterator_createChildEdge`, 'returnType') = 'logical'
attr(`LeafIterator_createChildEdge`, "inputTypes") = c('_p_LeafIterator', 'integer', 'integer', 'numeric', 'logical')
class(`LeafIterator_createChildEdge`) = c("SWIGFunction", class('LeafIterator_createChildEdge'))

# Start of accessor method for LeafIterator
setMethod('$', '_p_LeafIterator', function(x, name)

{
  accessorFuns = list('Equal' = LeafIterator_Equal, 'base' = LeafIterator_base, 'isEnd' = LeafIterator_isEnd, '__ref__' = LeafIterator___ref__, '__deref__' = LeafIterator___deref__, 'PlusPlusPrefix' = LeafIterator_PlusPlusPrefix, 'PlusPlusPostfix' = LeafIterator_PlusPlusPostfix, 'stepForward' = LeafIterator_stepForward, 'depth' = LeafIterator_depth, 'moduleIndex' = LeafIterator_moduleIndex, 'EqualEqual' = LeafIterator_EqualEqual, 'NotEqual' = LeafIterator_NotEqual, 'childDegree' = LeafIterator_childDegree, 'clear' = LeafIterator_clear, 'addChild' = LeafIterator_addChild, 'numSerializableChildEdges' = LeafIterator_numSerializableChildEdges, 'printState' = LeafIterator_printState, 'data' = LeafIterator_data_get, 'depthBelow' = LeafIterator_depthBelow_get, 'parentNode' = LeafIterator_parentNode_get, 'parentIndex' = LeafIterator_parentIndex_get, 'isLeaf' = LeafIterator_isLeaf_get, 'originalLeafIndex' = LeafIterator_originalLeafIndex_get, 'id' = LeafIterator_id_get, 'children' = LeafIterator_children_get, 'childEdges' = LeafIterator_childEdges_get, 'skip' = LeafIterator_skip_get, 'isMemoryNode' = LeafIterator_isMemoryNode_get, 'stateIndex' = LeafIterator_stateIndex_get, 'physIndex' = LeafIterator_physIndex_get, 'serializationSize' = LeafIterator_serializationSize, 'serialize' = LeafIterator_serialize, 'deserialize' = LeafIterator_deserialize, 'deserializeEdges' = LeafIterator_deserializeEdges, 'lastChild' = LeafIterator_lastChild, 'firstChild' = LeafIterator_firstChild, 'nextSibling' = LeafIterator_nextSibling, 'isLeafNode' = LeafIterator_isLeafNode, 'isLeafModule' = LeafIterator_isLeafModule, 'createChildEdge' = LeafIterator_createChildEdge);
  vaccessors = c('data', 'depthBelow', 'parentNode', 'parentIndex', 'isLeaf', 'originalLeafIndex', 'id', 'children', 'childEdges', 'skip', 'isMemoryNode', 'stateIndex', 'physIndex');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for LeafIterator
# Start of accessor method for LeafIterator
setMethod('$<-', '_p_LeafIterator', function(x, name, value)

{
  accessorFuns = list('data' = LeafIterator_data_set, 'depthBelow' = LeafIterator_depthBelow_set, 'parentNode' = LeafIterator_parentNode_set, 'parentIndex' = LeafIterator_parentIndex_set, 'isLeaf' = LeafIterator_isLeaf_set, 'originalLeafIndex' = LeafIterator_originalLeafIndex_set, 'id' = LeafIterator_id_set, 'children' = LeafIterator_children_set, 'childEdges' = LeafIterator_childEdges_set, 'skip' = LeafIterator_skip_set, 'isMemoryNode' = LeafIterator_isMemoryNode_set, 'stateIndex' = LeafIterator_stateIndex_set, 'physIndex' = LeafIterator_physIndex_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_LeafIterator', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = LeafIterator_data_set, 'depthBelow' = LeafIterator_depthBelow_set, 'parentNode' = LeafIterator_parentNode_set, 'parentIndex' = LeafIterator_parentIndex_set, 'isLeaf' = LeafIterator_isLeaf_set, 'originalLeafIndex' = LeafIterator_originalLeafIndex_set, 'id' = LeafIterator_id_set, 'children' = LeafIterator_children_set, 'childEdges' = LeafIterator_childEdges_set, 'skip' = LeafIterator_skip_set, 'isMemoryNode' = LeafIterator_isMemoryNode_set, 'stateIndex' = LeafIterator_stateIndex_set, 'physIndex' = LeafIterator_physIndex_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for LeafIterator
setMethod('delete', '_p_LeafIterator', function(obj) {delete_LeafIterator(obj)})
# Start of new_TreeIterator

`TreeIterator__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_TreeIterator__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_TreeIterator)
  ans
  
}

attr(`TreeIterator__SWIG_0`, 'returnType') = '_p_TreeIterator'
class(`TreeIterator__SWIG_0`) = c("SWIGFunction", class('TreeIterator__SWIG_0'))

# Start of new_TreeIterator

`TreeIterator__SWIG_1` = function(nodePointer, moduleIndexDepth)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref") 
  moduleIndexDepth = as.integer(moduleIndexDepth);
  
  if(length(moduleIndexDepth) > 1) {
    warning("using only the first element of moduleIndexDepth");
  };
  
  ;ans = .Call('R_swig_new_TreeIterator__SWIG_1', nodePointer, moduleIndexDepth, PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_TreeIterator)
  ans
  
}

attr(`TreeIterator__SWIG_1`, 'returnType') = '_p_TreeIterator'
attr(`TreeIterator__SWIG_1`, "inputTypes") = c('_p_SNode', 'integer')
class(`TreeIterator__SWIG_1`) = c("SWIGFunction", class('TreeIterator__SWIG_1'))

# Start of new_TreeIterator

`TreeIterator__SWIG_2` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref") 
  ;ans = .Call('R_swig_new_TreeIterator__SWIG_2', nodePointer, PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_TreeIterator)
  ans
  
}

attr(`TreeIterator__SWIG_2`, 'returnType') = '_p_TreeIterator'
attr(`TreeIterator__SWIG_2`, "inputTypes") = c('_p_SNode')
class(`TreeIterator__SWIG_2`) = c("SWIGFunction", class('TreeIterator__SWIG_2'))

# Start of new_TreeIterator

`TreeIterator__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_TreeIterator__SWIG_3', other, PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_TreeIterator)
  ans
  
}

attr(`TreeIterator__SWIG_3`, 'returnType') = '_p_TreeIterator'
attr(`TreeIterator__SWIG_3`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator__SWIG_3`) = c("SWIGFunction", class('TreeIterator__SWIG_3'))

`TreeIterator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- TreeIterator__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_SNode')) {
      f <- TreeIterator__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_TreeIterator') && length(argv[[1]]) == 1) {
      f <- TreeIterator__SWIG_3; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_SNode') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- TreeIterator__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for TreeIterator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of TreeIterator_Equal

`TreeIterator_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_TreeIterator_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_Equal`, 'returnType') = '_p_TreeIterator'
attr(`TreeIterator_Equal`, "inputTypes") = c('_p_TreeIterator', '_p_TreeIterator')
class(`TreeIterator_Equal`) = c("SWIGFunction", class('TreeIterator_Equal'))

# Start of TreeIterator_base

`TreeIterator_base` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_base', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_base`, 'returnType') = '_p_SNode'
attr(`TreeIterator_base`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_base`) = c("SWIGFunction", class('TreeIterator_base'))

# Start of TreeIterator_isEnd

`TreeIterator_isEnd` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_isEnd', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_isEnd`, 'returnType') = 'logical'
attr(`TreeIterator_isEnd`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_isEnd`) = c("SWIGFunction", class('TreeIterator_isEnd'))

# Start of TreeIterator___ref__

`TreeIterator___ref__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator___ref__', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator___ref__`, 'returnType') = '_p_SNode'
attr(`TreeIterator___ref__`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator___ref__`) = c("SWIGFunction", class('TreeIterator___ref__'))

# Start of TreeIterator___deref__

`TreeIterator___deref__` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator___deref__', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator___deref__`, 'returnType') = '_p_SNode'
attr(`TreeIterator___deref__`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator___deref__`) = c("SWIGFunction", class('TreeIterator___deref__'))

# Start of TreeIterator_PlusPlusPrefix

`TreeIterator_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_PlusPlusPrefix`, 'returnType') = '_p_TreeIterator'
attr(`TreeIterator_PlusPlusPrefix`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_PlusPlusPrefix`) = c("SWIGFunction", class('TreeIterator_PlusPlusPrefix'))

# Start of TreeIterator_PlusPlusPostfix

`TreeIterator_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_TreeIterator_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans);
  
  ans
  
}

attr(`TreeIterator_PlusPlusPostfix`, 'returnType') = '_p_TreeIterator'
attr(`TreeIterator_PlusPlusPostfix`, "inputTypes") = c('_p_TreeIterator', 'integer')
class(`TreeIterator_PlusPlusPostfix`) = c("SWIGFunction", class('TreeIterator_PlusPlusPostfix'))

# Start of TreeIterator_stepForward

`TreeIterator_stepForward` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_stepForward', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_stepForward`, 'returnType') = '_p_TreeIterator'
attr(`TreeIterator_stepForward`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_stepForward`) = c("SWIGFunction", class('TreeIterator_stepForward'))

# Start of TreeIterator_depth

`TreeIterator_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_depth`, 'returnType') = 'integer'
attr(`TreeIterator_depth`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_depth`) = c("SWIGFunction", class('TreeIterator_depth'))

# Start of TreeIterator_moduleIndex

`TreeIterator_moduleIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_moduleIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_moduleIndex`, 'returnType') = 'integer'
attr(`TreeIterator_moduleIndex`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_moduleIndex`) = c("SWIGFunction", class('TreeIterator_moduleIndex'))

# Start of TreeIterator_path

`TreeIterator_path` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_path', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_path`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`TreeIterator_path`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_path`) = c("SWIGFunction", class('TreeIterator_path'))

# Start of TreeIterator_EqualEqual

`TreeIterator_EqualEqual` = function(self, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref") 
  ;.Call('R_swig_TreeIterator_EqualEqual', self, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_EqualEqual`, 'returnType') = 'logical'
attr(`TreeIterator_EqualEqual`, "inputTypes") = c('_p_TreeIterator', '_p_TreeIterator')
class(`TreeIterator_EqualEqual`) = c("SWIGFunction", class('TreeIterator_EqualEqual'))

# Start of TreeIterator_NotEqual

`TreeIterator_NotEqual` = function(self, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref") 
  ;.Call('R_swig_TreeIterator_NotEqual', self, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_NotEqual`, 'returnType') = 'logical'
attr(`TreeIterator_NotEqual`, "inputTypes") = c('_p_TreeIterator', '_p_TreeIterator')
class(`TreeIterator_NotEqual`) = c("SWIGFunction", class('TreeIterator_NotEqual'))

# Start of delete_TreeIterator

`delete_TreeIterator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_TreeIterator', self, PACKAGE='infomap');
  
}

attr(`delete_TreeIterator`, 'returnType') = 'void'
attr(`delete_TreeIterator`, "inputTypes") = c('_p_TreeIterator')
class(`delete_TreeIterator`) = c("SWIGFunction", class('delete_TreeIterator'))

# Start of TreeIterator_childDegree

`TreeIterator_childDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_childDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_childDegree`, 'returnType') = 'integer'
attr(`TreeIterator_childDegree`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_childDegree`) = c("SWIGFunction", class('TreeIterator_childDegree'))

# Start of TreeIterator_clear

`TreeIterator_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_clear', self, PACKAGE='infomap');
  
}

attr(`TreeIterator_clear`, 'returnType') = 'void'
attr(`TreeIterator_clear`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_clear`) = c("SWIGFunction", class('TreeIterator_clear'))

# Start of TreeIterator_addChild

`TreeIterator_addChild` = function(self, child)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(child, "ExternalReference")) child = slot(child,"ref") 
  ;.Call('R_swig_TreeIterator_addChild', self, child, PACKAGE='infomap');
  
}

attr(`TreeIterator_addChild`, 'returnType') = 'void'
attr(`TreeIterator_addChild`, "inputTypes") = c('_p_TreeIterator', '_p_SNode')
class(`TreeIterator_addChild`) = c("SWIGFunction", class('TreeIterator_addChild'))

# Start of TreeIterator_numSerializableChildEdges

`TreeIterator_numSerializableChildEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_numSerializableChildEdges', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_numSerializableChildEdges`, 'returnType') = 'integer'
attr(`TreeIterator_numSerializableChildEdges`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_numSerializableChildEdges`) = c("SWIGFunction", class('TreeIterator_numSerializableChildEdges'))

# Start of TreeIterator_printState

`TreeIterator_printState__SWIG_0` = function(self, indexOffset, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  indexOffset = as.integer(indexOffset);
  
  if(length(indexOffset) > 1) {
    warning("using only the first element of indexOffset");
  };
  
  ;.Call('R_swig_TreeIterator_printState__SWIG_0', self, indexOffset, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_printState__SWIG_0`, 'returnType') = 'character'
attr(`TreeIterator_printState__SWIG_0`, "inputTypes") = c('_p_TreeIterator', 'integer')
class(`TreeIterator_printState__SWIG_0`) = c("SWIGFunction", class('TreeIterator_printState__SWIG_0'))

# Start of TreeIterator_printState

`TreeIterator_printState__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_printState__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_printState__SWIG_1`, 'returnType') = 'character'
attr(`TreeIterator_printState__SWIG_1`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_printState__SWIG_1`) = c("SWIGFunction", class('TreeIterator_printState__SWIG_1'))

`TreeIterator_printState` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_TreeIterator')) {
      f <- TreeIterator_printState__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_TreeIterator') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- TreeIterator_printState__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for TreeIterator_printState with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of TreeIterator_data_set

`TreeIterator_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_TreeIterator_data_set', self, s_data, PACKAGE='infomap');
  
}

attr(`TreeIterator_data_set`, 'returnType') = 'void'
attr(`TreeIterator_data_set`, "inputTypes") = c('_p_TreeIterator', '_p_NodeData')
class(`TreeIterator_data_set`) = c("SWIGFunction", class('TreeIterator_data_set'))

# Start of TreeIterator_data_get

`TreeIterator_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_data_get', self, PACKAGE='infomap');
  ans <- new("_p_NodeData", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_data_get`, 'returnType') = '_p_NodeData'
attr(`TreeIterator_data_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_data_get`) = c("SWIGFunction", class('TreeIterator_data_get'))

# Start of TreeIterator_depthBelow_set

`TreeIterator_depthBelow_set` = function(self, s_depthBelow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_depthBelow = as.integer(s_depthBelow);
  
  if(length(s_depthBelow) > 1) {
    warning("using only the first element of s_depthBelow");
  };
  
  ;.Call('R_swig_TreeIterator_depthBelow_set', self, s_depthBelow, PACKAGE='infomap');
  
}

attr(`TreeIterator_depthBelow_set`, 'returnType') = 'void'
attr(`TreeIterator_depthBelow_set`, "inputTypes") = c('_p_TreeIterator', 'integer')
class(`TreeIterator_depthBelow_set`) = c("SWIGFunction", class('TreeIterator_depthBelow_set'))

# Start of TreeIterator_depthBelow_get

`TreeIterator_depthBelow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_depthBelow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_depthBelow_get`, 'returnType') = 'integer'
attr(`TreeIterator_depthBelow_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_depthBelow_get`) = c("SWIGFunction", class('TreeIterator_depthBelow_get'))

# Start of TreeIterator_parentNode_set

`TreeIterator_parentNode_set` = function(self, s_parentNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_parentNode, "ExternalReference")) s_parentNode = slot(s_parentNode,"ref") 
  ;.Call('R_swig_TreeIterator_parentNode_set', self, s_parentNode, PACKAGE='infomap');
  
}

attr(`TreeIterator_parentNode_set`, 'returnType') = 'void'
attr(`TreeIterator_parentNode_set`, "inputTypes") = c('_p_TreeIterator', '_p_SNode')
class(`TreeIterator_parentNode_set`) = c("SWIGFunction", class('TreeIterator_parentNode_set'))

# Start of TreeIterator_parentNode_get

`TreeIterator_parentNode_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_parentNode_get', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_parentNode_get`, 'returnType') = '_p_SNode'
attr(`TreeIterator_parentNode_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_parentNode_get`) = c("SWIGFunction", class('TreeIterator_parentNode_get'))

# Start of TreeIterator_parentIndex_set

`TreeIterator_parentIndex_set` = function(self, s_parentIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_parentIndex = as.integer(s_parentIndex);
  
  if(length(s_parentIndex) > 1) {
    warning("using only the first element of s_parentIndex");
  };
  
  ;.Call('R_swig_TreeIterator_parentIndex_set', self, s_parentIndex, PACKAGE='infomap');
  
}

attr(`TreeIterator_parentIndex_set`, 'returnType') = 'void'
attr(`TreeIterator_parentIndex_set`, "inputTypes") = c('_p_TreeIterator', 'integer')
class(`TreeIterator_parentIndex_set`) = c("SWIGFunction", class('TreeIterator_parentIndex_set'))

# Start of TreeIterator_parentIndex_get

`TreeIterator_parentIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_parentIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_parentIndex_get`, 'returnType') = 'integer'
attr(`TreeIterator_parentIndex_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_parentIndex_get`) = c("SWIGFunction", class('TreeIterator_parentIndex_get'))

# Start of TreeIterator_isLeaf_set

`TreeIterator_isLeaf_set` = function(self, s_isLeaf)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_isLeaf = as.logical(s_isLeaf);
  ;.Call('R_swig_TreeIterator_isLeaf_set', self, s_isLeaf, PACKAGE='infomap');
  
}

attr(`TreeIterator_isLeaf_set`, 'returnType') = 'void'
attr(`TreeIterator_isLeaf_set`, "inputTypes") = c('_p_TreeIterator', 'logical')
class(`TreeIterator_isLeaf_set`) = c("SWIGFunction", class('TreeIterator_isLeaf_set'))

# Start of TreeIterator_isLeaf_get

`TreeIterator_isLeaf_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_isLeaf_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_isLeaf_get`, 'returnType') = 'logical'
attr(`TreeIterator_isLeaf_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_isLeaf_get`) = c("SWIGFunction", class('TreeIterator_isLeaf_get'))

# Start of TreeIterator_originalLeafIndex_set

`TreeIterator_originalLeafIndex_set` = function(self, s_originalLeafIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_originalLeafIndex = as.integer(s_originalLeafIndex);
  
  if(length(s_originalLeafIndex) > 1) {
    warning("using only the first element of s_originalLeafIndex");
  };
  
  ;.Call('R_swig_TreeIterator_originalLeafIndex_set', self, s_originalLeafIndex, PACKAGE='infomap');
  
}

attr(`TreeIterator_originalLeafIndex_set`, 'returnType') = 'void'
attr(`TreeIterator_originalLeafIndex_set`, "inputTypes") = c('_p_TreeIterator', 'integer')
class(`TreeIterator_originalLeafIndex_set`) = c("SWIGFunction", class('TreeIterator_originalLeafIndex_set'))

# Start of TreeIterator_originalLeafIndex_get

`TreeIterator_originalLeafIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_originalLeafIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_originalLeafIndex_get`, 'returnType') = 'integer'
attr(`TreeIterator_originalLeafIndex_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_originalLeafIndex_get`) = c("SWIGFunction", class('TreeIterator_originalLeafIndex_get'))

# Start of TreeIterator_id_set

`TreeIterator_id_set` = function(self, s_id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_id = as.integer(s_id);
  
  if(length(s_id) > 1) {
    warning("using only the first element of s_id");
  };
  
  ;.Call('R_swig_TreeIterator_id_set', self, s_id, PACKAGE='infomap');
  
}

attr(`TreeIterator_id_set`, 'returnType') = 'void'
attr(`TreeIterator_id_set`, "inputTypes") = c('_p_TreeIterator', 'integer')
class(`TreeIterator_id_set`) = c("SWIGFunction", class('TreeIterator_id_set'))

# Start of TreeIterator_id_get

`TreeIterator_id_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_id_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_id_get`, 'returnType') = 'integer'
attr(`TreeIterator_id_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_id_get`) = c("SWIGFunction", class('TreeIterator_id_get'))

# Start of TreeIterator_children_set

`TreeIterator_children_set` = function(self, s_children)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_children, "ExternalReference")) s_children = slot(s_children,"ref") 
  ;.Call('R_swig_TreeIterator_children_set', self, s_children, PACKAGE='infomap');
  
}

attr(`TreeIterator_children_set`, 'returnType') = 'void'
attr(`TreeIterator_children_set`, "inputTypes") = c('_p_TreeIterator', '_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t')
class(`TreeIterator_children_set`) = c("SWIGFunction", class('TreeIterator_children_set'))

# Start of TreeIterator_children_get

`TreeIterator_children_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_children_get', self, PACKAGE='infomap');
  ans <- new("_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_children_get`, 'returnType') = '_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t'
attr(`TreeIterator_children_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_children_get`) = c("SWIGFunction", class('TreeIterator_children_get'))

# Start of TreeIterator_childEdges_set

`TreeIterator_childEdges_set` = function(self, s_childEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_childEdges, "ExternalReference")) s_childEdges = slot(s_childEdges,"ref") 
  ;.Call('R_swig_TreeIterator_childEdges_set', self, s_childEdges, PACKAGE='infomap');
  
}

attr(`TreeIterator_childEdges_set`, 'returnType') = 'void'
attr(`TreeIterator_childEdges_set`, "inputTypes") = c('_p_TreeIterator', '_p_std__setT_ChildEdge_EdgeComp_t')
class(`TreeIterator_childEdges_set`) = c("SWIGFunction", class('TreeIterator_childEdges_set'))

# Start of TreeIterator_childEdges_get

`TreeIterator_childEdges_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_childEdges_get', self, PACKAGE='infomap');
  ans <- new("_p_std__setT_ChildEdge_EdgeComp_t", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_childEdges_get`, 'returnType') = '_p_std__setT_ChildEdge_EdgeComp_t'
attr(`TreeIterator_childEdges_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_childEdges_get`) = c("SWIGFunction", class('TreeIterator_childEdges_get'))

# Start of TreeIterator_skip_set

`TreeIterator_skip_set` = function(self, s_skip)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_skip = as.logical(s_skip);
  ;.Call('R_swig_TreeIterator_skip_set', self, s_skip, PACKAGE='infomap');
  
}

attr(`TreeIterator_skip_set`, 'returnType') = 'void'
attr(`TreeIterator_skip_set`, "inputTypes") = c('_p_TreeIterator', 'logical')
class(`TreeIterator_skip_set`) = c("SWIGFunction", class('TreeIterator_skip_set'))

# Start of TreeIterator_skip_get

`TreeIterator_skip_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_skip_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_skip_get`, 'returnType') = 'logical'
attr(`TreeIterator_skip_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_skip_get`) = c("SWIGFunction", class('TreeIterator_skip_get'))

# Start of TreeIterator_isMemoryNode_set

`TreeIterator_isMemoryNode_set` = function(self, s_isMemoryNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_isMemoryNode = as.logical(s_isMemoryNode);
  ;.Call('R_swig_TreeIterator_isMemoryNode_set', self, s_isMemoryNode, PACKAGE='infomap');
  
}

attr(`TreeIterator_isMemoryNode_set`, 'returnType') = 'void'
attr(`TreeIterator_isMemoryNode_set`, "inputTypes") = c('_p_TreeIterator', 'logical')
class(`TreeIterator_isMemoryNode_set`) = c("SWIGFunction", class('TreeIterator_isMemoryNode_set'))

# Start of TreeIterator_isMemoryNode_get

`TreeIterator_isMemoryNode_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_isMemoryNode_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_isMemoryNode_get`, 'returnType') = 'logical'
attr(`TreeIterator_isMemoryNode_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_isMemoryNode_get`) = c("SWIGFunction", class('TreeIterator_isMemoryNode_get'))

# Start of TreeIterator_stateIndex_set

`TreeIterator_stateIndex_set` = function(self, s_stateIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_stateIndex = as.integer(s_stateIndex);
  
  if(length(s_stateIndex) > 1) {
    warning("using only the first element of s_stateIndex");
  };
  
  ;.Call('R_swig_TreeIterator_stateIndex_set', self, s_stateIndex, PACKAGE='infomap');
  
}

attr(`TreeIterator_stateIndex_set`, 'returnType') = 'void'
attr(`TreeIterator_stateIndex_set`, "inputTypes") = c('_p_TreeIterator', 'integer')
class(`TreeIterator_stateIndex_set`) = c("SWIGFunction", class('TreeIterator_stateIndex_set'))

# Start of TreeIterator_stateIndex_get

`TreeIterator_stateIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_stateIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_stateIndex_get`, 'returnType') = 'integer'
attr(`TreeIterator_stateIndex_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_stateIndex_get`) = c("SWIGFunction", class('TreeIterator_stateIndex_get'))

# Start of TreeIterator_physIndex_set

`TreeIterator_physIndex_set` = function(self, s_physIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_physIndex = as.integer(s_physIndex);
  
  if(length(s_physIndex) > 1) {
    warning("using only the first element of s_physIndex");
  };
  
  ;.Call('R_swig_TreeIterator_physIndex_set', self, s_physIndex, PACKAGE='infomap');
  
}

attr(`TreeIterator_physIndex_set`, 'returnType') = 'void'
attr(`TreeIterator_physIndex_set`, "inputTypes") = c('_p_TreeIterator', 'integer')
class(`TreeIterator_physIndex_set`) = c("SWIGFunction", class('TreeIterator_physIndex_set'))

# Start of TreeIterator_physIndex_get

`TreeIterator_physIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_physIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_physIndex_get`, 'returnType') = 'integer'
attr(`TreeIterator_physIndex_get`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_physIndex_get`) = c("SWIGFunction", class('TreeIterator_physIndex_get'))

# Start of TreeIterator_serializationSize

`TreeIterator_serializationSize` = function(self, writeEdges, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_TreeIterator_serializationSize', self, writeEdges, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_serializationSize`, 'returnType') = 'integer'
attr(`TreeIterator_serializationSize`, "inputTypes") = c('_p_TreeIterator', 'logical')
class(`TreeIterator_serializationSize`) = c("SWIGFunction", class('TreeIterator_serializationSize'))

# Start of TreeIterator_serialize

`TreeIterator_serialize` = function(self, outFile, childPosition, writeEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(outFile, "ExternalReference")) outFile = slot(outFile,"ref") 
  childPosition = as.integer(childPosition);
  
  if(length(childPosition) > 1) {
    warning("using only the first element of childPosition");
  };
  
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_TreeIterator_serialize', self, outFile, childPosition, writeEdges, PACKAGE='infomap');
  
}

attr(`TreeIterator_serialize`, 'returnType') = 'void'
attr(`TreeIterator_serialize`, "inputTypes") = c('_p_TreeIterator', '_p_SafeBinaryOutFile', 'integer', 'logical')
class(`TreeIterator_serialize`) = c("SWIGFunction", class('TreeIterator_serialize'))

# Start of TreeIterator_deserialize

`TreeIterator_deserialize` = function(self, dataStream, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dataStream, "ExternalReference")) dataStream = slot(dataStream,"ref") 
  ;.Call('R_swig_TreeIterator_deserialize', self, dataStream, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_deserialize`, 'returnType') = 'integer'
attr(`TreeIterator_deserialize`, "inputTypes") = c('_p_TreeIterator', '_p_SafeBinaryInFile')
class(`TreeIterator_deserialize`) = c("SWIGFunction", class('TreeIterator_deserialize'))

# Start of TreeIterator_deserializeEdges

`TreeIterator_deserializeEdges` = function(self, dataStream, directedEdges, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dataStream, "ExternalReference")) dataStream = slot(dataStream,"ref") 
  directedEdges = as.logical(directedEdges);
  ;.Call('R_swig_TreeIterator_deserializeEdges', self, dataStream, directedEdges, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_deserializeEdges`, 'returnType') = 'integer'
attr(`TreeIterator_deserializeEdges`, "inputTypes") = c('_p_TreeIterator', '_p_SafeBinaryInFile', 'logical')
class(`TreeIterator_deserializeEdges`) = c("SWIGFunction", class('TreeIterator_deserializeEdges'))

# Start of TreeIterator_lastChild

`TreeIterator_lastChild` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_lastChild', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_lastChild`, 'returnType') = '_p_SNode'
attr(`TreeIterator_lastChild`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_lastChild`) = c("SWIGFunction", class('TreeIterator_lastChild'))

# Start of TreeIterator_firstChild

`TreeIterator_firstChild` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_firstChild', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_firstChild`, 'returnType') = '_p_SNode'
attr(`TreeIterator_firstChild`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_firstChild`) = c("SWIGFunction", class('TreeIterator_firstChild'))

# Start of TreeIterator_nextSibling

`TreeIterator_nextSibling` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_TreeIterator_nextSibling', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`TreeIterator_nextSibling`, 'returnType') = '_p_SNode'
attr(`TreeIterator_nextSibling`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_nextSibling`) = c("SWIGFunction", class('TreeIterator_nextSibling'))

# Start of TreeIterator_isLeafNode

`TreeIterator_isLeafNode` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_isLeafNode', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_isLeafNode`, 'returnType') = 'logical'
attr(`TreeIterator_isLeafNode`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_isLeafNode`) = c("SWIGFunction", class('TreeIterator_isLeafNode'))

# Start of TreeIterator_isLeafModule

`TreeIterator_isLeafModule` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_TreeIterator_isLeafModule', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_isLeafModule`, 'returnType') = 'logical'
attr(`TreeIterator_isLeafModule`, "inputTypes") = c('_p_TreeIterator')
class(`TreeIterator_isLeafModule`) = c("SWIGFunction", class('TreeIterator_isLeafModule'))

# Start of TreeIterator_createChildEdge

`TreeIterator_createChildEdge` = function(self, sourceIndex, targetIndex, flow, directed, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  sourceIndex = as.integer(sourceIndex);
  
  if(length(sourceIndex) > 1) {
    warning("using only the first element of sourceIndex");
  };
  
  targetIndex = as.integer(targetIndex);
  
  if(length(targetIndex) > 1) {
    warning("using only the first element of targetIndex");
  };
  
  
  directed = as.logical(directed);
  ;.Call('R_swig_TreeIterator_createChildEdge', self, sourceIndex, targetIndex, flow, directed, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`TreeIterator_createChildEdge`, 'returnType') = 'logical'
attr(`TreeIterator_createChildEdge`, "inputTypes") = c('_p_TreeIterator', 'integer', 'integer', 'numeric', 'logical')
class(`TreeIterator_createChildEdge`) = c("SWIGFunction", class('TreeIterator_createChildEdge'))

# Start of accessor method for TreeIterator
setMethod('$', '_p_TreeIterator', function(x, name)

{
  accessorFuns = list('Equal' = TreeIterator_Equal, 'base' = TreeIterator_base, 'isEnd' = TreeIterator_isEnd, '__ref__' = TreeIterator___ref__, '__deref__' = TreeIterator___deref__, 'PlusPlusPrefix' = TreeIterator_PlusPlusPrefix, 'PlusPlusPostfix' = TreeIterator_PlusPlusPostfix, 'stepForward' = TreeIterator_stepForward, 'depth' = TreeIterator_depth, 'moduleIndex' = TreeIterator_moduleIndex, 'path' = TreeIterator_path, 'EqualEqual' = TreeIterator_EqualEqual, 'NotEqual' = TreeIterator_NotEqual, 'childDegree' = TreeIterator_childDegree, 'clear' = TreeIterator_clear, 'addChild' = TreeIterator_addChild, 'numSerializableChildEdges' = TreeIterator_numSerializableChildEdges, 'printState' = TreeIterator_printState, 'data' = TreeIterator_data_get, 'depthBelow' = TreeIterator_depthBelow_get, 'parentNode' = TreeIterator_parentNode_get, 'parentIndex' = TreeIterator_parentIndex_get, 'isLeaf' = TreeIterator_isLeaf_get, 'originalLeafIndex' = TreeIterator_originalLeafIndex_get, 'id' = TreeIterator_id_get, 'children' = TreeIterator_children_get, 'childEdges' = TreeIterator_childEdges_get, 'skip' = TreeIterator_skip_get, 'isMemoryNode' = TreeIterator_isMemoryNode_get, 'stateIndex' = TreeIterator_stateIndex_get, 'physIndex' = TreeIterator_physIndex_get, 'serializationSize' = TreeIterator_serializationSize, 'serialize' = TreeIterator_serialize, 'deserialize' = TreeIterator_deserialize, 'deserializeEdges' = TreeIterator_deserializeEdges, 'lastChild' = TreeIterator_lastChild, 'firstChild' = TreeIterator_firstChild, 'nextSibling' = TreeIterator_nextSibling, 'isLeafNode' = TreeIterator_isLeafNode, 'isLeafModule' = TreeIterator_isLeafModule, 'createChildEdge' = TreeIterator_createChildEdge);
  vaccessors = c('data', 'depthBelow', 'parentNode', 'parentIndex', 'isLeaf', 'originalLeafIndex', 'id', 'children', 'childEdges', 'skip', 'isMemoryNode', 'stateIndex', 'physIndex');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for TreeIterator
# Start of accessor method for TreeIterator
setMethod('$<-', '_p_TreeIterator', function(x, name, value)

{
  accessorFuns = list('data' = TreeIterator_data_set, 'depthBelow' = TreeIterator_depthBelow_set, 'parentNode' = TreeIterator_parentNode_set, 'parentIndex' = TreeIterator_parentIndex_set, 'isLeaf' = TreeIterator_isLeaf_set, 'originalLeafIndex' = TreeIterator_originalLeafIndex_set, 'id' = TreeIterator_id_set, 'children' = TreeIterator_children_set, 'childEdges' = TreeIterator_childEdges_set, 'skip' = TreeIterator_skip_set, 'isMemoryNode' = TreeIterator_isMemoryNode_set, 'stateIndex' = TreeIterator_stateIndex_set, 'physIndex' = TreeIterator_physIndex_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_TreeIterator', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = TreeIterator_data_set, 'depthBelow' = TreeIterator_depthBelow_set, 'parentNode' = TreeIterator_parentNode_set, 'parentIndex' = TreeIterator_parentIndex_set, 'isLeaf' = TreeIterator_isLeaf_set, 'originalLeafIndex' = TreeIterator_originalLeafIndex_set, 'id' = TreeIterator_id_set, 'children' = TreeIterator_children_set, 'childEdges' = TreeIterator_childEdges_set, 'skip' = TreeIterator_skip_set, 'isMemoryNode' = TreeIterator_isMemoryNode_set, 'stateIndex' = TreeIterator_stateIndex_set, 'physIndex' = TreeIterator_physIndex_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for TreeIterator
setMethod('delete', '_p_TreeIterator', function(obj) {delete_TreeIterator(obj)})
# Start of new_ChildIterator

`ChildIterator__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_ChildIterator__SWIG_0', PACKAGE='infomap');
  ans <- new("_p_ChildIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ChildIterator)
  ans
  
}

attr(`ChildIterator__SWIG_0`, 'returnType') = '_p_ChildIterator'
class(`ChildIterator__SWIG_0`) = c("SWIGFunction", class('ChildIterator__SWIG_0'))

# Start of new_ChildIterator

`ChildIterator__SWIG_1` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref") 
  ;ans = .Call('R_swig_new_ChildIterator__SWIG_1', nodePointer, PACKAGE='infomap');
  ans <- new("_p_ChildIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ChildIterator)
  ans
  
}

attr(`ChildIterator__SWIG_1`, 'returnType') = '_p_ChildIterator'
attr(`ChildIterator__SWIG_1`, "inputTypes") = c('_p_SNode')
class(`ChildIterator__SWIG_1`) = c("SWIGFunction", class('ChildIterator__SWIG_1'))

# Start of new_ChildIterator

`ChildIterator__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_ChildIterator__SWIG_2', other, PACKAGE='infomap');
  ans <- new("_p_ChildIterator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ChildIterator)
  ans
  
}

attr(`ChildIterator__SWIG_2`, 'returnType') = '_p_ChildIterator'
attr(`ChildIterator__SWIG_2`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator__SWIG_2`) = c("SWIGFunction", class('ChildIterator__SWIG_2'))

`ChildIterator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- ChildIterator__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_SNode')) {
      f <- ChildIterator__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_ChildIterator') && length(argv[[1]]) == 1) {
      f <- ChildIterator__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for ChildIterator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ChildIterator_Equal

`ChildIterator_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_ChildIterator_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_ChildIterator", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_Equal`, 'returnType') = '_p_ChildIterator'
attr(`ChildIterator_Equal`, "inputTypes") = c('_p_ChildIterator', '_p_ChildIterator')
class(`ChildIterator_Equal`) = c("SWIGFunction", class('ChildIterator_Equal'))

# Start of ChildIterator_base

`ChildIterator_base` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_base', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_base`, 'returnType') = '_p_SNode'
attr(`ChildIterator_base`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_base`) = c("SWIGFunction", class('ChildIterator_base'))

# Start of ChildIterator_isEnd

`ChildIterator_isEnd` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_isEnd', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_isEnd`, 'returnType') = 'logical'
attr(`ChildIterator_isEnd`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_isEnd`) = c("SWIGFunction", class('ChildIterator_isEnd'))

# Start of ChildIterator___ref__

`ChildIterator___ref__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator___ref__', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator___ref__`, 'returnType') = '_p_SNode'
attr(`ChildIterator___ref__`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator___ref__`) = c("SWIGFunction", class('ChildIterator___ref__'))

# Start of ChildIterator___deref__

`ChildIterator___deref__` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator___deref__', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator___deref__`, 'returnType') = '_p_SNode'
attr(`ChildIterator___deref__`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator___deref__`) = c("SWIGFunction", class('ChildIterator___deref__'))

# Start of ChildIterator_PlusPlusPrefix

`ChildIterator_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_ChildIterator", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_PlusPlusPrefix`, 'returnType') = '_p_ChildIterator'
attr(`ChildIterator_PlusPlusPrefix`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_PlusPlusPrefix`) = c("SWIGFunction", class('ChildIterator_PlusPlusPrefix'))

# Start of ChildIterator_PlusPlusPostfix

`ChildIterator_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_ChildIterator_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_ChildIterator", ref=ans);
  
  ans
  
}

attr(`ChildIterator_PlusPlusPostfix`, 'returnType') = '_p_ChildIterator'
attr(`ChildIterator_PlusPlusPostfix`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_PlusPlusPostfix`) = c("SWIGFunction", class('ChildIterator_PlusPlusPostfix'))

# Start of ChildIterator_stepForward

`ChildIterator_stepForward` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_stepForward', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_ChildIterator", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_stepForward`, 'returnType') = '_p_ChildIterator'
attr(`ChildIterator_stepForward`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_stepForward`) = c("SWIGFunction", class('ChildIterator_stepForward'))

# Start of ChildIterator_childIndex

`ChildIterator_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_childIndex`, 'returnType') = 'integer'
attr(`ChildIterator_childIndex`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_childIndex`) = c("SWIGFunction", class('ChildIterator_childIndex'))

# Start of ChildIterator_EqualEqual

`ChildIterator_EqualEqual` = function(self, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref") 
  ;.Call('R_swig_ChildIterator_EqualEqual', self, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_EqualEqual`, 'returnType') = 'logical'
attr(`ChildIterator_EqualEqual`, "inputTypes") = c('_p_ChildIterator', '_p_ChildIterator')
class(`ChildIterator_EqualEqual`) = c("SWIGFunction", class('ChildIterator_EqualEqual'))

# Start of ChildIterator_NotEqual

`ChildIterator_NotEqual` = function(self, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref") 
  ;.Call('R_swig_ChildIterator_NotEqual', self, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_NotEqual`, 'returnType') = 'logical'
attr(`ChildIterator_NotEqual`, "inputTypes") = c('_p_ChildIterator', '_p_ChildIterator')
class(`ChildIterator_NotEqual`) = c("SWIGFunction", class('ChildIterator_NotEqual'))

# Start of delete_ChildIterator

`delete_ChildIterator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_ChildIterator', self, PACKAGE='infomap');
  
}

attr(`delete_ChildIterator`, 'returnType') = 'void'
attr(`delete_ChildIterator`, "inputTypes") = c('_p_ChildIterator')
class(`delete_ChildIterator`) = c("SWIGFunction", class('delete_ChildIterator'))

# Start of ChildIterator_childDegree

`ChildIterator_childDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_childDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_childDegree`, 'returnType') = 'integer'
attr(`ChildIterator_childDegree`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_childDegree`) = c("SWIGFunction", class('ChildIterator_childDegree'))

# Start of ChildIterator_clear

`ChildIterator_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_clear', self, PACKAGE='infomap');
  
}

attr(`ChildIterator_clear`, 'returnType') = 'void'
attr(`ChildIterator_clear`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_clear`) = c("SWIGFunction", class('ChildIterator_clear'))

# Start of ChildIterator_addChild

`ChildIterator_addChild` = function(self, child)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(child, "ExternalReference")) child = slot(child,"ref") 
  ;.Call('R_swig_ChildIterator_addChild', self, child, PACKAGE='infomap');
  
}

attr(`ChildIterator_addChild`, 'returnType') = 'void'
attr(`ChildIterator_addChild`, "inputTypes") = c('_p_ChildIterator', '_p_SNode')
class(`ChildIterator_addChild`) = c("SWIGFunction", class('ChildIterator_addChild'))

# Start of ChildIterator_numSerializableChildEdges

`ChildIterator_numSerializableChildEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_numSerializableChildEdges', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_numSerializableChildEdges`, 'returnType') = 'integer'
attr(`ChildIterator_numSerializableChildEdges`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_numSerializableChildEdges`) = c("SWIGFunction", class('ChildIterator_numSerializableChildEdges'))

# Start of ChildIterator_printState

`ChildIterator_printState__SWIG_0` = function(self, indexOffset, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  indexOffset = as.integer(indexOffset);
  
  if(length(indexOffset) > 1) {
    warning("using only the first element of indexOffset");
  };
  
  ;.Call('R_swig_ChildIterator_printState__SWIG_0', self, indexOffset, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_printState__SWIG_0`, 'returnType') = 'character'
attr(`ChildIterator_printState__SWIG_0`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_printState__SWIG_0`) = c("SWIGFunction", class('ChildIterator_printState__SWIG_0'))

# Start of ChildIterator_printState

`ChildIterator_printState__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_printState__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_printState__SWIG_1`, 'returnType') = 'character'
attr(`ChildIterator_printState__SWIG_1`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_printState__SWIG_1`) = c("SWIGFunction", class('ChildIterator_printState__SWIG_1'))

`ChildIterator_printState` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_ChildIterator')) {
      f <- ChildIterator_printState__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_ChildIterator') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- ChildIterator_printState__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for ChildIterator_printState with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ChildIterator_data_set

`ChildIterator_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_ChildIterator_data_set', self, s_data, PACKAGE='infomap');
  
}

attr(`ChildIterator_data_set`, 'returnType') = 'void'
attr(`ChildIterator_data_set`, "inputTypes") = c('_p_ChildIterator', '_p_NodeData')
class(`ChildIterator_data_set`) = c("SWIGFunction", class('ChildIterator_data_set'))

# Start of ChildIterator_data_get

`ChildIterator_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_data_get', self, PACKAGE='infomap');
  ans <- new("_p_NodeData", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_data_get`, 'returnType') = '_p_NodeData'
attr(`ChildIterator_data_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_data_get`) = c("SWIGFunction", class('ChildIterator_data_get'))

# Start of ChildIterator_depth_set

`ChildIterator_depth_set` = function(self, s_depth)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_depth = as.integer(s_depth);
  
  if(length(s_depth) > 1) {
    warning("using only the first element of s_depth");
  };
  
  ;.Call('R_swig_ChildIterator_depth_set', self, s_depth, PACKAGE='infomap');
  
}

attr(`ChildIterator_depth_set`, 'returnType') = 'void'
attr(`ChildIterator_depth_set`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_depth_set`) = c("SWIGFunction", class('ChildIterator_depth_set'))

# Start of ChildIterator_depth_get

`ChildIterator_depth_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_depth_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_depth_get`, 'returnType') = 'integer'
attr(`ChildIterator_depth_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_depth_get`) = c("SWIGFunction", class('ChildIterator_depth_get'))

# Start of ChildIterator_depthBelow_set

`ChildIterator_depthBelow_set` = function(self, s_depthBelow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_depthBelow = as.integer(s_depthBelow);
  
  if(length(s_depthBelow) > 1) {
    warning("using only the first element of s_depthBelow");
  };
  
  ;.Call('R_swig_ChildIterator_depthBelow_set', self, s_depthBelow, PACKAGE='infomap');
  
}

attr(`ChildIterator_depthBelow_set`, 'returnType') = 'void'
attr(`ChildIterator_depthBelow_set`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_depthBelow_set`) = c("SWIGFunction", class('ChildIterator_depthBelow_set'))

# Start of ChildIterator_depthBelow_get

`ChildIterator_depthBelow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_depthBelow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_depthBelow_get`, 'returnType') = 'integer'
attr(`ChildIterator_depthBelow_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_depthBelow_get`) = c("SWIGFunction", class('ChildIterator_depthBelow_get'))

# Start of ChildIterator_parentNode_set

`ChildIterator_parentNode_set` = function(self, s_parentNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_parentNode, "ExternalReference")) s_parentNode = slot(s_parentNode,"ref") 
  ;.Call('R_swig_ChildIterator_parentNode_set', self, s_parentNode, PACKAGE='infomap');
  
}

attr(`ChildIterator_parentNode_set`, 'returnType') = 'void'
attr(`ChildIterator_parentNode_set`, "inputTypes") = c('_p_ChildIterator', '_p_SNode')
class(`ChildIterator_parentNode_set`) = c("SWIGFunction", class('ChildIterator_parentNode_set'))

# Start of ChildIterator_parentNode_get

`ChildIterator_parentNode_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_parentNode_get', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_parentNode_get`, 'returnType') = '_p_SNode'
attr(`ChildIterator_parentNode_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_parentNode_get`) = c("SWIGFunction", class('ChildIterator_parentNode_get'))

# Start of ChildIterator_parentIndex_set

`ChildIterator_parentIndex_set` = function(self, s_parentIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_parentIndex = as.integer(s_parentIndex);
  
  if(length(s_parentIndex) > 1) {
    warning("using only the first element of s_parentIndex");
  };
  
  ;.Call('R_swig_ChildIterator_parentIndex_set', self, s_parentIndex, PACKAGE='infomap');
  
}

attr(`ChildIterator_parentIndex_set`, 'returnType') = 'void'
attr(`ChildIterator_parentIndex_set`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_parentIndex_set`) = c("SWIGFunction", class('ChildIterator_parentIndex_set'))

# Start of ChildIterator_parentIndex_get

`ChildIterator_parentIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_parentIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_parentIndex_get`, 'returnType') = 'integer'
attr(`ChildIterator_parentIndex_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_parentIndex_get`) = c("SWIGFunction", class('ChildIterator_parentIndex_get'))

# Start of ChildIterator_isLeaf_set

`ChildIterator_isLeaf_set` = function(self, s_isLeaf)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_isLeaf = as.logical(s_isLeaf);
  ;.Call('R_swig_ChildIterator_isLeaf_set', self, s_isLeaf, PACKAGE='infomap');
  
}

attr(`ChildIterator_isLeaf_set`, 'returnType') = 'void'
attr(`ChildIterator_isLeaf_set`, "inputTypes") = c('_p_ChildIterator', 'logical')
class(`ChildIterator_isLeaf_set`) = c("SWIGFunction", class('ChildIterator_isLeaf_set'))

# Start of ChildIterator_isLeaf_get

`ChildIterator_isLeaf_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_isLeaf_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_isLeaf_get`, 'returnType') = 'logical'
attr(`ChildIterator_isLeaf_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_isLeaf_get`) = c("SWIGFunction", class('ChildIterator_isLeaf_get'))

# Start of ChildIterator_originalLeafIndex_set

`ChildIterator_originalLeafIndex_set` = function(self, s_originalLeafIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_originalLeafIndex = as.integer(s_originalLeafIndex);
  
  if(length(s_originalLeafIndex) > 1) {
    warning("using only the first element of s_originalLeafIndex");
  };
  
  ;.Call('R_swig_ChildIterator_originalLeafIndex_set', self, s_originalLeafIndex, PACKAGE='infomap');
  
}

attr(`ChildIterator_originalLeafIndex_set`, 'returnType') = 'void'
attr(`ChildIterator_originalLeafIndex_set`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_originalLeafIndex_set`) = c("SWIGFunction", class('ChildIterator_originalLeafIndex_set'))

# Start of ChildIterator_originalLeafIndex_get

`ChildIterator_originalLeafIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_originalLeafIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_originalLeafIndex_get`, 'returnType') = 'integer'
attr(`ChildIterator_originalLeafIndex_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_originalLeafIndex_get`) = c("SWIGFunction", class('ChildIterator_originalLeafIndex_get'))

# Start of ChildIterator_id_set

`ChildIterator_id_set` = function(self, s_id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_id = as.integer(s_id);
  
  if(length(s_id) > 1) {
    warning("using only the first element of s_id");
  };
  
  ;.Call('R_swig_ChildIterator_id_set', self, s_id, PACKAGE='infomap');
  
}

attr(`ChildIterator_id_set`, 'returnType') = 'void'
attr(`ChildIterator_id_set`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_id_set`) = c("SWIGFunction", class('ChildIterator_id_set'))

# Start of ChildIterator_id_get

`ChildIterator_id_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_id_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_id_get`, 'returnType') = 'integer'
attr(`ChildIterator_id_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_id_get`) = c("SWIGFunction", class('ChildIterator_id_get'))

# Start of ChildIterator_children_set

`ChildIterator_children_set` = function(self, s_children)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_children, "ExternalReference")) s_children = slot(s_children,"ref") 
  ;.Call('R_swig_ChildIterator_children_set', self, s_children, PACKAGE='infomap');
  
}

attr(`ChildIterator_children_set`, 'returnType') = 'void'
attr(`ChildIterator_children_set`, "inputTypes") = c('_p_ChildIterator', '_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t')
class(`ChildIterator_children_set`) = c("SWIGFunction", class('ChildIterator_children_set'))

# Start of ChildIterator_children_get

`ChildIterator_children_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_children_get', self, PACKAGE='infomap');
  ans <- new("_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_children_get`, 'returnType') = '_p_std__dequeT_SNode_p_std__allocatorT_SNode_p_t_t'
attr(`ChildIterator_children_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_children_get`) = c("SWIGFunction", class('ChildIterator_children_get'))

# Start of ChildIterator_childEdges_set

`ChildIterator_childEdges_set` = function(self, s_childEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_childEdges, "ExternalReference")) s_childEdges = slot(s_childEdges,"ref") 
  ;.Call('R_swig_ChildIterator_childEdges_set', self, s_childEdges, PACKAGE='infomap');
  
}

attr(`ChildIterator_childEdges_set`, 'returnType') = 'void'
attr(`ChildIterator_childEdges_set`, "inputTypes") = c('_p_ChildIterator', '_p_std__setT_ChildEdge_EdgeComp_t')
class(`ChildIterator_childEdges_set`) = c("SWIGFunction", class('ChildIterator_childEdges_set'))

# Start of ChildIterator_childEdges_get

`ChildIterator_childEdges_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_childEdges_get', self, PACKAGE='infomap');
  ans <- new("_p_std__setT_ChildEdge_EdgeComp_t", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_childEdges_get`, 'returnType') = '_p_std__setT_ChildEdge_EdgeComp_t'
attr(`ChildIterator_childEdges_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_childEdges_get`) = c("SWIGFunction", class('ChildIterator_childEdges_get'))

# Start of ChildIterator_skip_set

`ChildIterator_skip_set` = function(self, s_skip)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_skip = as.logical(s_skip);
  ;.Call('R_swig_ChildIterator_skip_set', self, s_skip, PACKAGE='infomap');
  
}

attr(`ChildIterator_skip_set`, 'returnType') = 'void'
attr(`ChildIterator_skip_set`, "inputTypes") = c('_p_ChildIterator', 'logical')
class(`ChildIterator_skip_set`) = c("SWIGFunction", class('ChildIterator_skip_set'))

# Start of ChildIterator_skip_get

`ChildIterator_skip_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_skip_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_skip_get`, 'returnType') = 'logical'
attr(`ChildIterator_skip_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_skip_get`) = c("SWIGFunction", class('ChildIterator_skip_get'))

# Start of ChildIterator_isMemoryNode_set

`ChildIterator_isMemoryNode_set` = function(self, s_isMemoryNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_isMemoryNode = as.logical(s_isMemoryNode);
  ;.Call('R_swig_ChildIterator_isMemoryNode_set', self, s_isMemoryNode, PACKAGE='infomap');
  
}

attr(`ChildIterator_isMemoryNode_set`, 'returnType') = 'void'
attr(`ChildIterator_isMemoryNode_set`, "inputTypes") = c('_p_ChildIterator', 'logical')
class(`ChildIterator_isMemoryNode_set`) = c("SWIGFunction", class('ChildIterator_isMemoryNode_set'))

# Start of ChildIterator_isMemoryNode_get

`ChildIterator_isMemoryNode_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_isMemoryNode_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_isMemoryNode_get`, 'returnType') = 'logical'
attr(`ChildIterator_isMemoryNode_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_isMemoryNode_get`) = c("SWIGFunction", class('ChildIterator_isMemoryNode_get'))

# Start of ChildIterator_stateIndex_set

`ChildIterator_stateIndex_set` = function(self, s_stateIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_stateIndex = as.integer(s_stateIndex);
  
  if(length(s_stateIndex) > 1) {
    warning("using only the first element of s_stateIndex");
  };
  
  ;.Call('R_swig_ChildIterator_stateIndex_set', self, s_stateIndex, PACKAGE='infomap');
  
}

attr(`ChildIterator_stateIndex_set`, 'returnType') = 'void'
attr(`ChildIterator_stateIndex_set`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_stateIndex_set`) = c("SWIGFunction", class('ChildIterator_stateIndex_set'))

# Start of ChildIterator_stateIndex_get

`ChildIterator_stateIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_stateIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_stateIndex_get`, 'returnType') = 'integer'
attr(`ChildIterator_stateIndex_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_stateIndex_get`) = c("SWIGFunction", class('ChildIterator_stateIndex_get'))

# Start of ChildIterator_physIndex_set

`ChildIterator_physIndex_set` = function(self, s_physIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_physIndex = as.integer(s_physIndex);
  
  if(length(s_physIndex) > 1) {
    warning("using only the first element of s_physIndex");
  };
  
  ;.Call('R_swig_ChildIterator_physIndex_set', self, s_physIndex, PACKAGE='infomap');
  
}

attr(`ChildIterator_physIndex_set`, 'returnType') = 'void'
attr(`ChildIterator_physIndex_set`, "inputTypes") = c('_p_ChildIterator', 'integer')
class(`ChildIterator_physIndex_set`) = c("SWIGFunction", class('ChildIterator_physIndex_set'))

# Start of ChildIterator_physIndex_get

`ChildIterator_physIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_physIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_physIndex_get`, 'returnType') = 'integer'
attr(`ChildIterator_physIndex_get`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_physIndex_get`) = c("SWIGFunction", class('ChildIterator_physIndex_get'))

# Start of ChildIterator_serializationSize

`ChildIterator_serializationSize` = function(self, writeEdges, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_ChildIterator_serializationSize', self, writeEdges, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_serializationSize`, 'returnType') = 'integer'
attr(`ChildIterator_serializationSize`, "inputTypes") = c('_p_ChildIterator', 'logical')
class(`ChildIterator_serializationSize`) = c("SWIGFunction", class('ChildIterator_serializationSize'))

# Start of ChildIterator_serialize

`ChildIterator_serialize` = function(self, outFile, childPosition, writeEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(outFile, "ExternalReference")) outFile = slot(outFile,"ref") 
  childPosition = as.integer(childPosition);
  
  if(length(childPosition) > 1) {
    warning("using only the first element of childPosition");
  };
  
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_ChildIterator_serialize', self, outFile, childPosition, writeEdges, PACKAGE='infomap');
  
}

attr(`ChildIterator_serialize`, 'returnType') = 'void'
attr(`ChildIterator_serialize`, "inputTypes") = c('_p_ChildIterator', '_p_SafeBinaryOutFile', 'integer', 'logical')
class(`ChildIterator_serialize`) = c("SWIGFunction", class('ChildIterator_serialize'))

# Start of ChildIterator_deserialize

`ChildIterator_deserialize` = function(self, dataStream, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dataStream, "ExternalReference")) dataStream = slot(dataStream,"ref") 
  ;.Call('R_swig_ChildIterator_deserialize', self, dataStream, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_deserialize`, 'returnType') = 'integer'
attr(`ChildIterator_deserialize`, "inputTypes") = c('_p_ChildIterator', '_p_SafeBinaryInFile')
class(`ChildIterator_deserialize`) = c("SWIGFunction", class('ChildIterator_deserialize'))

# Start of ChildIterator_deserializeEdges

`ChildIterator_deserializeEdges` = function(self, dataStream, directedEdges, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dataStream, "ExternalReference")) dataStream = slot(dataStream,"ref") 
  directedEdges = as.logical(directedEdges);
  ;.Call('R_swig_ChildIterator_deserializeEdges', self, dataStream, directedEdges, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_deserializeEdges`, 'returnType') = 'integer'
attr(`ChildIterator_deserializeEdges`, "inputTypes") = c('_p_ChildIterator', '_p_SafeBinaryInFile', 'logical')
class(`ChildIterator_deserializeEdges`) = c("SWIGFunction", class('ChildIterator_deserializeEdges'))

# Start of ChildIterator_lastChild

`ChildIterator_lastChild` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_lastChild', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_lastChild`, 'returnType') = '_p_SNode'
attr(`ChildIterator_lastChild`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_lastChild`) = c("SWIGFunction", class('ChildIterator_lastChild'))

# Start of ChildIterator_firstChild

`ChildIterator_firstChild` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_firstChild', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_firstChild`, 'returnType') = '_p_SNode'
attr(`ChildIterator_firstChild`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_firstChild`) = c("SWIGFunction", class('ChildIterator_firstChild'))

# Start of ChildIterator_nextSibling

`ChildIterator_nextSibling` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ChildIterator_nextSibling', self, PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`ChildIterator_nextSibling`, 'returnType') = '_p_SNode'
attr(`ChildIterator_nextSibling`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_nextSibling`) = c("SWIGFunction", class('ChildIterator_nextSibling'))

# Start of ChildIterator_isLeafNode

`ChildIterator_isLeafNode` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_isLeafNode', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_isLeafNode`, 'returnType') = 'logical'
attr(`ChildIterator_isLeafNode`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_isLeafNode`) = c("SWIGFunction", class('ChildIterator_isLeafNode'))

# Start of ChildIterator_isLeafModule

`ChildIterator_isLeafModule` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_ChildIterator_isLeafModule', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_isLeafModule`, 'returnType') = 'logical'
attr(`ChildIterator_isLeafModule`, "inputTypes") = c('_p_ChildIterator')
class(`ChildIterator_isLeafModule`) = c("SWIGFunction", class('ChildIterator_isLeafModule'))

# Start of ChildIterator_createChildEdge

`ChildIterator_createChildEdge` = function(self, sourceIndex, targetIndex, flow, directed, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  sourceIndex = as.integer(sourceIndex);
  
  if(length(sourceIndex) > 1) {
    warning("using only the first element of sourceIndex");
  };
  
  targetIndex = as.integer(targetIndex);
  
  if(length(targetIndex) > 1) {
    warning("using only the first element of targetIndex");
  };
  
  
  directed = as.logical(directed);
  ;.Call('R_swig_ChildIterator_createChildEdge', self, sourceIndex, targetIndex, flow, directed, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`ChildIterator_createChildEdge`, 'returnType') = 'logical'
attr(`ChildIterator_createChildEdge`, "inputTypes") = c('_p_ChildIterator', 'integer', 'integer', 'numeric', 'logical')
class(`ChildIterator_createChildEdge`) = c("SWIGFunction", class('ChildIterator_createChildEdge'))

# Start of accessor method for ChildIterator
setMethod('$', '_p_ChildIterator', function(x, name)

{
  accessorFuns = list('Equal' = ChildIterator_Equal, 'base' = ChildIterator_base, 'isEnd' = ChildIterator_isEnd, '__ref__' = ChildIterator___ref__, '__deref__' = ChildIterator___deref__, 'PlusPlusPrefix' = ChildIterator_PlusPlusPrefix, 'PlusPlusPostfix' = ChildIterator_PlusPlusPostfix, 'stepForward' = ChildIterator_stepForward, 'childIndex' = ChildIterator_childIndex, 'EqualEqual' = ChildIterator_EqualEqual, 'NotEqual' = ChildIterator_NotEqual, 'childDegree' = ChildIterator_childDegree, 'clear' = ChildIterator_clear, 'addChild' = ChildIterator_addChild, 'numSerializableChildEdges' = ChildIterator_numSerializableChildEdges, 'printState' = ChildIterator_printState, 'data' = ChildIterator_data_get, 'depth' = ChildIterator_depth_get, 'depthBelow' = ChildIterator_depthBelow_get, 'parentNode' = ChildIterator_parentNode_get, 'parentIndex' = ChildIterator_parentIndex_get, 'isLeaf' = ChildIterator_isLeaf_get, 'originalLeafIndex' = ChildIterator_originalLeafIndex_get, 'id' = ChildIterator_id_get, 'children' = ChildIterator_children_get, 'childEdges' = ChildIterator_childEdges_get, 'skip' = ChildIterator_skip_get, 'isMemoryNode' = ChildIterator_isMemoryNode_get, 'stateIndex' = ChildIterator_stateIndex_get, 'physIndex' = ChildIterator_physIndex_get, 'serializationSize' = ChildIterator_serializationSize, 'serialize' = ChildIterator_serialize, 'deserialize' = ChildIterator_deserialize, 'deserializeEdges' = ChildIterator_deserializeEdges, 'lastChild' = ChildIterator_lastChild, 'firstChild' = ChildIterator_firstChild, 'nextSibling' = ChildIterator_nextSibling, 'isLeafNode' = ChildIterator_isLeafNode, 'isLeafModule' = ChildIterator_isLeafModule, 'createChildEdge' = ChildIterator_createChildEdge);
  vaccessors = c('data', 'depth', 'depthBelow', 'parentNode', 'parentIndex', 'isLeaf', 'originalLeafIndex', 'id', 'children', 'childEdges', 'skip', 'isMemoryNode', 'stateIndex', 'physIndex');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for ChildIterator
# Start of accessor method for ChildIterator
setMethod('$<-', '_p_ChildIterator', function(x, name, value)

{
  accessorFuns = list('data' = ChildIterator_data_set, 'depth' = ChildIterator_depth_set, 'depthBelow' = ChildIterator_depthBelow_set, 'parentNode' = ChildIterator_parentNode_set, 'parentIndex' = ChildIterator_parentIndex_set, 'isLeaf' = ChildIterator_isLeaf_set, 'originalLeafIndex' = ChildIterator_originalLeafIndex_set, 'id' = ChildIterator_id_set, 'children' = ChildIterator_children_set, 'childEdges' = ChildIterator_childEdges_set, 'skip' = ChildIterator_skip_set, 'isMemoryNode' = ChildIterator_isMemoryNode_set, 'stateIndex' = ChildIterator_stateIndex_set, 'physIndex' = ChildIterator_physIndex_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_ChildIterator', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = ChildIterator_data_set, 'depth' = ChildIterator_depth_set, 'depthBelow' = ChildIterator_depthBelow_set, 'parentNode' = ChildIterator_parentNode_set, 'parentIndex' = ChildIterator_parentIndex_set, 'isLeaf' = ChildIterator_isLeaf_set, 'originalLeafIndex' = ChildIterator_originalLeafIndex_set, 'id' = ChildIterator_id_set, 'children' = ChildIterator_children_set, 'childEdges' = ChildIterator_childEdges_set, 'skip' = ChildIterator_skip_set, 'isMemoryNode' = ChildIterator_isMemoryNode_set, 'stateIndex' = ChildIterator_stateIndex_set, 'physIndex' = ChildIterator_physIndex_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for ChildIterator
setMethod('delete', '_p_ChildIterator', function(obj) {delete_ChildIterator(obj)})
# Start of new_HierarchicalNetwork

`HierarchicalNetwork` = function(conf)
{
  if (inherits(conf, "ExternalReference")) conf = slot(conf,"ref") 
  ;ans = .Call('R_swig_new_HierarchicalNetwork', conf, PACKAGE='infomap');
  ans <- new("_p_HierarchicalNetwork", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_HierarchicalNetwork)
  ans
  
}

attr(`HierarchicalNetwork`, 'returnType') = '_p_HierarchicalNetwork'
attr(`HierarchicalNetwork`, "inputTypes") = c('_p_Config')
class(`HierarchicalNetwork`) = c("SWIGFunction", class('HierarchicalNetwork'))

# Start of delete_HierarchicalNetwork

`delete_HierarchicalNetwork` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_HierarchicalNetwork', self, PACKAGE='infomap');
  
}

attr(`delete_HierarchicalNetwork`, 'returnType') = 'void'
attr(`delete_HierarchicalNetwork`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`delete_HierarchicalNetwork`) = c("SWIGFunction", class('delete_HierarchicalNetwork'))

# Start of HierarchicalNetwork_init

`HierarchicalNetwork_init` = function(self, networkName, codelength, oneLevelCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  networkName = as(networkName, "character"); 
  
  
  ;.Call('R_swig_HierarchicalNetwork_init', self, networkName, codelength, oneLevelCodelength, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_init`, 'returnType') = 'void'
attr(`HierarchicalNetwork_init`, "inputTypes") = c('_p_HierarchicalNetwork', 'character', 'numeric', 'numeric')
class(`HierarchicalNetwork_init`) = c("SWIGFunction", class('HierarchicalNetwork_init'))

# Start of HierarchicalNetwork_clear

`HierarchicalNetwork_clear__SWIG_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_clear__SWIG_0', self, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_clear__SWIG_0`, 'returnType') = 'void'
attr(`HierarchicalNetwork_clear__SWIG_0`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_clear__SWIG_0`) = c("SWIGFunction", class('HierarchicalNetwork_clear__SWIG_0'))

# Start of HierarchicalNetwork_clear

`HierarchicalNetwork_clear__SWIG_1` = function(self, conf)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(conf, "ExternalReference")) conf = slot(conf,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_clear__SWIG_1', self, conf, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_clear__SWIG_1`, 'returnType') = 'void'
attr(`HierarchicalNetwork_clear__SWIG_1`, "inputTypes") = c('_p_HierarchicalNetwork', '_p_Config')
class(`HierarchicalNetwork_clear__SWIG_1`) = c("SWIGFunction", class('HierarchicalNetwork_clear__SWIG_1'))

`HierarchicalNetwork_clear` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork')) {
      f <- HierarchicalNetwork_clear__SWIG_0; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && extends(argtypes[2], '_p_Config') && length(argv[[2]]) == 1) {
      f <- HierarchicalNetwork_clear__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for HierarchicalNetwork_clear with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of HierarchicalNetwork_getRootNode

`HierarchicalNetwork_getRootNode` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_HierarchicalNetwork_getRootNode', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`HierarchicalNetwork_getRootNode`, 'returnType') = '_p_SNode'
attr(`HierarchicalNetwork_getRootNode`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_getRootNode`) = c("SWIGFunction", class('HierarchicalNetwork_getRootNode'))

# Start of HierarchicalNetwork_numTopModules

`HierarchicalNetwork_numTopModules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_numTopModules', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_numTopModules`, 'returnType') = 'integer'
attr(`HierarchicalNetwork_numTopModules`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_numTopModules`) = c("SWIGFunction", class('HierarchicalNetwork_numTopModules'))

# Start of HierarchicalNetwork_leafIter

`HierarchicalNetwork_leafIter__SWIG_0` = function(self, moduleIndexDepth, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  moduleIndexDepth = as.integer(moduleIndexDepth);
  
  if(length(moduleIndexDepth) > 1) {
    warning("using only the first element of moduleIndexDepth");
  };
  
  ;ans = .Call('R_swig_HierarchicalNetwork_leafIter__SWIG_0', self, moduleIndexDepth, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans);
  
  ans
  
}

attr(`HierarchicalNetwork_leafIter__SWIG_0`, 'returnType') = '_p_LeafIterator'
attr(`HierarchicalNetwork_leafIter__SWIG_0`, "inputTypes") = c('_p_HierarchicalNetwork', 'integer')
class(`HierarchicalNetwork_leafIter__SWIG_0`) = c("SWIGFunction", class('HierarchicalNetwork_leafIter__SWIG_0'))

# Start of HierarchicalNetwork_leafIter

`HierarchicalNetwork_leafIter__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_HierarchicalNetwork_leafIter__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_LeafIterator", ref=ans);
  
  ans
  
}

attr(`HierarchicalNetwork_leafIter__SWIG_1`, 'returnType') = '_p_LeafIterator'
attr(`HierarchicalNetwork_leafIter__SWIG_1`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_leafIter__SWIG_1`) = c("SWIGFunction", class('HierarchicalNetwork_leafIter__SWIG_1'))

`HierarchicalNetwork_leafIter` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork')) {
      f <- HierarchicalNetwork_leafIter__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- HierarchicalNetwork_leafIter__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for HierarchicalNetwork_leafIter with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of HierarchicalNetwork_treeIter

`HierarchicalNetwork_treeIter__SWIG_0` = function(self, moduleIndexDepth, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  moduleIndexDepth = as.integer(moduleIndexDepth);
  
  if(length(moduleIndexDepth) > 1) {
    warning("using only the first element of moduleIndexDepth");
  };
  
  ;ans = .Call('R_swig_HierarchicalNetwork_treeIter__SWIG_0', self, moduleIndexDepth, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans);
  
  ans
  
}

attr(`HierarchicalNetwork_treeIter__SWIG_0`, 'returnType') = '_p_TreeIterator'
attr(`HierarchicalNetwork_treeIter__SWIG_0`, "inputTypes") = c('_p_HierarchicalNetwork', 'integer')
class(`HierarchicalNetwork_treeIter__SWIG_0`) = c("SWIGFunction", class('HierarchicalNetwork_treeIter__SWIG_0'))

# Start of HierarchicalNetwork_treeIter

`HierarchicalNetwork_treeIter__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_HierarchicalNetwork_treeIter__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_TreeIterator", ref=ans);
  
  ans
  
}

attr(`HierarchicalNetwork_treeIter__SWIG_1`, 'returnType') = '_p_TreeIterator'
attr(`HierarchicalNetwork_treeIter__SWIG_1`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_treeIter__SWIG_1`) = c("SWIGFunction", class('HierarchicalNetwork_treeIter__SWIG_1'))

`HierarchicalNetwork_treeIter` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork')) {
      f <- HierarchicalNetwork_treeIter__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- HierarchicalNetwork_treeIter__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for HierarchicalNetwork_treeIter with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of HierarchicalNetwork_addNode

`HierarchicalNetwork_addNode` = function(self, parent, flow, exitFlow, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref") 
  
  
  ;ans = .Call('R_swig_HierarchicalNetwork_addNode', self, parent, flow, exitFlow, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`HierarchicalNetwork_addNode`, 'returnType') = '_p_SNode'
attr(`HierarchicalNetwork_addNode`, "inputTypes") = c('_p_HierarchicalNetwork', '_p_SNode', 'numeric', 'numeric')
class(`HierarchicalNetwork_addNode`) = c("SWIGFunction", class('HierarchicalNetwork_addNode'))

# Start of HierarchicalNetwork_addLeafNode

`HierarchicalNetwork_addLeafNode__SWIG_0` = function(self, parent, flow, exitFlow, name, leafIndex, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref") 
  
  
  name = as(name, "character"); 
  leafIndex = as.integer(leafIndex);
  
  if(length(leafIndex) > 1) {
    warning("using only the first element of leafIndex");
  };
  
  ;ans = .Call('R_swig_HierarchicalNetwork_addLeafNode__SWIG_0', self, parent, flow, exitFlow, name, leafIndex, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`HierarchicalNetwork_addLeafNode__SWIG_0`, 'returnType') = '_p_SNode'
attr(`HierarchicalNetwork_addLeafNode__SWIG_0`, "inputTypes") = c('_p_HierarchicalNetwork', '_p_SNode', 'numeric', 'numeric', 'character', 'integer')
class(`HierarchicalNetwork_addLeafNode__SWIG_0`) = c("SWIGFunction", class('HierarchicalNetwork_addLeafNode__SWIG_0'))

# Start of HierarchicalNetwork_addLeafNode

`HierarchicalNetwork_addLeafNode__SWIG_1` = function(self, parent, flow, exitFlow, name, leafIndex, originalIndex, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref") 
  
  
  name = as(name, "character"); 
  leafIndex = as.integer(leafIndex);
  
  if(length(leafIndex) > 1) {
    warning("using only the first element of leafIndex");
  };
  
  originalIndex = as.integer(originalIndex);
  
  if(length(originalIndex) > 1) {
    warning("using only the first element of originalIndex");
  };
  
  ;ans = .Call('R_swig_HierarchicalNetwork_addLeafNode__SWIG_1', self, parent, flow, exitFlow, name, leafIndex, originalIndex, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`HierarchicalNetwork_addLeafNode__SWIG_1`, 'returnType') = '_p_SNode'
attr(`HierarchicalNetwork_addLeafNode__SWIG_1`, "inputTypes") = c('_p_HierarchicalNetwork', '_p_SNode', 'numeric', 'numeric', 'character', 'integer', 'integer')
class(`HierarchicalNetwork_addLeafNode__SWIG_1`) = c("SWIGFunction", class('HierarchicalNetwork_addLeafNode__SWIG_1'))

# Start of HierarchicalNetwork_addLeafNode

`HierarchicalNetwork_addLeafNode__SWIG_2` = function(self, parent, flow, exitFlow, name, leafIndex, originalIndex, isMemoryNode, stateIndex, physIndex, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref") 
  
  
  name = as(name, "character"); 
  leafIndex = as.integer(leafIndex);
  
  if(length(leafIndex) > 1) {
    warning("using only the first element of leafIndex");
  };
  
  originalIndex = as.integer(originalIndex);
  
  if(length(originalIndex) > 1) {
    warning("using only the first element of originalIndex");
  };
  
  isMemoryNode = as.logical(isMemoryNode);
  stateIndex = as.integer(stateIndex);
  
  if(length(stateIndex) > 1) {
    warning("using only the first element of stateIndex");
  };
  
  physIndex = as.integer(physIndex);
  
  if(length(physIndex) > 1) {
    warning("using only the first element of physIndex");
  };
  
  ;ans = .Call('R_swig_HierarchicalNetwork_addLeafNode__SWIG_2', self, parent, flow, exitFlow, name, leafIndex, originalIndex, isMemoryNode, stateIndex, physIndex, as.logical(.copy), PACKAGE='infomap');
  ans <- new("_p_SNode", ref=ans) ;
  
  ans
  
}

attr(`HierarchicalNetwork_addLeafNode__SWIG_2`, 'returnType') = '_p_SNode'
attr(`HierarchicalNetwork_addLeafNode__SWIG_2`, "inputTypes") = c('_p_HierarchicalNetwork', '_p_SNode', 'numeric', 'numeric', 'character', 'integer', 'integer', 'logical', 'integer', 'integer')
class(`HierarchicalNetwork_addLeafNode__SWIG_2`) = c("SWIGFunction", class('HierarchicalNetwork_addLeafNode__SWIG_2'))

`HierarchicalNetwork_addLeafNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 6) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && extends(argtypes[2], '_p_SNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 )) {
      f <- HierarchicalNetwork_addLeafNode__SWIG_0; 
    }
  } else if (argc == 7) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && extends(argtypes[2], '_p_SNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 )) {
      f <- HierarchicalNetwork_addLeafNode__SWIG_1; 
    }
  } else if (argc == 10) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && extends(argtypes[2], '_p_SNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && ( (is.integer(argv[[6]]) || is.numeric(argv[[6]])) && length(argv[[6]]) == 1 ) && ( (is.integer(argv[[7]]) || is.numeric(argv[[7]])) && length(argv[[7]]) == 1 ) && ( is.logical(argv[[8]]) && length(argv[[8]]) == 1 ) && ( (is.integer(argv[[9]]) || is.numeric(argv[[9]])) && length(argv[[9]]) == 1 ) && ( (is.integer(argv[[10]]) || is.numeric(argv[[10]])) && length(argv[[10]]) == 1 )) {
      f <- HierarchicalNetwork_addLeafNode__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for HierarchicalNetwork_addLeafNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of HierarchicalNetwork_prepareAddLeafNodes

`HierarchicalNetwork_prepareAddLeafNodes` = function(self, numLeafNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  numLeafNodes = as.integer(numLeafNodes);
  
  if(length(numLeafNodes) > 1) {
    warning("using only the first element of numLeafNodes");
  };
  
  ;.Call('R_swig_HierarchicalNetwork_prepareAddLeafNodes', self, numLeafNodes, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_prepareAddLeafNodes`, 'returnType') = 'void'
attr(`HierarchicalNetwork_prepareAddLeafNodes`, "inputTypes") = c('_p_HierarchicalNetwork', 'integer')
class(`HierarchicalNetwork_prepareAddLeafNodes`) = c("SWIGFunction", class('HierarchicalNetwork_prepareAddLeafNodes'))

# Start of HierarchicalNetwork_addLeafEdge

`HierarchicalNetwork_addLeafEdge` = function(self, sourceLeafNodeIndex, targetLeafNodeIndex, flow, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  sourceLeafNodeIndex = as.integer(sourceLeafNodeIndex);
  
  if(length(sourceLeafNodeIndex) > 1) {
    warning("using only the first element of sourceLeafNodeIndex");
  };
  
  targetLeafNodeIndex = as.integer(targetLeafNodeIndex);
  
  if(length(targetLeafNodeIndex) > 1) {
    warning("using only the first element of targetLeafNodeIndex");
  };
  
  
  ;.Call('R_swig_HierarchicalNetwork_addLeafEdge', self, sourceLeafNodeIndex, targetLeafNodeIndex, flow, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_addLeafEdge`, 'returnType') = 'logical'
attr(`HierarchicalNetwork_addLeafEdge`, "inputTypes") = c('_p_HierarchicalNetwork', 'integer', 'integer', 'numeric')
class(`HierarchicalNetwork_addLeafEdge`) = c("SWIGFunction", class('HierarchicalNetwork_addLeafEdge'))

# Start of HierarchicalNetwork_propagateNodeNameUpInHierarchy

`HierarchicalNetwork_propagateNodeNameUpInHierarchy` = function(self, node)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(node, "ExternalReference")) node = slot(node,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_propagateNodeNameUpInHierarchy', self, node, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_propagateNodeNameUpInHierarchy`, 'returnType') = 'void'
attr(`HierarchicalNetwork_propagateNodeNameUpInHierarchy`, "inputTypes") = c('_p_HierarchicalNetwork', '_p_SNode')
class(`HierarchicalNetwork_propagateNodeNameUpInHierarchy`) = c("SWIGFunction", class('HierarchicalNetwork_propagateNodeNameUpInHierarchy'))

# Start of HierarchicalNetwork_writeStreamableTree

`HierarchicalNetwork_writeStreamableTree` = function(self, fileName, writeEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  fileName = as(fileName, "character"); 
  writeEdges = as.logical(writeEdges);
  ;.Call('R_swig_HierarchicalNetwork_writeStreamableTree', self, fileName, writeEdges, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_writeStreamableTree`, 'returnType') = 'void'
attr(`HierarchicalNetwork_writeStreamableTree`, "inputTypes") = c('_p_HierarchicalNetwork', 'character', 'logical')
class(`HierarchicalNetwork_writeStreamableTree`) = c("SWIGFunction", class('HierarchicalNetwork_writeStreamableTree'))

# Start of HierarchicalNetwork_readStreamableTree

`HierarchicalNetwork_readStreamableTree` = function(self, fileName)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  fileName = as(fileName, "character"); 
  ;.Call('R_swig_HierarchicalNetwork_readStreamableTree', self, fileName, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_readStreamableTree`, 'returnType') = 'void'
attr(`HierarchicalNetwork_readStreamableTree`, "inputTypes") = c('_p_HierarchicalNetwork', 'character')
class(`HierarchicalNetwork_readStreamableTree`) = c("SWIGFunction", class('HierarchicalNetwork_readStreamableTree'))

# Start of HierarchicalNetwork_writeHumanReadableTree

`HierarchicalNetwork_writeHumanReadableTree__SWIG_0` = function(self, fileName, writeHierarchicalNetworkEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  fileName = as(fileName, "character"); 
  writeHierarchicalNetworkEdges = as.logical(writeHierarchicalNetworkEdges);
  ;.Call('R_swig_HierarchicalNetwork_writeHumanReadableTree__SWIG_0', self, fileName, writeHierarchicalNetworkEdges, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_writeHumanReadableTree__SWIG_0`, 'returnType') = 'void'
attr(`HierarchicalNetwork_writeHumanReadableTree__SWIG_0`, "inputTypes") = c('_p_HierarchicalNetwork', 'character', 'logical')
class(`HierarchicalNetwork_writeHumanReadableTree__SWIG_0`) = c("SWIGFunction", class('HierarchicalNetwork_writeHumanReadableTree__SWIG_0'))

# Start of HierarchicalNetwork_writeHumanReadableTree

`HierarchicalNetwork_writeHumanReadableTree__SWIG_1` = function(self, fileName)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  fileName = as(fileName, "character"); 
  ;.Call('R_swig_HierarchicalNetwork_writeHumanReadableTree__SWIG_1', self, fileName, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_writeHumanReadableTree__SWIG_1`, 'returnType') = 'void'
attr(`HierarchicalNetwork_writeHumanReadableTree__SWIG_1`, "inputTypes") = c('_p_HierarchicalNetwork', 'character')
class(`HierarchicalNetwork_writeHumanReadableTree__SWIG_1`) = c("SWIGFunction", class('HierarchicalNetwork_writeHumanReadableTree__SWIG_1'))

`HierarchicalNetwork_writeHumanReadableTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- HierarchicalNetwork_writeHumanReadableTree__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- HierarchicalNetwork_writeHumanReadableTree__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for HierarchicalNetwork_writeHumanReadableTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of HierarchicalNetwork_writeClu

`HierarchicalNetwork_writeClu__SWIG_0` = function(self, fileName, moduleIndexDepth)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  fileName = as(fileName, "character"); 
  moduleIndexDepth = as.integer(moduleIndexDepth);
  
  if(length(moduleIndexDepth) > 1) {
    warning("using only the first element of moduleIndexDepth");
  };
  
  ;.Call('R_swig_HierarchicalNetwork_writeClu__SWIG_0', self, fileName, moduleIndexDepth, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_writeClu__SWIG_0`, 'returnType') = 'void'
attr(`HierarchicalNetwork_writeClu__SWIG_0`, "inputTypes") = c('_p_HierarchicalNetwork', 'character', 'integer')
class(`HierarchicalNetwork_writeClu__SWIG_0`) = c("SWIGFunction", class('HierarchicalNetwork_writeClu__SWIG_0'))

# Start of HierarchicalNetwork_writeClu

`HierarchicalNetwork_writeClu__SWIG_1` = function(self, fileName)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  fileName = as(fileName, "character"); 
  ;.Call('R_swig_HierarchicalNetwork_writeClu__SWIG_1', self, fileName, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_writeClu__SWIG_1`, 'returnType') = 'void'
attr(`HierarchicalNetwork_writeClu__SWIG_1`, "inputTypes") = c('_p_HierarchicalNetwork', 'character')
class(`HierarchicalNetwork_writeClu__SWIG_1`) = c("SWIGFunction", class('HierarchicalNetwork_writeClu__SWIG_1'))

`HierarchicalNetwork_writeClu` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- HierarchicalNetwork_writeClu__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_HierarchicalNetwork') && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- HierarchicalNetwork_writeClu__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for HierarchicalNetwork_writeClu with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of HierarchicalNetwork_readHumanReadableTree

`HierarchicalNetwork_readHumanReadableTree` = function(self, fileName)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  fileName = as(fileName, "character"); 
  ;.Call('R_swig_HierarchicalNetwork_readHumanReadableTree', self, fileName, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_readHumanReadableTree`, 'returnType') = 'void'
attr(`HierarchicalNetwork_readHumanReadableTree`, "inputTypes") = c('_p_HierarchicalNetwork', 'character')
class(`HierarchicalNetwork_readHumanReadableTree`) = c("SWIGFunction", class('HierarchicalNetwork_readHumanReadableTree'))

# Start of HierarchicalNetwork_writeMap

`HierarchicalNetwork_writeMap` = function(self, fileName)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  fileName = as(fileName, "character"); 
  ;.Call('R_swig_HierarchicalNetwork_writeMap', self, fileName, PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_writeMap`, 'returnType') = 'void'
attr(`HierarchicalNetwork_writeMap`, "inputTypes") = c('_p_HierarchicalNetwork', 'character')
class(`HierarchicalNetwork_writeMap`) = c("SWIGFunction", class('HierarchicalNetwork_writeMap'))

# Start of HierarchicalNetwork_numLeafNodes

`HierarchicalNetwork_numLeafNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_numLeafNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_numLeafNodes`, 'returnType') = 'integer'
attr(`HierarchicalNetwork_numLeafNodes`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_numLeafNodes`) = c("SWIGFunction", class('HierarchicalNetwork_numLeafNodes'))

# Start of HierarchicalNetwork_numLeafEdges

`HierarchicalNetwork_numLeafEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_numLeafEdges', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_numLeafEdges`, 'returnType') = 'integer'
attr(`HierarchicalNetwork_numLeafEdges`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_numLeafEdges`) = c("SWIGFunction", class('HierarchicalNetwork_numLeafEdges'))

# Start of HierarchicalNetwork_numNodesInTree

`HierarchicalNetwork_numNodesInTree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_numNodesInTree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_numNodesInTree`, 'returnType') = 'integer'
attr(`HierarchicalNetwork_numNodesInTree`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_numNodesInTree`) = c("SWIGFunction", class('HierarchicalNetwork_numNodesInTree'))

# Start of HierarchicalNetwork_maxDepth

`HierarchicalNetwork_maxDepth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_maxDepth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_maxDepth`, 'returnType') = 'integer'
attr(`HierarchicalNetwork_maxDepth`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_maxDepth`) = c("SWIGFunction", class('HierarchicalNetwork_maxDepth'))

# Start of HierarchicalNetwork_codelength

`HierarchicalNetwork_codelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_codelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_codelength`, 'returnType') = 'numeric'
attr(`HierarchicalNetwork_codelength`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_codelength`) = c("SWIGFunction", class('HierarchicalNetwork_codelength'))

# Start of HierarchicalNetwork_onelevelCodelength

`HierarchicalNetwork_onelevelCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_HierarchicalNetwork_onelevelCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`HierarchicalNetwork_onelevelCodelength`, 'returnType') = 'numeric'
attr(`HierarchicalNetwork_onelevelCodelength`, "inputTypes") = c('_p_HierarchicalNetwork')
class(`HierarchicalNetwork_onelevelCodelength`) = c("SWIGFunction", class('HierarchicalNetwork_onelevelCodelength'))

# Start of accessor method for HierarchicalNetwork
setMethod('$', '_p_HierarchicalNetwork', function(x, name)

{
  accessorFuns = list('init' = HierarchicalNetwork_init, 'clear' = HierarchicalNetwork_clear, 'getRootNode' = HierarchicalNetwork_getRootNode, 'numTopModules' = HierarchicalNetwork_numTopModules, 'leafIter' = HierarchicalNetwork_leafIter, 'treeIter' = HierarchicalNetwork_treeIter, 'addNode' = HierarchicalNetwork_addNode, 'addLeafNode' = HierarchicalNetwork_addLeafNode, 'prepareAddLeafNodes' = HierarchicalNetwork_prepareAddLeafNodes, 'addLeafEdge' = HierarchicalNetwork_addLeafEdge, 'propagateNodeNameUpInHierarchy' = HierarchicalNetwork_propagateNodeNameUpInHierarchy, 'writeStreamableTree' = HierarchicalNetwork_writeStreamableTree, 'readStreamableTree' = HierarchicalNetwork_readStreamableTree, 'writeHumanReadableTree' = HierarchicalNetwork_writeHumanReadableTree, 'writeClu' = HierarchicalNetwork_writeClu, 'readHumanReadableTree' = HierarchicalNetwork_readHumanReadableTree, 'writeMap' = HierarchicalNetwork_writeMap, 'numLeafNodes' = HierarchicalNetwork_numLeafNodes, 'numLeafEdges' = HierarchicalNetwork_numLeafEdges, 'numNodesInTree' = HierarchicalNetwork_numNodesInTree, 'maxDepth' = HierarchicalNetwork_maxDepth, 'codelength' = HierarchicalNetwork_codelength, 'onelevelCodelength' = HierarchicalNetwork_onelevelCodelength);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for HierarchicalNetwork
setMethod('delete', '_p_HierarchicalNetwork', function(obj) {delete_HierarchicalNetwork(obj)})

